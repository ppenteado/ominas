<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.6.1 on Fri Jul 14 10:59:39 2017 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>grim_planes_include.pro (OMINAS API Documentation)</title>

    
    <style type="text/css" media="all">
            /* setup page */
      body { font-family: Helvetica, sans-serif; font-size: 12pt; margin: 0; padding: 0; }
      div.content { padding: 1em; }
      p { line-height: 1.4; }
      td p { padding-bottom: 0.5em; }
      img { border: 0; }
      
      /* link styles */
      a { text-decoration: none; }
      a:link, a:visited { color: #0000FF; }
      a:hover, a:focus { background: yellow; border-bottom: 1emx dotted #303099; }
      
      /* dir-overview styles */
      dt.filename { margin-top: 0.5em; }
      dl.file_listing { margin-left: 1em; }
      
      /* titles */
      h1, h2, h3, h4 { font-weight:normal; color: #871E31; margin-top: 1.5em; }
      h4 { margin-bottom: 0.25em; }
      .center { margin-left: auto; margin-right: auto; }
      .small { font-family: Verdana, Helvetica, sans-serif; font-size: 90%; }
      .smaller { font-family: Verdana, Helvetica, sans-serif; font-size: 80%; }
      .smallest { font-family: Verdana, Helvetica, sans-serif; font-size: 70%; }
      h1.basename { margin-top: 0; margin-bottom: 0; }
      h1.basename span.file-attributes { font-size: 70%; margin-left: 3em; color: #384806; }
      h2.directory { font-size: 90%; margin-bottom: 0; }
      h2.routine-name { margin-top: 0; margin-bottom: 0; }
      p.categories { color: #384806; margin-top: 0; }
      span.file_attribute { float: right; color: #384806; margin: 0 0 1em 3em; }
      div#file_comments { margin-top: 1em; }
      
      div.routine-details { border: 1px dotted #C0C0C0; margin-top: 1em; padding: 1em; }
      span.routine-attributes { font-size: 70%; margin-left: 3em; color: #384806; }
      div.details dt { color: #871E31; margin-left: 2em; }
      div.details dt span { color: #384806; margin-left: 2em; }
      div.details dd { margin: 0.5em 2em 1em 4em; }
      a.top {
        font-family: Verdana, Helvetica, sans-serif;
        font-size: 8pt;
        font-weight: bold;
        color: #5070ff;
        text-transform: uppercase;
        float: right;
        margin-left: 1em;
      }
      
      /* comments */
      .pre { white-space: pre; }
      
      /* code styles */
      code { font-family: Monaco, "Courier New", Courier, monospace; font-size: 95%; }
      code.listing { white-space: pre; display: block; margin: 0.75em 0 0.75em 0; padding: 0 3em 0 1em; line-height: 1.4em; }
      code.source { white-space: pre; display: block; }
      code.source span.comments { color: #408080; }
      .syntax { margin-top: 1em; margin-left: 1.5em; text-indent: -1.5em; }
      .var { font-style: italic; }
      .argument { } /* white-space: nowrap; does not work in Safari (and sometimes not even in Firefox) */
      
      dl.routine-summary dt { margin-bottom: 0.25em; }
      dl.routine-summary dd { margin-bottom: 0.5em; margin-left: 2em; }
      
      ul.inherited-method-summary { padding-left: 0em; margin-left: 0em; }
      
      /* general styles */
      ul li { list-style-type: none; }
      table { empty-cells: show; }
      thead { color: #871E31; }
      dd { margin-bottom: 0.35em; }
      input, textarea { background: #F3F6ED; border: #E1D6C6 1px solid; padding: 2px 1em 2px 0.5em; }
      input.text { background: #FFFFC0; }
      
      div.note { margin: 1em 2em 1em 2em; background: #EFEFEF; border: 1px #A0A0A0 dotted; padding: 0 1em 0 1em; }
      p.indent { margin-left: 2em; }
      
      /* An attribute table is a vertical list of name-value pairs. */
      table.box {
        background: #EFEFEF;
        border: 1px #A0A0A0 dotted;
        padding-top: 0.75em;
        padding-bottom: 0.75em;
      }
      table.attribute { padding-left: 0.75em; padding-right: 0.75em; }
      table td { vertical-align: top; }
      table.attribute p { margin: 0; }
      table td.name { font-style: normal; padding-right: 1.5em; }
      ul.fieldslist { padding-top: 0; color: #909090; }
      ul.fieldslist li { margin-bottom: 0.25em; }
      span.fieldname { color: #000000; }
      
      dl.attribute dt { color: #990000; }
      
      /* header/navbar styles */
      div.header { padding: 2em 2em 0 2em; background: #9E9D7B; border-bottom: 2px #262626 solid; }
      div.header h1 { color: white; margin:0; font-weight: normal; }
      div.header h2 { color: white; margin-top: 0; margin-bottom: 1em; font-weight: normal; font-style: italic; font-size: 100%; }
      table.navbar { background: #CCC097; margin: 0; padding: 0; border-bottom: 1px #262626 dotted; width: 100%; }
      table.navbar td { padding: 4px 0.5em 3px 0.5em; white-space: nowrap; vertical-align: top; }
      table.navbar td.flexible { width: 100%; text-align: right; padding-right: 1em; white-space: nowrap; }
      table.navbar td.selected { background: #262626; }
      table.navbar td.selected, table.navbar td.selected a { color: white; }
      table.navbar a:hover, table.navbar a:focus { background: inherit; border-bottom: 1px solid #303099; }
      p.localnavbar { text-align: right; margin: 0.2em 1em 0.2em 0.2em; padding: 0; }
      
      /* CSS graphics styles */
      div.box {
        margin-left: 0.25em;
        display: inline-block;
        width: 0.9em;
        height: 0.9em;
        vertical-align: -1px;
      }
      .red { background-color: #A00; }
      .orange { background-color: #F40; }
      .green { background-color: #480; }
      
      /* index styles */
      span.index_type { margin-left: 1em; }
      dl.index_listing dd { margin-bottom: 0.5em; margin-left: 2em; }
      dl.index_listing dd p { margin-top: 0.2em; margin-bottom: 0em; }
      
      /* search styles */
      fieldset { border: #ddd 1px solid; padding: 1em; margin-top: 3em; }
      legend { color: #871E31; font-size: 120%; }
      label { white-space: nowrap; }
      p.description { margin: 2em 2em 1em 2em; }
      form table td.name { vertical-align: middle; }
      
      /* footer styles */
      div.footer { padding: 0.5em 1em 0.5em 1em; background: #EFEFEF; border-top: 1px #A0A0A0 dotted; }
      div.footer table { width: 100%; }
      div.footer td.right { text-align: right; }

    </style>
    <style type="text/css" media="print">
            p.localnavbar { display: none; }
      
      div.header { background: white; }
      div.header h1 { color: black; }
      div.header h2 { color: black; }

    </style>
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="grim_planes_include.pro (OMINAS API Documentation)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">;=============================================================================</span>
<span class="comments">; grim_next_plane</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_next_plane:source"></a>pro grim_next_plane, grim_data, norefresh=norefresh

 if(grim_data.n_planes EQ 1) then return

 <span class="comments">;-----------------------------------</span>
 <span class="comments">; change to next valid plane</span>
 <span class="comments">;-----------------------------------</span>
 flags = *grim_data.pl_flags_p

 repeat $
  begin
   grim_data.pn = grim_data.pn + 1
   if(grim_data.pn EQ grim_data.n_planes) then grim_data.pn = 0
  endrep until(flags[grim_data.pn] NE 0)

 grim_set_data, grim_data

 no_erase = 1 
 if(grim_data.type EQ 'plot') then no_erase = 0
 
 if(NOT keyword_set(norefresh)) then grim_refresh, grim_data, no_erase=no_erase, /noglass

 grim_call_plane_callbacks, grim_data
 grim_sync_planes, grim_data
end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_previous_plane</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_previous_plane:source"></a>pro grim_previous_plane, grim_data

 if(grim_data.n_planes EQ 1) then return

 <span class="comments">;-----------------------------------</span>
 <span class="comments">; change to next valid plane</span>
 <span class="comments">;-----------------------------------</span>
 flags = *grim_data.pl_flags_p

 repeat $
  begin
   grim_data.pn = grim_data.pn - 1
   if(grim_data.pn EQ -1) then grim_data.pn = grim_data.n_planes-1
  endrep until(flags[grim_data.pn] NE 0)

 grim_set_data, grim_data

 no_erase = 1 
 if(grim_data.type EQ 'plot') then no_erase = 0
 
 grim_refresh, grim_data, no_erase=no_erase, /noglass
 grim_call_plane_callbacks, grim_data
 grim_sync_planes, grim_data
end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_get_plane</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_get_plane:source"></a>function grim_get_plane, grim_data, all=all, pn=pn, visible=visible

 if(keyword_set(all)) then $
  begin
   flags = *grim_data.pl_flags_p
   pn = where(flags NE 0)
   if(pn[0] EQ -1) then return, 0
  end 

 if(n_elements(pn) NE 0) then pns = pn $
 else pns = grim_data.pn

 planes = (*grim_data.planes_p)[pns]
 return, planes
end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_test_map</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_test_map:source"></a>function grim_test_map, grim_data, plane=plane

 if(NOT keyword_set(plane)) then plane = grim_get_plane(grim_data)

 if(dat_instrument(plane.dd) EQ 'MAP') then return, 1

 if(NOT keyword_set(*plane.cd_p)) then return, 0

 if(cor_class(*plane.cd_p) EQ 'MAP') then return, 1

 return, 0
end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_test_rgb</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_test_rgb:source"></a>function grim_test_rgb, grim_data, plane
 planes = grim_get_plane(grim_data, /all)
 w = where(planes.dd EQ plane.dd)
 if(n_elements(w) GT 1) then return, 0
 return, n_elements(dat_dim(plane.dd, /true) EQ 3)
end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_get_image</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_get_image:source"></a>function grim_get_image, grim_data, plane=plane, abscissa=abscissa, $
   current=current, sample=sample, channel=channel, nd=nd

 if(NOT keyword_set(plane)) then plane = grim_get_plane(grim_data)

 dim = (dat_dim(plane.dd))[0:1]

 <span class="comments">;--------------------------------------------------------------------</span>
 <span class="comments">; if rgb plane, then override offset to yield image corresponding</span>
 <span class="comments">; to specified channel</span>
 <span class="comments">;--------------------------------------------------------------------</span>
 if(grim_test_rgb(grim_data, plane)) then $
  begin
   true = 0
   if(NOT keyword_set(channel)) then true = 1 $
   else slice = channel
  end

 <span class="comments">;--------------------------------------------------------------------</span>
 <span class="comments">; return image</span>
 <span class="comments">;--------------------------------------------------------------------</span>
 return, dat_data(plane.dd, true=true, $
          sample=sample, current=current, nd=nd, slice=slice, abscissa=abscissa)
end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_stretch_plane</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_stretch_plane:source"></a>pro grim_stretch_plane, grim_data, planes

 n = n_elements(planes)

 if(n GT 1) then grim_print, 'Auto stretching all planes...'

 for i=0, n-1 do $
  begin
   image = grim_get_image(grim_data, plane=planes[i], /current)

   test = image_auto_stretch(bytscl(image), min=min, max=max)
   planes[i].cmd.bottom = min
   planes[i].cmd.top = max
   grim_set_plane, grim_data, planes[i], pn=planes[i].pn
  end

 if(n GT 1) then  grim_print, 'Done', /append
end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_plane_set_visible</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_plane_set_visible:source"></a>pro grim_plane_set_visible, grim_data, planes, val, toggle=toggle

 if(keyword_set(toggle)) then $
  begin
   w = where(planes.visible EQ 1)
   ww = where(planes.visible EQ 0)
   if(w[0] NE -1) then planes[w].visible = 0
   if(ww[0] NE -1) then planes[ww].visible = 1
  end $
 else planes.visible = val

 grim_set_plane, grim_data, planes, pn=planes.pn
end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_get_visible_planes</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_get_visible_planes:source"></a>function grim_get_visible_planes, grim_data

 plane = grim_get_plane(grim_data)
 all_planes = grim_get_plane(grim_data, /all)
 w = where(all_planes.visible)

 if(NOT plane.visible) then planes = plane
 if(w[0] NE -1) then planes = append_array(planes, all_planes[w])

 return, planes
end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_set_plane</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_set_plane:source"></a>pro grim_set_plane, grim_data, plane, pn=pn

 if(NOT ptr_valid(grim_data.planes_p)) then return

 if(n_elements(pn) NE 0) then (*grim_data.planes_p)[pn] = plane $
<span class="comments">; else (*grim_data.planes_p)[grim_data.pn] = plane</span>
 else (*grim_data.planes_p)[plane.pn] = plane

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_rm_plane</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_rm_plane:source"></a>pro grim_rm_plane, grim_data, pn

 <span class="comments">;---------------------------------------------------------------</span>
 <span class="comments">; if this is the only plane, then exit</span>
 <span class="comments">;---------------------------------------------------------------</span>
 w = where(*grim_data.pl_flags_p EQ 1)
 if(n_elements(w) EQ 1) then $
  begin
   grim_exit, grim_data
   return
  end

 <span class="comments">;---------------------------------------------------------------</span>
 <span class="comments">; mark the specified plane as inactive</span>
 <span class="comments">;  NOTE:  The data for the plane still exists and may continue</span>
 <span class="comments">;         to be used from the command line.</span>
 <span class="comments">;---------------------------------------------------------------</span>
 plane = grim_get_plane(grim_data, pn=pn)
 plane.pn = -1
 grim_set_plane, grim_data, plane, pn=pn

 (*grim_data.pl_flags_p)[pn] = 0

 <span class="comments">;---------------------------------------------------------------</span>
 <span class="comments">; change to a valid plane</span>
 <span class="comments">;---------------------------------------------------------------</span>
 grim_previous_plane, grim_data
 grim_refresh, grim_data


end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_crop_plane</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_crop_plane:source"></a>pro grim_crop_plane, grim_data, plane

 
 <span class="comments">;----------------------------------------------</span>
 <span class="comments">; plot: crop to visible xrange</span>
 <span class="comments">;----------------------------------------------</span>
 if(grim_data.type EQ 'plot') then $
  begin
   tvgr, grim_data.wnum, get=tvd
   xrange = tvd.xrange

   dat = dat_data(plane.dd, abscissa=x)
   w = where((x GE xrange[0]) AND (x LE xrange[1]))

   dat = dat[w]
   dat_set_data, plane.dd, dat, abscissa=x[w]
  end $
 <span class="comments">;----------------------------------------------</span>
 <span class="comments">; image: crop to visible size</span>
 <span class="comments">;----------------------------------------------</span>
 else $
  begin
   <span class="comments">;- - - - - - - - - - - - - - - - - - - - - - </span>
   <span class="comments">; sample cropped image</span>
   <span class="comments">;- - - - - - - - - - - - - - - - - - - - - - </span>
   p0 = [0,0] & p1 = [!d.x_size, !d.y_size]-1
   pp0 = round((convert_coord(/device, /to_data, p0))[0:1])
   pp1 = round((convert_coord(/device, /to_data, p1))[0:1])

   dim = dat_dim(plane.dd)
   xmin = min([pp0[0],pp1[0]])
   xmax = max([pp0[0],pp1[0]])
   ymin = min([pp0[1],pp1[1]])
   ymax = max([pp0[1],pp1[1]])

   xxmin = xmin>0
   xxmax = xmax&lt;dim[0]-1
   yymin = ymin>0
   yymax = ymax&lt;dim[1]-1

   size = [xxmax-xxmin+1, yymax-yymin+1]
   data_xy = gridgen(size, p0=[xxmin,yymin])

   im = grim_get_image(grim_data, plane=plane, sample=data_xy, /nd)
   im = reform(im, size[0], size[1], /over)

   <span class="comments">;- - - - - - - - - - - - - - - - - - - - - - </span>
   <span class="comments">; update display parameters</span>
   <span class="comments">;- - - - - - - - - - - - - - - - - - - - - - </span>
   tvim, grim_data.wnum, offset=[0,0], zoom=!d.x_size/float(xmax-xmin)

   <span class="comments">;- - - - - - - - - - - - - - - - - - - - - - </span>
   <span class="comments">; update data array</span>
   <span class="comments">;- - - - - - - - - - - - - - - - - - - - - - </span>
   dat_set_data, plane.dd, im, /noevent

   <span class="comments">;- - - - - - - - - - - - - - - - - - - - - - </span>
   <span class="comments">; modify camera pointing</span>
   <span class="comments">; need to deal with maps as well</span>
   <span class="comments">;- - - - - - - - - - - - - - - - - - - - - - </span>
   if(NOT grim_test_map(grim_data)) then $
    begin
     cd = *plane.cd_p
     if(keyword_set(cd)) then cam_set_oaxis, cd, cam_oaxis(cd) - [xxmin,yymin]
    end

   nv_flush
  end


end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_init_parms</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_init_parms:source"></a>function grim_init_parms, n, color=color, thick=thick, nsum=nsum, psym=psym, $
                          symsize=symsize


 _parm = {grim_parm_data_struct, $
		color:		ctwhite(), $
		thick:		1l, $
		nsum:		0, $
		symsize:	1., $
		psym:		-3l $
              }

 parm = replicate(_parm, n)

 if(keyword__set(color)) then parm.color = color
 if(keyword__set(thick)) then parm.thick = thick
 if(keyword__set(nsum)) then parm.nsum = nsum
 if(keyword__set(psym)) then parm.psym = psym
 if(keyword__set(symsize)) then parm.symsize = symsize

 return, parm
end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_clone_plane</span>
<span class="comments">;</span>
<span class="comments">; This is a crappy implementation</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_clone_plane:source"></a>function grim_clone_plane, grim_data, plane=plane, spawn=spawn

<span class="comments">; if(keyword_set(spawn)) then </span>
 grim_add_planes, grim_data, plane.dd, pn=pn

 new_plane = nv_clone(plane)

 new_plane.pn = pn
 (*grim_data.planes_p)[pn] = new_plane

 new_plane.cmd = colormap_descriptor(data=new_plane.pn, $
                                n_colors=grim_n_colors(dat_typecode(new_plane.dd)))

 grim_set_plane, grim_data, new_plane
 grim_set_data, grim_data

 return, new_plane
end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_channel_to_rgb</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_channel_to_rgb:source"></a>function grim_channel_to_rgb, channel

 rgb = [0b,0b,0b]
 
 <span class="comments">;----------------------------------</span>
 <span class="comments">; string: channel may be r, g, b</span>
 <span class="comments">;----------------------------------</span>
 if(size(channel, /type) EQ 7) then $
  begin
   rgb[0] = channel[i] EQ 'r' ? 1:0
   rgb[1] = channel[i] EQ 'g' ? 1:0
   rgb[2] = channel[i] EQ 'b' ? 1:0
   return, rgb
  end

 <span class="comments">;----------------------------------</span>
 <span class="comments">; byte -- channel is bit mask</span>
 <span class="comments">;----------------------------------</span>
 rgb[0] = (channel AND 1b) NE 0
 rgb[1] = (channel AND 2b) NE 0
 rgb[2] = (channel AND 4b) NE 0

 return, rgb
end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grim_add_planes</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grim_add_planes:source"></a>pro grim_add_planes, grim_data, dd, pns=pns, filter=filter, fov=fov, clip=clip, hide=hide, $
                      path=path, save_path=save_path, load_path=load_path, $
                      cam_trs=cam_trs, plt_trs=plt_trs, rng_trs=rng_trs, str_trs=str_trs, stn_trs=stn_trs, arr_trs=arr_trs, $
                      sun_trs=sun_trs, color=color, position=_position, $
                      xrange=_xrange, yrange=_yrange, $
                      thick=thick, nsum=nsum, xtitle=xtitle, ytitle=ytitle, $
                      psym=psym, symsize=symsize, max=max, visibility=visibility, channel=channel, $
                      render_sample=render_sample, render_pht_min=render_pht_min, $
                      overlays=overlays, cmd=cmd0

  pns = 0
  MAX_OVERLAYS = 128

  n_planes = n_elements(dd) 

  if(NOT keyword_set(max)) then max = 0

  if(NOT keyword_set(fov)) then fov = grim_data.def_fov
  if(NOT keyword_set(clip)) then clip = grim_data.def_clip
  if(NOT keyword_set(hide)) then hide = grim_data.def_hide
  if(NOT keyword_set(filter)) then filter = grim_data.def_filter
  if(NOT keyword_set(visibility)) then visibility = 0
  if(NOT defined(render_pht_min)) then render_pht_min = 0.02
  if(NOT keyword_set(render_sample)) then render_sample = 1

  if(NOT keyword_set(load_path)) then load_path = grim_data.def_load_path
  if(NOT keyword_set(save_path)) then save_path = grim_data.def_save_path

  if(NOT keyword_set(cam_trs)) then cam_trs = grim_data.def_cam_trs
  if(NOT keyword_set(plt_trs)) then plt_trs = grim_data.def_plt_trs
  if(NOT keyword_set(rng_trs)) then rng_trs = grim_data.def_rng_trs
  if(NOT keyword_set(str_trs)) then str_trs = grim_data.def_str_trs
  if(NOT keyword_set(stn_trs)) then stn_trs = grim_data.def_stn_trs
  if(NOT keyword_set(arr_trs)) then arr_trs = grim_data.def_arr_trs
  if(NOT keyword_set(sun_trs)) then sun_trs = grim_data.def_sun_trs

  if(NOT keyword_set(color)) then color = grim_data.def_color
  if(NOT keyword_set(thick)) then thick = grim_data.def_thick
  if(NOT keyword_set(nsum)) then nsum = grim_data.def_nsum
  if(NOT keyword_set(psym)) then psym = grim_data.def_psym
  if(NOT keyword_set(symsize)) then symsize = grim_data.def_symsize

  if(NOT keyword_set(title)) then title = grim_data.def_title
  if(NOT keyword_set(xtitle)) then xtitle = grim_data.def_xtitle
  if(NOT keyword_set(ytitle)) then ytitle = grim_data.def_ytitle

  xrange = [0.,0.]
  yrange = [0.,0.]
  if(keyword_set(_xrange)) then xrange = _xrange
  if(keyword_set(_yrange)) then yrange = _yrange
  if(n_elements(xrange)/2 NE n_planes) then $
                                    xrange = xrange#make_array(n_planes,val=1d)
  if(n_elements(yrange)/2 NE n_planes) then $
                                    yrange = yrange#make_array(n_planes,val=1d)

  position = [0.,0.,0.,0.]
  if(keyword_set(_position)) then position = _position
  dim = size(position, /dim)
  if(n_elements(dim) EQ 1) then dim = [dim,1]
  if(dim[1] NE n_planes) then position = position#make_array(n_planes,val=1d)
  if(dim[0] EQ 2) then position = [position, dblarr(2,n_planes)]


  <span class="comments">;--------------------------</span>
  <span class="comments">; plot parms data structure</span>
  <span class="comments">;--------------------------</span>
  n = n_elements(dd)
  parm = grim_init_parms(n, color=color, thick=thick, nsum=nsum, psym=psym, symsize=symsize)


  <span class="comments">;--------------------------------</span>
  <span class="comments">; 8 or 24-bit display?</span>
  <span class="comments">;--------------------------------</span>
<span class="comments">;n_colors = 256</span>
<span class="comments">;  ctmod, visual=visual</span>
<span class="comments">;  if(visual EQ 8) then n_colors = !d.n_colors $</span>
<span class="comments">;  else if(visual EQ 24) then n_colors = 256 $</span>
<span class="comments">;  else message, 'Only 8 and 24-bit displays supported.'</span>


  window, /free, /pix, xs=1, ys=1	<span class="comments">; necessary to allocate color table</span>
  ctmod

  <span class="comments">;---------------------</span>
  <span class="comments">; planes</span>
  <span class="comments">;---------------------</span>
  planes = *grim_data.planes_p
  flags = *grim_data.pl_flags_p

  if(n_elements(xtitle) EQ 1) then xtitle = make_array(n_planes, val=xtitle)
  if(n_elements(ytitle) EQ 1) then ytitle = make_array(n_planes, val=ytitle)
  if(n_elements(title) EQ 1) then title = make_array(n_planes, val=title)

  for i=0, n_planes-1 do $
   begin
    flag = 1
    if(cor_name(dd[i]) EQ 'BLANK') then flag = 2

    vis = 0b
    if(keyword_set(visibility)) then vis = visibility
    if(n_elements(vis) GT 1) then vis = vis[i]

    rgb = [1,1,1]
    if(keyword_set(channel)) then rgb = grim_channel_to_rgb(channel[i])

    plane = {grim_planes_struct, $
	<span class="comments">;---------------</span>
	<span class="comments">; bookkeeping</span>
	<span class="comments">;---------------</span>
		pn		:	-1, $
		grnum		:	grim_data.grnum, $
		filter		:	filter, $
		load_path	:	load_path, $
		save_path	:	save_path, $
		rendering	:	0, $
		render_sample	:	render_sample, $
		render_pht_min	:	render_pht_min, $
		render_show	:	1b, $
		prescaled	:	0, $			<span class="comments">; overlays always visible?</span>
		visible		:	0, $			<span class="comments">; overlays always visible?</span>
		image_visible	:	0, $
		tvd_save_p	:	ptr_new(0), $
		cradec		:	dblarr(1,3), $
		dradec		:	dblarr(1,3), $
		max		:	double(max), $
		t0		:	0d, $			<span class="comments">; last cd time, $</span>
		initial_overlays_p :	ptr_new(overlays), $

	<span class="comments">;---------------</span>
	<span class="comments">; plot viewing</span>
	<span class="comments">;---------------</span>
		xrange		:	xrange[*,i], $
		yrange		:	yrange[*,i], $
		position	:	position[*,i], $
		title		:	title[i], $
		xtitle		:	xtitle[i], $
		ytitle		:	ytitle[i], $
		parm		:	parm[i], $

	<span class="comments">;---------------</span>
	<span class="comments">; descriptors</span>
	<span class="comments">;---------------</span>
		dd		:	dd[i], $		<span class="comments">; Data descriptor</span>
		sibling_dd	:	obj_new(), $		<span class="comments">; Last sibling dd</span>
		cd_p		:	ptr_new(obj_new()), $	<span class="comments">; Camera descriptor</span>
		pd_p		:	ptr_new(obj_new()), $	<span class="comments">; Planet descriptors</span>
		rd_p		:	ptr_new(obj_new()), $	<span class="comments">; Ring descriptors</span>
		sd_p		:	ptr_new(obj_new()), $	<span class="comments">; Star descriptors</span>
		sund_p		:	ptr_new(obj_new()), $	<span class="comments">; Sun descriptor</span>
		std_p		:	ptr_new(obj_new()), $	<span class="comments">; Station descriptors</span>
		ard_p		:	ptr_new(obj_new()), $	<span class="comments">; Array descriptors</span>
		od_p		:	ptr_new(obj_new()), $	<span class="comments">; Observer descriptor</span>

	<span class="comments">;----------------------------</span>
	<span class="comments">; active objects</span>
	<span class="comments">;----------------------------</span>
<span class="comments">; it may be simpler to implement these as udata on each overlay ptd or xd</span>
		active_xd_p	:	ptr_new(obj_new()), $	<span class="comments">; Descriptors of</span>
								<span class="comments">;  active objects</span>
		active_overlays_ptdp :	ptr_new(obj_new()), $	<span class="comments">; Active overlays</span>

		active_user_tags_p	:	ptr_new(''), $	

	<span class="comments">;-----------------------------------------------------------</span>
	<span class="comments">; overlay points arrays  -- </span>
	<span class="comments">;  Each overlay array, *(*overlay_ptdps)[i], has dimensions</span>
	<span class="comments">;  (nptd, nd), where nd is the number of descriptors </span>
	<span class="comments">;  (planets, rings, etc.) and nptd is the number of arrays per</span>
	<span class="comments">;  descriptor (e.g., rings have two arrays per descriptor).</span>
	<span class="comments">;-----------------------------------------------------------</span>
		overlay_ptdps		:	ptr_new(0), $
<span class="comments">; it may be simpler to implement these as udata on each overlay ptd</span>
		overlay_names_p		:	ptr_new(''), $
		overlay_classes_p	:	ptr_new(0), $
		overlay_genres_p	:	ptr_new(0), $
		overlay_dep_p		:	ptr_new(0), $
		overlay_labels_p	:	ptr_new(0), $
		overlay_color_p		:	ptr_new(''), $
		overlay_psym_p		:	ptr_new(0), $
		overlay_symsize_p	:	ptr_new(0.), $ 
		overlay_shade_p		:	ptr_new(0.), $ 
		overlay_tlab_p		:	ptr_new(0b), $
		overlay_tshade_p	:	ptr_new(0b), $
		overlay_tfill_p		:	ptr_new(0b), $
		overlay_data_p		:	ptr_new(0), $
		override_color		:	'', $

<span class="comments">;	;-----------------------------------------------------------</span>
<span class="comments">;	; fill arrays</span>
<span class="comments">;	;-----------------------------------------------------------</span>
<span class="comments">;		fill_poly_ptdps		:	ptr_new(0), $</span>
<span class="comments">;		fill_color_p		:	ptr_new(0), $</span>
<span class="comments">;		fill_names_p		:	ptr_new(''), $</span>

	<span class="comments">;-----------------------------------------------------------</span>
	<span class="comments">; special arrays</span>
	<span class="comments">;-----------------------------------------------------------</span>
		roi_p		:	ptr_new(0), $
		roi_ptd		:	pnt_create_descriptors(), $
		star_labels_p	:	ptr_new(0), $
		mask_p		: 	ptr_new(-1), $
		tiepoint_ptdp	: 	ptr_new(obj_new()), $
		curve_ptdp	: 	ptr_new(obj_new()), $
		user_ptd_tlp	:	ptr_new(), $	
		notes_p		:	ptr_new(''), $

	<span class="comments">;-----------------</span>
	<span class="comments">; stretch</span>
	<span class="comments">;-----------------</span>
		cmd		:	{colormap_descriptor}, $

	<span class="comments">;-------------------</span>
	<span class="comments">; image visibility</span>
	<span class="comments">;-------------------</span>
		rgb		:	byte(rgb), $ 		<span class="comments">; 1=selected</span>
		visibility	:	byte(vis), $		<span class="comments">; 0=normal, 1=always</span>

	<span class="comments">;-----------------</span>
	<span class="comments">; points settings</span>
	<span class="comments">;-----------------</span>
		hide		:	byte(hide), $
		fov		:	float(fov), $
		clip		:	float(clip), $
		cam_trs		:	cam_trs, $ 
		plt_trs		:	plt_trs, $ 
		rng_trs		:	rng_trs, $ 
		str_trs		:	str_trs, $ 
		stn_trs		:	stn_trs, $ 
		arr_trs		:	arr_trs, $ 
		sun_trs		:	sun_trs $ 
	     }


    new = 0
    if(NOT keyword__set(planes)) then new = 1 $
    else if(cor_name(planes[0].dd) EQ 'BLANK') then new = 1

    <span class="comments">;------------------------------------------------</span>
    <span class="comments">; the first non-blank plane --</span>
    <span class="comments">;------------------------------------------------</span>
    if(new) then $
     begin
      planes = plane
      pn = 0
      pns = [pn]
      flags = flag
     end $
    else $
    <span class="comments">;------------------------------------------------</span>
    <span class="comments">; an additional plane</span>
    <span class="comments">;------------------------------------------------</span>
     begin
      w = where(flags EQ 0)
      <span class="comments">;------------------------------------------------</span>
      <span class="comments">; replace a defunct plane ...</span>
      <span class="comments">;------------------------------------------------</span>
      if(w[0] NE -1) then $
       begin
        pn = w[0]
        planes[pn] = plane
        flags[pn] = flag
       end $
      <span class="comments">;------------------------------------------------</span>
      <span class="comments">; append plane at end of list ...</span>
      <span class="comments">;------------------------------------------------</span>
      else $
       begin
        planes = [planes, plane]
        flags = [flags, flag]
        pn = n_elements(planes) - 1
       end

      if(NOT keyword__set(pns)) then pns = [pn] $
      else pns = [pns, pn]
     end

    planes[pn].pn = pn

    <span class="comments">;--------------------------------------------</span>
    <span class="comments">; create colormap</span>
    <span class="comments">;--------------------------------------------</span>
    planes[pn].cmd = colormap_descriptor(data=planes[pn].pn, cmd0=cmd0, $
                          n_colors=grim_n_colors(dat_typecode(planes[pn].dd)))

    <span class="comments">;--------------------------------------------</span>
    <span class="comments">; create overlay arrays</span>
    <span class="comments">;--------------------------------------------</span>
    grim_create_overlays, grim_data, plane
   end

 planes.image_visible = 1

 grim_data.n_planes = n_elements(planes)
 *grim_data.planes_p = planes
 *grim_data.pl_flags_p = flags

end
<span class="comments">;=============================================================================</span>

<a id="grim_planes_include:source"></a>pro grim_planes_include
a=!null
end

</code>
    </div>
  </body>
</html>