<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.6.1 on Fri Jul 14 10:58:42 2017 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>pg_mask.pro (OMINAS API Documentation)</title>

    
    <style type="text/css" media="all">
            /* setup page */
      body { font-family: Helvetica, sans-serif; font-size: 12pt; margin: 0; padding: 0; }
      div.content { padding: 1em; }
      p { line-height: 1.4; }
      td p { padding-bottom: 0.5em; }
      img { border: 0; }
      
      /* link styles */
      a { text-decoration: none; }
      a:link, a:visited { color: #0000FF; }
      a:hover, a:focus { background: yellow; border-bottom: 1emx dotted #303099; }
      
      /* dir-overview styles */
      dt.filename { margin-top: 0.5em; }
      dl.file_listing { margin-left: 1em; }
      
      /* titles */
      h1, h2, h3, h4 { font-weight:normal; color: #871E31; margin-top: 1.5em; }
      h4 { margin-bottom: 0.25em; }
      .center { margin-left: auto; margin-right: auto; }
      .small { font-family: Verdana, Helvetica, sans-serif; font-size: 90%; }
      .smaller { font-family: Verdana, Helvetica, sans-serif; font-size: 80%; }
      .smallest { font-family: Verdana, Helvetica, sans-serif; font-size: 70%; }
      h1.basename { margin-top: 0; margin-bottom: 0; }
      h1.basename span.file-attributes { font-size: 70%; margin-left: 3em; color: #384806; }
      h2.directory { font-size: 90%; margin-bottom: 0; }
      h2.routine-name { margin-top: 0; margin-bottom: 0; }
      p.categories { color: #384806; margin-top: 0; }
      span.file_attribute { float: right; color: #384806; margin: 0 0 1em 3em; }
      div#file_comments { margin-top: 1em; }
      
      div.routine-details { border: 1px dotted #C0C0C0; margin-top: 1em; padding: 1em; }
      span.routine-attributes { font-size: 70%; margin-left: 3em; color: #384806; }
      div.details dt { color: #871E31; margin-left: 2em; }
      div.details dt span { color: #384806; margin-left: 2em; }
      div.details dd { margin: 0.5em 2em 1em 4em; }
      a.top {
        font-family: Verdana, Helvetica, sans-serif;
        font-size: 8pt;
        font-weight: bold;
        color: #5070ff;
        text-transform: uppercase;
        float: right;
        margin-left: 1em;
      }
      
      /* comments */
      .pre { white-space: pre; }
      
      /* code styles */
      code { font-family: Monaco, "Courier New", Courier, monospace; font-size: 95%; }
      code.listing { white-space: pre; display: block; margin: 0.75em 0 0.75em 0; padding: 0 3em 0 1em; line-height: 1.4em; }
      code.source { white-space: pre; display: block; }
      code.source span.comments { color: #408080; }
      .syntax { margin-top: 1em; margin-left: 1.5em; text-indent: -1.5em; }
      .var { font-style: italic; }
      .argument { } /* white-space: nowrap; does not work in Safari (and sometimes not even in Firefox) */
      
      dl.routine-summary dt { margin-bottom: 0.25em; }
      dl.routine-summary dd { margin-bottom: 0.5em; margin-left: 2em; }
      
      ul.inherited-method-summary { padding-left: 0em; margin-left: 0em; }
      
      /* general styles */
      ul li { list-style-type: none; }
      table { empty-cells: show; }
      thead { color: #871E31; }
      dd { margin-bottom: 0.35em; }
      input, textarea { background: #F3F6ED; border: #E1D6C6 1px solid; padding: 2px 1em 2px 0.5em; }
      input.text { background: #FFFFC0; }
      
      div.note { margin: 1em 2em 1em 2em; background: #EFEFEF; border: 1px #A0A0A0 dotted; padding: 0 1em 0 1em; }
      p.indent { margin-left: 2em; }
      
      /* An attribute table is a vertical list of name-value pairs. */
      table.box {
        background: #EFEFEF;
        border: 1px #A0A0A0 dotted;
        padding-top: 0.75em;
        padding-bottom: 0.75em;
      }
      table.attribute { padding-left: 0.75em; padding-right: 0.75em; }
      table td { vertical-align: top; }
      table.attribute p { margin: 0; }
      table td.name { font-style: normal; padding-right: 1.5em; }
      ul.fieldslist { padding-top: 0; color: #909090; }
      ul.fieldslist li { margin-bottom: 0.25em; }
      span.fieldname { color: #000000; }
      
      dl.attribute dt { color: #990000; }
      
      /* header/navbar styles */
      div.header { padding: 2em 2em 0 2em; background: #9E9D7B; border-bottom: 2px #262626 solid; }
      div.header h1 { color: white; margin:0; font-weight: normal; }
      div.header h2 { color: white; margin-top: 0; margin-bottom: 1em; font-weight: normal; font-style: italic; font-size: 100%; }
      table.navbar { background: #CCC097; margin: 0; padding: 0; border-bottom: 1px #262626 dotted; width: 100%; }
      table.navbar td { padding: 4px 0.5em 3px 0.5em; white-space: nowrap; vertical-align: top; }
      table.navbar td.flexible { width: 100%; text-align: right; padding-right: 1em; white-space: nowrap; }
      table.navbar td.selected { background: #262626; }
      table.navbar td.selected, table.navbar td.selected a { color: white; }
      table.navbar a:hover, table.navbar a:focus { background: inherit; border-bottom: 1px solid #303099; }
      p.localnavbar { text-align: right; margin: 0.2em 1em 0.2em 0.2em; padding: 0; }
      
      /* CSS graphics styles */
      div.box {
        margin-left: 0.25em;
        display: inline-block;
        width: 0.9em;
        height: 0.9em;
        vertical-align: -1px;
      }
      .red { background-color: #A00; }
      .orange { background-color: #F40; }
      .green { background-color: #480; }
      
      /* index styles */
      span.index_type { margin-left: 1em; }
      dl.index_listing dd { margin-bottom: 0.5em; margin-left: 2em; }
      dl.index_listing dd p { margin-top: 0.2em; margin-bottom: 0em; }
      
      /* search styles */
      fieldset { border: #ddd 1px solid; padding: 1em; margin-top: 3em; }
      legend { color: #871E31; font-size: 120%; }
      label { white-space: nowrap; }
      p.description { margin: 2em 2em 1em 2em; }
      form table td.name { vertical-align: middle; }
      
      /* footer styles */
      div.footer { padding: 0.5em 1em 0.5em 1em; background: #EFEFEF; border-top: 1px #A0A0A0 dotted; }
      div.footer table { width: 100%; }
      div.footer td.right { text-align: right; }

    </style>
    <style type="text/css" media="print">
            p.localnavbar { display: none; }
      
      div.header { background: white; }
      div.header h1 { color: black; }
      div.header h2 { color: black; }

    </style>
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="pg_mask.pro (OMINAS API Documentation)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	pg_mask</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Uses the given geometry to compute an image mask for all objects</span>
<span class="comments">;	in a scene.</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/PG</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;	mask = pg_mask(cd=cd, gbx=gbx, dkx=dkx, bx=bx, sund=sund)</span>
<span class="comments">;	mask = pg_mask(gd=gd)</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; ARGUMENTS:</span>
<span class="comments">;  INPUT: NONE</span>
<span class="comments">;</span>
<span class="comments">;  OUTPUT: NONE</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; KEYWORDS:</span>
<span class="comments">;  INPUT:</span>
<span class="comments">;	cd:	Camera descriptor.</span>
<span class="comments">;</span>
<span class="comments">;	gbx:	Globe descriptors.</span>
<span class="comments">;</span>
<span class="comments">;	dkx:	Disk descriptors.</span>
<span class="comments">;</span>
<span class="comments">;	bx:	Body descriptors (i.e. point sources).</span>
<span class="comments">;</span>
<span class="comments">;	sund:	Star descriptor giving the sun.</span>
<span class="comments">;</span>
<span class="comments">;	gd:	Generic descriptor.  If given, the descriptor inputs </span>
<span class="comments">;		are taken from this structure if not explicitly given.</span>
<span class="comments">;</span>
<span class="comments">;	dd:	Data descriptor containing a generic descriptor to use</span>
<span class="comments">;		if gd not given.</span>
<span class="comments">;</span>
<span class="comments">;	fgbx,fdkx,fbx:	Fractonal amount to increase the radii of each</span>
<span class="comments">;			descriptor type.</span>
<span class="comments">;</span>
<span class="comments">;	dgbx,ddkx,dbx:	Absolute amount, in physical units (e.g. meters), to </span>
<span class="comments">;			increase the radii of each descriptor type.</span>
<span class="comments">;</span>
<span class="comments">;	pgbx,pdkx,pbx:	Absolute amount, in mask pixels, to increase the radii </span>
<span class="comments">;			of each descriptor type.</span>
<span class="comments">;</span>
<span class="comments">;	nodd;    If set, no data descriptor is created.</span>
<span class="comments">;</span>
<span class="comments">;	np:      Number of points to use in computing curves.  Default is 1000.</span>
<span class="comments">;</span>
<span class="comments">;  OUTPUT:</span>
<span class="comments">;	limb_ptd:	POINT giving the computed limb points.</span>
<span class="comments">;</span>
<span class="comments">;	term_ptd:	POINT giving the computed terminator points.</span>
<span class="comments">;</span>
<span class="comments">;	disk_ptd:	POINT giving the computed disk points.</span>
<span class="comments">;</span>
<span class="comments">;	body_ptd:	POINT giving the computed body points.</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; RETURN:</span>
<span class="comments">;	Data descriptor containing a byte image in which pixels corresponding </span>
<span class="comments">;	to objects are set to 1.</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; STATUS:</span>
<span class="comments">;	Complete.</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; SEE ALSO:</span>
<span class="comments">;	pg_spikes</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale, 4/2004</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; pgmsk_grow</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="pgmsk_grow:source"></a>function pgmsk_grow, mask, dr

 dim = size(mask, /dim)

 smask = fltarr(dim+[dr,dr]*2)
 smask[dr:dr+dim[0]-1, dr:dr+dim[1]-1] = mask
 smask = smooth(smask,dr) 
 w = where(smask GT 0)
 smask[w] = 1

 mask = smask[dr:dr+dim[0]-1, dr:dr+dim[1]-1]
 return, mask
end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; pg_mask</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="pg_mask:source"></a>function pg_mask, mask=mask, dd=dd, gd=gd, cd=cd, gbx=gbx, dkx=dkx, bx=_bx, sund=sund, $
                                    fgbx=fgbx, fdkx=fdkx, fbx=fbx, $
                                    dgbx=dgbx, ddkx=ddkx, dbx=dbx, $
                                    pgbx=pgbx, pdkx=pdkx, pbx=pbx, $
      limb_ptd=limb_ptd, term_ptd=term_ptd, body_ptd=body_ptd, disk_ptd=ring_ptd, $
      nodd=nodd, np=np

 if(keyword_set(_bx)) then bx = _bx

 if(NOT keyword_set(fbx)) then fbx = 1d
 if(NOT keyword_set(fgbx)) then fgbx = fbx
 if(NOT keyword_set(fdkx)) then fdkx = fbx

 if(NOT keyword_set(dbx)) then dbx = 0d
 if(NOT keyword_set(dgbx)) then dgbx = dbx
 if(NOT keyword_set(ddkx)) then ddkx = dbx

 if(NOT keyword_set(pbx)) then pbx = 0d
 if(NOT keyword_set(pgbx)) then pgbx = pbx
 if(NOT keyword_set(pdkx)) then pdkx = pbx

 if(NOT keyword_set(np)) then np = 1000

 <span class="comments">;-----------------------------------------------</span>
 <span class="comments">; dereference the generic descriptor if given</span>
 <span class="comments">;-----------------------------------------------</span>
 if(NOT keyword_set(cd)) then cd = dat_gd(gd, dd=dd, /cd)
 if(NOT keyword_set(bx)) then bx = dat_gd(gd, dd=dd, /bx)
 if(NOT keyword_set(gbx)) then gbx = dat_gd(gd, dd=dd, /gbx)
 if(NOT keyword_set(dkx)) then dkx = dat_gd(gd, dd=dd, /dkx)
 if(NOT keyword_set(sund)) then sund = dat_gd(gd, dd=dd, /sund)

 if(NOT keyword_set(gbx)) then gbx = cor_select(bx, 'GLOBE', /rm, /class)
 if(NOT keyword_set(dkx)) then dkx = cor_select(bx, 'DISK', /rm, /class)
 if(NOT keyword_set(bx)) then bx = 0

 scale = mean(cam_scale(cd))
 dim = cam_size(cd)


 <span class="comments">;-----------------------------------------------</span>
 <span class="comments">; disks</span>
 <span class="comments">;-----------------------------------------------</span>
 dsk_mask = bytarr(dim)
 if(keyword_set(dkx)) then $
  begin
   dkd = nv_clone(dkx)
   ndkd = n_elements(dkd)

   <span class="comments">;- - - - - - - - - - - - - - - - - - - - -</span>
   <span class="comments">; apply radius changes</span>
   <span class="comments">;- - - - - - - - - - - - - - - - - - - - -</span>
   v = bod_pos(dkd) - bod_pos(make_array(ndkd, val=cd))
   dist = v_mag(v)
   cos_theta = v_inner((bod_orient(dkd))[2,*,*], v_unit(v))

   sma = dsk_sma(dkd)
   sma[0,0,*] = sma[0,0,*] / fdkx
   sma[0,0,*] = sma[0,0,*] - ddkx

   sma[0,1,*] = sma[0,1,*] * fdkx
   sma[0,1,*] = sma[0,1,*] + ddkx
   
   dsk_set_sma, dkd, sma


   <span class="comments">;- - - - - - - - - - - - - - - - - - - - -</span>
   <span class="comments">; compute mask</span>
   <span class="comments">;- - - - - - - - - - - - - - - - - - - - -</span>
   sma = (dsk_sma(dkd))[0,0,*]
   ii = rotate(sort(sma), 2)
   dkd = dkd[ii]

   ring_ptd = pg_disk(cd=cd, dkx=dkd, np=np)
   for i=0, ndkd-1 do $
    begin
     inner_pp = pnt_points(/cat, /vis, ring_ptd[2*i])
     outer_pp = pnt_points(/cat, /vis, ring_ptd[2*i+1])

     if(keyword_set(outer_pp)) then $
      begin
         ii_outer = polyfillv(outer_pp[0,*], outer_pp[1,*], dim[0], dim[1])
         if(ii_outer[0] NE -1) then dsk_mask[ii_outer] = 1
      end

     if(keyword_set(inner_pp)) then $
      begin
         ii_inner = polyfillv(inner_pp[0,*], inner_pp[1,*], dim[0], dim[1])
         if(ii_inner[0] NE -1) then dsk_mask[ii_inner] = 0
      end
    end

   dsk_mask = pgmsk_grow(dsk_mask, pdkx)

   nv_free, dkd
  end


 <span class="comments">;-----------------------------------------------</span>
 <span class="comments">; globes</span>
 <span class="comments">;-----------------------------------------------</span>
 glb_mask = bytarr(dim)
 if(keyword_set(gbx)) then $
  begin
   gbd = nv_clone(gbx)
   ngbd = n_elements(gbd)

   <span class="comments">;- - - - - - - - - - - - - - - - - - - - -</span>
   <span class="comments">; apply radius changes</span>
   <span class="comments">;- - - - - - - - - - - - - - - - - - - - -</span>
   dist = v_mag(bod_pos(gbd) - bod_pos(make_array(ngbd, val=cd)))

   radii = glb_radii(gbd)
   radii = radii * fgbx
   radii[*] = radii[*] + dgbx
   
   glb_set_radii, gbd, radii

   <span class="comments">;- - - - - - - - - - - - - - - - - - - - -</span>
   <span class="comments">; compute mask</span>
   <span class="comments">;- - - - - - - - - - - - - - - - - - - - -</span>
   center_ptd = pg_center(cd=cd, bx=gbd)
   center_pts = pnt_points(/cat, /vis, center_ptd)
   cam_pos = bod_pos(cd)##make_array(ngbd, val=1d)
   rad_pix = (glb_radii(gbd))[2,*] / v_mag(cam_pos - tr(bod_pos(gbd))) $
                                                        / (cam_scale(cd))[0]

   w = where((center_pts[0,*]-rad_pix LT dim[0]) $
            AND (center_pts[0,*]+rad_pix GT 0) $
            AND (center_pts[1,*]-rad_pix LT dim[1]) $
            AND (center_pts[1,*]+rad_pix GT 0))
   nw = n_elements(w)

   if(w[0] NE -1) then $
    begin
     limb_ptd = pg_limb(cd=cd, gbx=gbd[w], np=np) 
   
     for i=0, nw-1 do $
      begin
       pp = pnt_points(limb_ptd[i], /vis)
       ii = polyfillv(pp[0,*], pp[1,*], dim[0], dim[1])
       if(ii[0] NE -1) then glb_mask[ii] = 1
      end

     if(keyword_set(sund)) then $
      begin
       pg_hide, /assoc, limb_ptd, bx=gbd[w], od=sund

       term_ptd = pg_limb(cd=cd, od=sund, gbx=gbd[w])
       pg_hide, /assoc, term_ptd, bx=gbd[w], cd=cd

       for i=0, nw-1 do $
        begin
         p = pnt_points([limb_ptd[i], term_ptd[i]], /vis)
         pp = poly_rectify(p)
         ii = polyfillv(pp[0,*], pp[1,*], dim[0], dim[1])
         if(ii[0] NE -1) then glb_mask[ii] = 1
        end
      end
    end

   glb_mask = pgmsk_grow(glb_mask, pgbx)

   nv_free, gbd

   <span class="comments">;-----------------------------------------------</span>
   <span class="comments">; add any sub-pixel objects back to the bx list</span>
   <span class="comments">;-----------------------------------------------</span>
   w = where(rad_pix LT 1)
   if(w[0] NE -1) then bx = append_array(bx, gbx[w])
  end


 <span class="comments">;-----------------------------------------------</span>
 <span class="comments">; point sources</span>
 <span class="comments">;-----------------------------------------------</span>
 bx_mask = bytarr(dim)
 if(keyword_set(bx)) then $
  begin
   bd = nv_clone(bx)
   nbd = n_elements(bd)

   <span class="comments">;- - - - - - - - - - - - - - - - - - - - -</span>
   <span class="comments">; apply radius changes</span>
   <span class="comments">;- - - - - - - - - - - - - - - - - - - - -</span>
   dist = v_mag(bod_pos(bd) - bod_pos(make_array(nbd, val=cd)))

   radii = dblarr(nbd)
   radii[*] = pbx
   
   <span class="comments">;- - - - - - - - - - - - - - - - - - - - -</span>
   <span class="comments">; compute mask</span>
   <span class="comments">;- - - - - - - - - - - - - - - - - - - - -</span>
   body_ptd = pg_center(cd=cd, bx=bd)
   body_pts = pnt_points(/cat, /vis, body_ptd)

   w = in_image(cd, body_pts, slop=1)
   nw = n_elements(w)

   if(w[0] NE -1) then $
    for i=0, nw-1 do $
     begin
      pp = circle(body_pts[*,w[i]], radii[w[i]])
      ii = polyfillv(pp[0,*], pp[1,*], dim[0], dim[1])
      if(ii[0] NE -1) then bx_mask[ii] = 1
     end

   nv_free, bd
  end


 <span class="comments">;-----------------------------------------------</span>
 <span class="comments">; consolidate masks</span>
 <span class="comments">;-----------------------------------------------</span>
 mask = (dsk_mask + glb_mask + bx_mask)&lt;1



 <span class="comments">;-----------------------------------------------</span>
 <span class="comments">; set up data descriptor</span>
 <span class="comments">;-----------------------------------------------</span>
 if(keyword_set(nodd)) then return, mask

 dd_mask = dat_create_descriptors(1, data=mask)
 return, dd_mask
end
<span class="comments">;=============================================================================</span>
</code>
    </div>
  </body>
</html>