<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.6.1 on Fri Jul 14 11:01:04 2017 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>render.pro (OMINAS API Documentation)</title>

    
    <style type="text/css" media="all">
            /* setup page */
      body { font-family: Helvetica, sans-serif; font-size: 12pt; margin: 0; padding: 0; }
      div.content { padding: 1em; }
      p { line-height: 1.4; }
      td p { padding-bottom: 0.5em; }
      img { border: 0; }
      
      /* link styles */
      a { text-decoration: none; }
      a:link, a:visited { color: #0000FF; }
      a:hover, a:focus { background: yellow; border-bottom: 1emx dotted #303099; }
      
      /* dir-overview styles */
      dt.filename { margin-top: 0.5em; }
      dl.file_listing { margin-left: 1em; }
      
      /* titles */
      h1, h2, h3, h4 { font-weight:normal; color: #871E31; margin-top: 1.5em; }
      h4 { margin-bottom: 0.25em; }
      .center { margin-left: auto; margin-right: auto; }
      .small { font-family: Verdana, Helvetica, sans-serif; font-size: 90%; }
      .smaller { font-family: Verdana, Helvetica, sans-serif; font-size: 80%; }
      .smallest { font-family: Verdana, Helvetica, sans-serif; font-size: 70%; }
      h1.basename { margin-top: 0; margin-bottom: 0; }
      h1.basename span.file-attributes { font-size: 70%; margin-left: 3em; color: #384806; }
      h2.directory { font-size: 90%; margin-bottom: 0; }
      h2.routine-name { margin-top: 0; margin-bottom: 0; }
      p.categories { color: #384806; margin-top: 0; }
      span.file_attribute { float: right; color: #384806; margin: 0 0 1em 3em; }
      div#file_comments { margin-top: 1em; }
      
      div.routine-details { border: 1px dotted #C0C0C0; margin-top: 1em; padding: 1em; }
      span.routine-attributes { font-size: 70%; margin-left: 3em; color: #384806; }
      div.details dt { color: #871E31; margin-left: 2em; }
      div.details dt span { color: #384806; margin-left: 2em; }
      div.details dd { margin: 0.5em 2em 1em 4em; }
      a.top {
        font-family: Verdana, Helvetica, sans-serif;
        font-size: 8pt;
        font-weight: bold;
        color: #5070ff;
        text-transform: uppercase;
        float: right;
        margin-left: 1em;
      }
      
      /* comments */
      .pre { white-space: pre; }
      
      /* code styles */
      code { font-family: Monaco, "Courier New", Courier, monospace; font-size: 95%; }
      code.listing { white-space: pre; display: block; margin: 0.75em 0 0.75em 0; padding: 0 3em 0 1em; line-height: 1.4em; }
      code.source { white-space: pre; display: block; }
      code.source span.comments { color: #408080; }
      .syntax { margin-top: 1em; margin-left: 1.5em; text-indent: -1.5em; }
      .var { font-style: italic; }
      .argument { } /* white-space: nowrap; does not work in Safari (and sometimes not even in Firefox) */
      
      dl.routine-summary dt { margin-bottom: 0.25em; }
      dl.routine-summary dd { margin-bottom: 0.5em; margin-left: 2em; }
      
      ul.inherited-method-summary { padding-left: 0em; margin-left: 0em; }
      
      /* general styles */
      ul li { list-style-type: none; }
      table { empty-cells: show; }
      thead { color: #871E31; }
      dd { margin-bottom: 0.35em; }
      input, textarea { background: #F3F6ED; border: #E1D6C6 1px solid; padding: 2px 1em 2px 0.5em; }
      input.text { background: #FFFFC0; }
      
      div.note { margin: 1em 2em 1em 2em; background: #EFEFEF; border: 1px #A0A0A0 dotted; padding: 0 1em 0 1em; }
      p.indent { margin-left: 2em; }
      
      /* An attribute table is a vertical list of name-value pairs. */
      table.box {
        background: #EFEFEF;
        border: 1px #A0A0A0 dotted;
        padding-top: 0.75em;
        padding-bottom: 0.75em;
      }
      table.attribute { padding-left: 0.75em; padding-right: 0.75em; }
      table td { vertical-align: top; }
      table.attribute p { margin: 0; }
      table td.name { font-style: normal; padding-right: 1.5em; }
      ul.fieldslist { padding-top: 0; color: #909090; }
      ul.fieldslist li { margin-bottom: 0.25em; }
      span.fieldname { color: #000000; }
      
      dl.attribute dt { color: #990000; }
      
      /* header/navbar styles */
      div.header { padding: 2em 2em 0 2em; background: #9E9D7B; border-bottom: 2px #262626 solid; }
      div.header h1 { color: white; margin:0; font-weight: normal; }
      div.header h2 { color: white; margin-top: 0; margin-bottom: 1em; font-weight: normal; font-style: italic; font-size: 100%; }
      table.navbar { background: #CCC097; margin: 0; padding: 0; border-bottom: 1px #262626 dotted; width: 100%; }
      table.navbar td { padding: 4px 0.5em 3px 0.5em; white-space: nowrap; vertical-align: top; }
      table.navbar td.flexible { width: 100%; text-align: right; padding-right: 1em; white-space: nowrap; }
      table.navbar td.selected { background: #262626; }
      table.navbar td.selected, table.navbar td.selected a { color: white; }
      table.navbar a:hover, table.navbar a:focus { background: inherit; border-bottom: 1px solid #303099; }
      p.localnavbar { text-align: right; margin: 0.2em 1em 0.2em 0.2em; padding: 0; }
      
      /* CSS graphics styles */
      div.box {
        margin-left: 0.25em;
        display: inline-block;
        width: 0.9em;
        height: 0.9em;
        vertical-align: -1px;
      }
      .red { background-color: #A00; }
      .orange { background-color: #F40; }
      .green { background-color: #480; }
      
      /* index styles */
      span.index_type { margin-left: 1em; }
      dl.index_listing dd { margin-bottom: 0.5em; margin-left: 2em; }
      dl.index_listing dd p { margin-top: 0.2em; margin-bottom: 0em; }
      
      /* search styles */
      fieldset { border: #ddd 1px solid; padding: 1em; margin-top: 3em; }
      legend { color: #871E31; font-size: 120%; }
      label { white-space: nowrap; }
      p.description { margin: 2em 2em 1em 2em; }
      form table td.name { vertical-align: middle; }
      
      /* footer styles */
      div.footer { padding: 0.5em 1em 0.5em 1em; background: #EFEFEF; border-top: 1px #A0A0A0 dotted; }
      div.footer table { width: 100%; }
      div.footer td.right { text-align: right; }

    </style>
    <style type="text/css" media="print">
            p.localnavbar { display: none; }
      
      div.header { background: white; }
      div.header h1 { color: black; }
      div.header h2 { color: black; }

    </style>
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="render.pro (OMINAS API Documentation)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	render</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PURPOSE:</span>
<span class="comments">;	Performs rendering on an array of bodies.</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CATEGORY:</span>
<span class="comments">;	NV/PG</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;	map = render(cd=cd, bx=bx, sund=sund)</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; ARGUMENTS:</span>
<span class="comments">;  INPUT: NONE</span>
<span class="comments">;	image_pts:    Array of the image points defining the grid to be traced.  </span>
<span class="comments">;</span>
<span class="comments">;  OUTPUT: NONE</span>
<span class="comments">;	image_pts:    Array of the image points giving the grid that was traced.  </span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; KEYWORDS:</span>
<span class="comments">;  INPUT:</span>
<span class="comments">;	cd:	      Camera descriptor.</span>
<span class="comments">;</span>
<span class="comments">;	bx:	      Array of object descriptors; must be a subclass of BODY.</span>
<span class="comments">;</span>
<span class="comments">;	sund:         Star descriptor for the Sun.</span>
<span class="comments">;</span>
<span class="comments">;	md:           Array of map descriptors, one for each body.</span>
<span class="comments">;</span>
<span class="comments">;	ddmap:        Array of data descriptors containing the body maps, </span>
<span class="comments">;	              one for each body.</span>
<span class="comments">;</span>
<span class="comments">;	sample:       Amount by which to subsample pixels.</span>
<span class="comments">;</span>
<span class="comments">;	pc_size:      To save memory, the projection is performed in pieces</span>
<span class="comments">;	              of this size.  Default is 65536.</span>
<span class="comments">;</span>
<span class="comments">;	penumbra:     If set, lighting rays are traced to random points on </span>
<span class="comments">;	              each secondary body rather then the center.</span>
<span class="comments">;</span>
<span class="comments">;	no_secondary: If set, no secondary ray tracing is performed, so </span>
<span class="comments">;	              resulting in no shadows.</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">;  OUTPUT: </span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; RETURN: </span>
<span class="comments">;	2D array containing the rendered image.</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; PROCEDURE:</span>
<span class="comments">;	</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; EXAMPLE:</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; STATUS:</span>
<span class="comments">;	Complete</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>



<span class="comments">;=================================================================================</span>
<span class="comments">; map_smoothing_width</span>
<span class="comments">;</span>
<span class="comments">;  This assume a globe and a rectangular map.  Need a more general way to</span>
<span class="comments">;  compute the footprint of a ray in map pixels. </span>
<span class="comments">;</span>
<span class="comments">;=================================================================================</span>
<a id="map_smoothing_width:source"></a>function map_smoothing_width, data, i


 bx = data.bx[i]
 md_bx = data.md[i]

 theta = $
    v_mag(bod_pos(data.cd)-bod_pos(bx))*cam_scale(data.cd[0]) $
        / (glb_radii(bx))[0]
    
 tvim, /silent, get_info=tvd
 zoom = max(tvd.zoom)

 smoothing = fix(max(map_size(md_bx)/[!dpi,2d*!dpi] * [theta,theta])) $
                                * map_scale(md_bx) / zoom / data.sample

 return, smoothing * 4
end
<span class="comments">;=================================================================================</span>



<span class="comments">;=================================================================================</span>
<span class="comments">; rdr_photometry</span>
<span class="comments">;</span>
<span class="comments">;=================================================================================</span>
<a id="rdr_photometry:source"></a>function rdr_photometry, data, cd, sund, bx, body_pts, no_pht=no_pht

 n = n_elements(body_pts)/3

 if(data.no_pht) then phot = make_array(n, val=1d) $
 else $
  begin
   pht_angles, 0, cd, bx, sund, body_pts=body_pts, emm=mu, inc=mu0, g=g

   refl_fn = sld_refl_fn(bx)
   refl_parm = sld_refl_parm(bx)
   if(NOT keyword_set(refl_fn)) then $
    begin
     refl_fn = 'pht_refl_lunar_lambert'
     refl_parm = [0.5,0.5]
    end

   phase_fn = sld_phase_fn(bx)
   phase_parm = sld_phase_parm(bx)
   if(NOT keyword_set(phase_fn)) then $
    begin
     phase_fn = 'pht_phase_isotropic'
     phase_parm = 0
    end

   refl_corr = call_function(refl_fn, mu, mu0, refl_parm)
   phase_corr = call_function(phase_fn, g, phase_parm)

   albedo = sld_albedo(bx)

   phot = refl_corr*phase_corr*albedo
  end


 return, phot > data.pht_min
end
<span class="comments">;=================================================================================</span>



<span class="comments">;=================================================================================</span>
<span class="comments">; rdr_map</span>
<span class="comments">;</span>
<span class="comments">;=================================================================================</span>
<a id="rdr_map:source"></a>pro rdr_map, data, piece, bx, md, ddmap, body_pts, phot, ii

 if(keyword_set(ddmap)) then $
  begin
   w = where(cor_name(bx) EQ cor_name(md))
   if(w[0] NE -1) then jj = w[0]
  end

 if(NOT defined(jj)) then piece[ii] = phot $
 else $
  begin
   ww = where(phot NE 0)
   if(ww[0] NE -1) then $
    begin
     www = ii[ww]

     <span class="comments">;- - - - - - - - - - - - - - - -</span>
     <span class="comments">; compute map points</span>
     <span class="comments">;- - - - - - - - - - - - - - - -</span>
     im_pts_map = body_to_image_pos(md[jj], bx, body_pts[www,*])

     <span class="comments">;- - - - - - - - - - - - - - - -</span>
     <span class="comments">; sample map</span>
     <span class="comments">;- - - - - - - - - - - - - - - -</span>
<span class="comments">;     map_smoothing_width = rdr_map_smoothing_width(data, ii)</span>
map_smoothing_width=1

     map = dat_data(ddmap[jj])

     dat = image_interp_cam(cd=md[jj], map, interp='sinc', $
               im_pts_map[0,*], im_pts_map[1,*], {k:4,fwhm:map_smoothing_width})

     <span class="comments">;- - - - - - - - - - - - - - - - - - - - - - - - -</span>
     <span class="comments">; replace unmapped samples with map average</span>
     <span class="comments">;- - - - - - - - - - - - - - - - - - - - - - - - -</span>
     w = where(dat EQ 0)
     if(w[0] NE -1) then dat[w] = mean(map)

     <span class="comments">;- - - - - - - - - - - - - - - -</span>
     <span class="comments">; apply photometry</span>
     <span class="comments">;- - - - - - - - - - - - - - - -</span>
     piece[www] = dat * phot
    end
  end
end
<span class="comments">;=================================================================================</span>



<span class="comments">;=================================================================================</span>
<span class="comments">; rdr_piece</span>
<span class="comments">;</span>
<span class="comments">;=================================================================================</span>
<a id="rdr_piece:source"></a>function rdr_piece, data, image_pts

 bx = data.bx
 md = data.md
 ddmap = data.ddmap
 cd = data.cd
 sund = data.sund

 np = n_elements(image_pts)/2
 piece = dblarr(np)


 <span class="comments">;---------------------------------------------</span>
 <span class="comments">; trace primary rays from camera</span>
 <span class="comments">;---------------------------------------------</span>
 raytrace, image_pts, cd=cd, bx=bx, $
	show=data.show, standoff=data.standoff, limit_source=data.limit_source, $
	hit_list=hit_list, hit_indices=hit_indices, hit_matrix=hit_matrix, $
        near_matrix=near_matrix, far_matrix=far_matrix, $
        range_matrix=range_matrix
 if(hit_list[0] EQ -1) then return, piece


 <span class="comments">;---------------------------------------------</span>
 <span class="comments">; trace secondary rays to sun</span>
 <span class="comments">;---------------------------------------------</span>
 sec_hit_indices = hit_indices
 sec_hit_matrix = hit_matrix
 sec_hit_list = hit_list
 if(data.no_secondary) then sec_hit_list = -1

 if(sec_hit_list[0] NE -1) then $
   raytrace, bx=bx, sbx=sund, penumbra=data.penumbra, $
	show=data.show, standoff=data.standoff, limit_source=data.limit_source, $
	hit_list=sec_hit_list, hit_indices=sec_hit_indices, hit_matrix=sec_hit_matrix, $
        near_matrix=sec_near_matrix, far_matrix=sec_far_matrix, $
        range_matrix=sec_range_matrix


 <span class="comments">;---------------------------------------------------------------------------</span>
 <span class="comments">; remove primary hits whose sunward secondaries hit other bodies </span>
 <span class="comments">;---------------------------------------------------------------------------</span>
 if(sec_hit_list[0] NE -1) then $
  begin
   w = where(sec_hit_indices NE -1)
   if(w[0] NE -1) then hit_indices[w] =-1
  end


 <span class="comments">;---------------------------------------------</span>
 <span class="comments">; map surfaces</span>
 <span class="comments">;---------------------------------------------</span>
 for i=0, n_elements(hit_list)-1 do $
  begin
   ii = hit_list[i]
   w = where(hit_indices EQ ii)
   nw = n_elements(w)
   if(w[0] NE -1) then $
    begin
     if(data.show) then plots, image_pts[*,w], psym=3, col=ctorange()

     <span class="comments">;- - - - - - - - - - - - - - - - - - - - - - - - - -</span>
     <span class="comments">; photometry</span>
     <span class="comments">;- - - - - - - - - - - - - - - - - - - - - - - - - -</span>
     phot = rdr_photometry(data, cd, sund, bx[ii], hit_matrix[w,*])

     <span class="comments">;- - - - - - - - - - - - - - - - - - - - - - - - - -</span>
     <span class="comments">; map</span>
     <span class="comments">;- - - - - - - - - - - - - - - - - - - - - - - - - -</span>
     rdr_map, data, piece, bx[ii], md, ddmap, hit_matrix, phot, w
    end
  end


 return, piece
end
<span class="comments">;=================================================================================</span>



<span class="comments">;=================================================================================</span>
<span class="comments">; render</span>
<span class="comments">;</span>
<span class="comments">;=================================================================================</span>
<a id="render:source"></a>function render, image_pts, cd=cd, sund=sund, $
  bx=bx, ddmap=ddmap, md=md, sample=sample, pc_size=pc_size, $
  show=show, pht_min=pht_min, no_pht=no_pht, $
  standoff=standoff, limit_source=limit_source, penumbra=penumbra, $
  no_secondary=no_secondary

 nbx = n_elements(bx)
 if(NOT keyword_set(no_secondary)) then no_secondary = 0
 if(NOT keyword_set(penumbra)) then penumbra = 0
 if(NOT keyword_set(pht_min)) then pht_min = 0

 if(NOT defined(limit_source)) then limit_source = 0
 if(NOT defined(standoff)) then standoff = 1

 if(NOT keyword_set(sund)) then $
  begin
   sund = 0
   no_secondary = (no_pht = 1)
  end

 show = keyword_set(show)
 if(NOT keyword_set(sample)) then sample = 1
 sample = double(sample)

 if(NOT keyword_set(pc_size)) then pc_size = 65536

 if(NOT keyword_set(ddmap)) then ddmap = objarr(nbx)
 if(NOT keyword_set(md)) then md = objarr(nbx)


 if(nbx EQ 0) then bx = 0
 data = { $
		cd		:	cd, $
		sund		:	sund, $
		bx		:	bx, $
		ddmap		:	ddmap, $
		md		:	md, $
		sample		:	sample, $
		no_secondary	:	no_secondary, $
		penumbra	:	penumbra, $
		limit_source	:	limit_source, $
		standoff	:	standoff, $
		pht_min		:	pht_min, $
		no_pht		:	keyword_set(no_pht), $
		show		:	show $
	}


 map_size = n_elements(image_pts)/2
 pc_size = long(pc_size&lt;map_size)
 npc = map_size/pc_size
 if(map_size mod pc_size NE 0) then npc = npc + 1

 sample2 = sample*sample

 <span class="comments">;----------------------------------------</span>
 <span class="comments">; perform ray tracing piece-by-piece</span>
 <span class="comments">;----------------------------------------</span>
 map = dblarr(map_size)
 for i=0, npc-1 do $
  begin
   <span class="comments">;------------------------------------</span>
   <span class="comments">; determine the size of this piece</span>
   <span class="comments">;------------------------------------</span>
   size = pc_size
   if(i EQ npc-1) then size = map_size - (npc-1)*pc_size

   <span class="comments">;------------------------------------</span>
   <span class="comments">; resample this grid piece</span>
   <span class="comments">;------------------------------------</span>
   <span class="comments">;- - - - - - - - - - - - - - - - - - - </span>
   <span class="comments">; get master grid for this piece</span>
   <span class="comments">;- - - - - - - - - - - - - - - - - - - </span>
   ii = lindgen(pc_size) + i*pc_size
   pc_image_pts = double(image_pts[*,ii])

   <span class="comments">;- - - - - - - - - - - - - - - - - - - </span>
   <span class="comments">; create subsampled grid</span>
   <span class="comments">;- - - - - - - - - - - - - - - - - - - </span>
   if(show) then plots, pc_image_pts, psym=1, col=ctred()

   dxy = gridgen([sample, sample], /double, /center)/sample
   dxy = dxy[linegen3z(2,sample2,pc_size)]
   dxy = transpose(dxy, [0,2,1])

   pc_image_pts = pc_image_pts[linegen3z(2,pc_size,sample2)]
   pc_image_pts = reform(pc_image_pts + dxy, 2,sample2*pc_size)

   if(show) then plots, pc_image_pts, psym=3, col=ctgreen()

   <span class="comments">;- - - - - - - - - - - - - - - - - - - </span>
   <span class="comments">; trace this piece</span>
   <span class="comments">;- - - - - - - - - - - - - - - - - - - </span>
   if(show) then $
    begin
     device, set_graphics=6
     plots, pc_image_pts, psym=3, col=ctgray(0.25)
     device, set_graphics=3
    end
   piece = rdr_piece(data, pc_image_pts)

   <span class="comments">;- - - - - - - - - - - - - - - - - - - - - </span>
   <span class="comments">; average over samples and add to map</span>
   <span class="comments">;- - - - - - - - - - - - - - - - - - - - -</span>
   piece = reform(piece, pc_size, sample2, /over)
   piece = total(piece,2)/(sample2)

   map[ii] = piece
  end


 return, map
end
<span class="comments">;=================================================================================</span>








<a id="test:source"></a>pro test
<span class="comments">; grim ~/casIss/1350/N1350122987_2.IMG over=planet_center,ring</span>
<span class="comments">; grim ~/casIss/1460/N1460090980_1.IMG over=planet_center,ring</span>
<span class="comments">; grim ~/casIss/1444/N1444735589_1.IMG over=planet_center,ring</span>
<span class="comments">; grim ~/casIss/1669/N1669801856_1.IMG over=planet_center</span>

 ingrid, dd=dd, cd=cd, pd=pd, rd=rd, sund=sund
 bx = append_array(pd, rd)
 dd_render = pg_render(/show, cd=cd, bx=bx, sund=sund, pht=0.02, /psf, /pen, sample=2, mask=0)

 grim, dd_render, /new, cd=cd, pd=pd, rd=rd, sund=sund

end
</code>
    </div>
  </body>
</html>