<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.6.1 on Mon Oct 24 08:52:07 2016 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>gr_phttool.pro (OMINAS API Documentation)</title>

    
    <style type="text/css" media="all">
            /* setup page */
      body { font-family: Helvetica, sans-serif; font-size: 12pt; margin: 0; padding: 0; }
      div.content { padding: 1em; }
      p { line-height: 1.4; }
      td p { padding-bottom: 0.5em; }
      img { border: 0; }
      
      /* link styles */
      a { text-decoration: none; }
      a:link, a:visited { color: #0000FF; }
      a:hover, a:focus { background: yellow; border-bottom: 1emx dotted #303099; }
      
      /* dir-overview styles */
      dt.filename { margin-top: 0.5em; }
      dl.file_listing { margin-left: 1em; }
      
      /* titles */
      h1, h2, h3, h4 { font-weight:normal; color: #871E31; margin-top: 1.5em; }
      h4 { margin-bottom: 0.25em; }
      .center { margin-left: auto; margin-right: auto; }
      .small { font-family: Verdana, Helvetica, sans-serif; font-size: 90%; }
      .smaller { font-family: Verdana, Helvetica, sans-serif; font-size: 80%; }
      .smallest { font-family: Verdana, Helvetica, sans-serif; font-size: 70%; }
      h1.basename { margin-top: 0; margin-bottom: 0; }
      h1.basename span.file-attributes { font-size: 70%; margin-left: 3em; color: #384806; }
      h2.directory { font-size: 90%; margin-bottom: 0; }
      h2.routine-name { margin-top: 0; margin-bottom: 0; }
      p.categories { color: #384806; margin-top: 0; }
      span.file_attribute { float: right; color: #384806; margin: 0 0 1em 3em; }
      div#file_comments { margin-top: 1em; }
      
      div.routine-details { border: 1px dotted #C0C0C0; margin-top: 1em; padding: 1em; }
      span.routine-attributes { font-size: 70%; margin-left: 3em; color: #384806; }
      div.details dt { color: #871E31; margin-left: 2em; }
      div.details dt span { color: #384806; margin-left: 2em; }
      div.details dd { margin: 0.5em 2em 1em 4em; }
      a.top {
        font-family: Verdana, Helvetica, sans-serif;
        font-size: 8pt;
        font-weight: bold;
        color: #5070ff;
        text-transform: uppercase;
        float: right;
        margin-left: 1em;
      }
      
      /* comments */
      .pre { white-space: pre; }
      
      /* code styles */
      code { font-family: Monaco, "Courier New", Courier, monospace; font-size: 95%; }
      code.listing { white-space: pre; display: block; margin: 0.75em 0 0.75em 0; padding: 0 3em 0 1em; line-height: 1.4em; }
      code.source { white-space: pre; display: block; }
      code.source span.comments { color: #408080; }
      .syntax { margin-top: 1em; margin-left: 1.5em; text-indent: -1.5em; }
      .var { font-style: italic; }
      .argument { } /* white-space: nowrap; does not work in Safari (and sometimes not even in Firefox) */
      
      dl.routine-summary dt { margin-bottom: 0.25em; }
      dl.routine-summary dd { margin-bottom: 0.5em; margin-left: 2em; }
      
      ul.inherited-method-summary { padding-left: 0em; margin-left: 0em; }
      
      /* general styles */
      ul li { list-style-type: none; }
      table { empty-cells: show; }
      thead { color: #871E31; }
      dd { margin-bottom: 0.35em; }
      input, textarea { background: #F3F6ED; border: #E1D6C6 1px solid; padding: 2px 1em 2px 0.5em; }
      input.text { background: #FFFFC0; }
      
      div.note { margin: 1em 2em 1em 2em; background: #EFEFEF; border: 1px #A0A0A0 dotted; padding: 0 1em 0 1em; }
      p.indent { margin-left: 2em; }
      
      /* An attribute table is a vertical list of name-value pairs. */
      table.box {
        background: #EFEFEF;
        border: 1px #A0A0A0 dotted;
        padding-top: 0.75em;
        padding-bottom: 0.75em;
      }
      table.attribute { padding-left: 0.75em; padding-right: 0.75em; }
      table td { vertical-align: top; }
      table.attribute p { margin: 0; }
      table td.name { font-style: normal; padding-right: 1.5em; }
      ul.fieldslist { padding-top: 0; color: #909090; }
      ul.fieldslist li { margin-bottom: 0.25em; }
      span.fieldname { color: #000000; }
      
      dl.attribute dt { color: #990000; }
      
      /* header/navbar styles */
      div.header { padding: 2em 2em 0 2em; background: #9E9D7B; border-bottom: 2px #262626 solid; }
      div.header h1 { color: white; margin:0; font-weight: normal; }
      div.header h2 { color: white; margin-top: 0; margin-bottom: 1em; font-weight: normal; font-style: italic; font-size: 100%; }
      table.navbar { background: #CCC097; margin: 0; padding: 0; border-bottom: 1px #262626 dotted; width: 100%; }
      table.navbar td { padding: 4px 0.5em 3px 0.5em; white-space: nowrap; vertical-align: top; }
      table.navbar td.flexible { width: 100%; text-align: right; padding-right: 1em; white-space: nowrap; }
      table.navbar td.selected { background: #262626; }
      table.navbar td.selected, table.navbar td.selected a { color: white; }
      table.navbar a:hover, table.navbar a:focus { background: inherit; border-bottom: 1px solid #303099; }
      p.localnavbar { text-align: right; margin: 0.2em 1em 0.2em 0.2em; padding: 0; }
      
      /* CSS graphics styles */
      div.box {
        margin-left: 0.25em;
        display: inline-block;
        width: 0.9em;
        height: 0.9em;
        vertical-align: -1px;
      }
      .red { background-color: #A00; }
      .orange { background-color: #F40; }
      .green { background-color: #480; }
      
      /* index styles */
      span.index_type { margin-left: 1em; }
      dl.index_listing dd { margin-bottom: 0.5em; margin-left: 2em; }
      dl.index_listing dd p { margin-top: 0.2em; margin-bottom: 0em; }
      
      /* search styles */
      fieldset { border: #ddd 1px solid; padding: 1em; margin-top: 3em; }
      legend { color: #871E31; font-size: 120%; }
      label { white-space: nowrap; }
      p.description { margin: 2em 2em 1em 2em; }
      form table td.name { vertical-align: middle; }
      
      /* footer styles */
      div.footer { padding: 0.5em 1em 0.5em 1em; background: #EFEFEF; border-top: 1px #A0A0A0 dotted; }
      div.footer table { width: 100%; }
      div.footer td.right { text-align: right; }

    </style>
    <style type="text/css" media="print">
            p.localnavbar { display: none; }
      
      div.header { background: white; }
      div.header h1 { color: black; }
      div.header h2 { color: black; }

    </style>
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="gr_phttool.pro (OMINAS API Documentation)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">;=============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; NAME:</span>
<span class="comments">;	gr_phttool</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; DESCRIPTION:</span>
<span class="comments">;	Graphical photometric correction tool. </span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; CALLING SEQUENCE:</span>
<span class="comments">;	</span>
<span class="comments">;	gr_phttool</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; ARGUMENTS:</span>
<span class="comments">;  INPUT: NONE</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">;  OUTPUT: NONE</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; KEYWORDS:</span>
<span class="comments">;  INPUT: NONE</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">;  OUTPUT: NONE</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; LAYOUT:</span>
<span class="comments">;	The gr_phttool layout consists of the following items:</span>
<span class="comments">;</span>
<span class="comments">;	 Reflectance function controls:</span>
<span class="comments">;		A reflectance function is selected using the droplist and </span>
<span class="comments">;		the relevant parameters (whose purpose depend on the specific</span>
<span class="comments">;		function) are input using the text widgets below.</span>
<span class="comments">;</span>
<span class="comments">;	 Phase function controls:</span>
<span class="comments">;		A phase function is selected using the droplist and </span>
<span class="comments">;		the relevant parameters (whose purpose depend on the specific</span>
<span class="comments">;		function) are input using the text widgets below. </span>
<span class="comments">;</span>
<span class="comments">;	   Reflectance and phase functions are determined by looking for any</span>
<span class="comments">;	   complied function whose name starts with 'pht_refl_' or 'pht_phase',</span>
<span class="comments">;	   or any routines in the directory pointed to by the environment variable</span>
<span class="comments">;	   GR_PHT_DIR. The function lists may be updated using the corresponding </span>
<span class="comments">;	   'Refresh' button.  The calling sequences are as follows:</span>
<span class="comments">;</span>
<span class="comments">;	   refl_corr = refl_fn(mu, mu0, refl_parm)</span>
<span class="comments">;	   phase_corr = phase_fn(g, phase_parm)</span>
<span class="comments">;</span>
<span class="comments">;	   where the photometric arguments are all cosines, and the *_parm </span>
<span class="comments">;	   arguments come from the corresponding input text widgets.</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">;	'Ok' button:</span>
<span class="comments">;		Applies the photometric correction described by the current</span>
<span class="comments">;		widget settings and exits.  </span>
<span class="comments">;</span>
<span class="comments">;	'Apply' button:</span>
<span class="comments">;		Applies the photometric correction described by the current</span>
<span class="comments">;		widget settings without exiting.  </span>
<span class="comments">;</span>
<span class="comments">;	'Apply All' button:</span>
<span class="comments">;		Applies the photometric correction described by the current</span>
<span class="comments">;		widget settings to all planes of the primary grim window for</span>
<span class="comments">;		which outline points have been activated. </span>
<span class="comments">;</span>
<span class="comments">;	'Cancel' button</span>
<span class="comments">;		Exits with no photometric correction.		</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; OPERATION:</span>
<span class="comments">;	gr_phttool allows the user to apply photometric corrections to images</span>
<span class="comments">;	using a simple graphical interface.  Corrections are applied to data </span>
<span class="comments">;	within any active limb points.  </span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; STATUS:</span>
<span class="comments">;	Incomplete.</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; MODIFICATION HISTORY:</span>
<span class="comments">; 	Written by:	Spitale 7/2002</span>
<span class="comments">;	</span>
<span class="comments">;-</span>
<span class="comments">;=============================================================================</span>

<span class="comments">;=============================================================================</span>
<span class="comments">; pht_descriptor__define</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="pht_descriptor__define:source"></a>pro pht_descriptor__define

 struct = $
    { pht_descriptor, $
	 refl_fn	:	'', $
	 phase_fn	:	'', $
	 n_refl_parm	:	0, $
	 n_phase_parm	:	0, $
	 refl_parm_p	:	nv_ptr_new(), $
	 phase_parm_p	:	nv_ptr_new() $
	}

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grpht_get_prefix</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grpht_get_prefix:source"></a>function grpht_get_prefix, type
 return, 'pht_' + type + '_'
end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grpht_descriptor</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grpht_descriptor:source"></a>function grpht_descriptor, refl_fn=refl_fn, phase_fn=phase_fn, $
            refl_parm=refl_parm, phase_parm=phase_parm, $
            n_refl_parm=n_refl_parm, n_phase_parm=n_phase_parm

 phtd = {pht_descriptor}
 phtd.refl_parm_p = nv_ptr_new([0,0,0])
 phtd.phase_parm_p = nv_ptr_new([0,0,0])

 if(keyword_set(refl_fn)) then phtd.refl_fn = refl_fn
 if(keyword_set(phase_fn)) then phtd.phase_fn = phase_fn
 if(keyword_set(refl_parm)) then *phtd.refl_parm_p = refl_parm
 if(keyword_set(phase_parm)) then *phtd.phase_parm_p = phase_parm
 if(keyword_set(n_refl_parm)) then phtd.n_refl_parm = n_refl_parm
 if(keyword_set(n_phase_parm)) then phtd.n_phase_parm = n_phase_parm

 return, phtd
end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grpht_get_phtd</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grpht_get_phtd:source"></a>function grpht_get_phtd, data, refl_fn, index=index

 refl_fns = data.phtds.refl_fn
 w = where(refl_fns EQ strupcase(refl_fn))
 index = w[0]

 return, data.phtds[index]
end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grpht_apply_correction</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grpht_apply_correction:source"></a>pro grpht_apply_correction, data, phtd, dd, cd, pd, sund, outline_ptd

 <span class="comments">;-----------------------------------</span>
 <span class="comments">; compute correction</span>
 <span class="comments">;-----------------------------------</span>
 refl_fn = grpht_get_prefix('refl') + phtd.refl_fn
 phase_fn = grpht_get_prefix('phase') + phtd.phase_fn

 widget_control, /hourglass
 dd_cor = pg_photom(dd, cd=cd, gbx=pd[0], sund=sund, outline=outline_ptd, $
             refl_fn=refl_fn, refl_parm=*phtd.refl_parm_p, $
             phase_fn=phase_fn, phase_parm=*phtd.phase_parm_p, /over)

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grpht_apply_correction_primary</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grpht_apply_correction_primary:source"></a>pro grpht_apply_correction_primary, grim_data, data, phtd
@pnt_include.pro

 <span class="comments">;---------------------------</span>
 <span class="comments">; get data</span>
 <span class="comments">;----------------------------</span>
 limb_ptd = grim_get_active_overlays(grim_data, 'limb')
 if(NOT keyword_set(limb_ptd)) then $
  begin
   grim_message, 'No outline points.'
   return
  end

 outline_ptd = nv_clone(limb_ptd[0])
 flags = pnt_flags(outline_ptd) & flags[*] = NOT PTD_MASK_INVISIBLE & pnt_set_flags, outline_ptd, flags

 ingrid, dd=dd, cd=cd, sund=sund, active_pd=pd

 if(NOT keyword_set(cd)) then $
  begin
   grim_message, 'No camera descriptor.'
   return
  end
 
 if(NOT keyword_set(pd)) then $
  begin
   grim_message, 'No active planet descriptor.'
   return
  end

 if(NOT keyword_set(sund)) then $
  begin
   grim_message, 'No sun descriptor.'
   return
  end

 <span class="comments">;----------------------------</span>
 <span class="comments">; apply correction</span>
 <span class="comments">;----------------------------</span>
 grpht_apply_correction, data, phtd, dd, cd, pd, sund, outline_ptd

 nv_free, outline_ptd
end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grpht_apply_correction_all</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grpht_apply_correction_all:source"></a>pro grpht_apply_correction_all, grim_data, data, phtd

 planes = grim_get_plane(grim_data, /all)
 nplanes = n_elements(planes)

 for i=0, nplanes-1 do $
  begin
   ingrid, pn=i, dd=dd, cd=cd, sund=sund, active_pd=pd, active_limb_ptd=limb_ptd
   apply = 1

   <span class="comments">;---------------------------</span>
   <span class="comments">; get data</span>
   <span class="comments">;----------------------------</span>
   if(NOT keyword__set(limb_ptd)) then apply = 0 $
   else outline_ptd = (limb_ptd)[0]

   if(NOT keyword__set(cd)) then apply = 0
   if(NOT keyword__set(pd)) then apply = 0 
   if(NOT keyword__set(sund)) then apply = 0

   <span class="comments">;----------------------------</span>
   <span class="comments">; apply correction</span>
   <span class="comments">;----------------------------</span>
   if(apply) then $
         grpht_apply_correction, data, phtd, dd, cd, pd, sund, outline_ptd
  end


end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grpht_parse_entry</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grpht_parse_entry:source"></a>function grpht_parse_entry, ids, tags, tag, null=null, drop=drop

 i = (where(tags EQ tag))[0]

 if(NOT keyword__set(drop)) then $
  begin   
   widget_control, ids[i], get_value=value

   null = 1
   if((strmid(value, 0, 1))[0] EQ '-') then return, 0
   null = 0

   if(size(value, /type) EQ 7) then value = str_sep(strtrim(value,2), ' ')
  end $
 else value = widget_info(ids[i], /droplist_select)


 return, value
end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grpht_set_entry</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grpht_set_entry:source"></a>pro grpht_set_entry, ids, tags, tag, value, drop=drop

 i = (where(tags EQ tag))[0]

 if(NOT keyword__set(drop)) then $
             widget_control, ids[i], set_value = strtrim(value,2) + ' ' $
 else widget_control, ids[i], set_droplist_select=value

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grpht_form_to_phtd</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grpht_form_to_phtd:source"></a>function grpht_form_to_phtd, data, refl_fn=refl_fn

 refl_parm0 = $
      double(grpht_parse_entry(data.ids, data.tags, 'REFL_PARM0', null=null0))
 refl_parm1 = $
      double(grpht_parse_entry(data.ids, data.tags, 'REFL_PARM1', null=null1))
 refl_parm2 = $
      double(grpht_parse_entry(data.ids, data.tags, 'REFL_PARM2', null=null2))

 n_refl = 0
 w = where([null0, null1, null2] NE 1)
 if(w[0] NE -1) then n_refl = n_elements(w)


 phase_parm0 = $
      double(grpht_parse_entry(data.ids, data.tags, 'PHASE_PARM0', null=null0))
 phase_parm1 = $
      double(grpht_parse_entry(data.ids, data.tags, 'PHASE_PARM1', null=null1))
 phase_parm2 = $
      double(grpht_parse_entry(data.ids, data.tags, 'PHASE_PARM2', null=null2))

 n_phase = 0
 w = where([null0, null1, null2] NE 1)
 if(w[0] NE -1) then n_phase = n_elements(w)


 if(NOT keyword__set(refl_fn)) then $
  begin
   refl_fn_index = $
          long(grpht_parse_entry(data.ids, data.tags, 'REFL_FN', /drop))
   refl_fn = strupcase(data.refl_fns[refl_fn_index])
  end

 phase_fn_index = $
        long(grpht_parse_entry(data.ids, data.tags, 'PHASE_FN', /drop))
 phase_fn = strupcase(data.phase_fns[phase_fn_index])


 return, grpht_descriptor( $
		refl_fn=refl_fn, $
		phase_fn=phase_fn, $
		n_refl=n_refl, $
		n_phase=n_phase, $
		refl_parm=[refl_parm0, refl_parm1, refl_parm2], $
		phase_parm=[phase_parm0, phase_parm1, phase_parm2])
end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grpht_get_functions</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grpht_get_functions:source"></a>function grpht_get_functions, type, default=_default

 default = 'minneart'
 if(type EQ 'phase') then default = 'isotropic'

 prefix = grpht_get_prefix(type)
 default = prefix + default

 which, default, output=output
 split_filename, output, dir, name

 env_dir = getenv('GR_PHT_DIR')

 names_dir = get_pro_by_prefix(prefix, dir=dir)
 names_dir = names_dir[where(names_dir NE prefix+'corr')]
 names_env_dir = get_pro_by_prefix(prefix, dir=env_dir)
 names_comp = get_pro_by_prefix(prefix)

 names = append_array(names_dir, names_comp)
 ss = sort(names)
 names = names[ss]
 uu = uniq(names)
 names = names[uu]

 if(n_elements(names) GT 1) then $
  begin
   w = where(strlowcase(names) EQ strlowcase(default))
   if(w[0] NE -1) then names = append_array(default, rm_list_item(names, w[0]))
  end

 names = strmid(names, strlen(prefix), 1000)
 return, names
end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grpht_refresh_fn</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grpht_refresh_fn:source"></a>pro grpht_refresh_fn, data, type
 w = where(data.tags EQ strupcase(TYPE) + '_FN')
 widget_control, data.ids[w], set_value=strupcase(grpht_get_functions(type))
end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grpht_phtd_to_form</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grpht_phtd_to_form:source"></a>pro grpht_phtd_to_form, data, phtd

 null = '-------------'

 grpht_set_entry, data.ids, data.tags, 'REFL_PARM0', (*phtd.refl_parm_p)[0]
 grpht_set_entry, data.ids, data.tags, 'REFL_PARM1', (*phtd.refl_parm_p)[1]
 grpht_set_entry, data.ids, data.tags, 'REFL_PARM2', (*phtd.refl_parm_p)[2]

 if(phtd.n_refl_parm LE 0) then $
         grpht_set_entry, data.ids, data.tags, 'REFL_PARM0', null
 if(phtd.n_refl_parm LE 1) then $
         grpht_set_entry, data.ids, data.tags, 'REFL_PARM1', null
 if(phtd.n_refl_parm LE 2) then $
         grpht_set_entry, data.ids, data.tags, 'REFL_PARM2', null

 grpht_set_entry, data.ids, data.tags, 'PHASE_PARM0', (*phtd.phase_parm_p)[0]
 grpht_set_entry, data.ids, data.tags, 'PHASE_PARM1', (*phtd.phase_parm_p)[1]
 grpht_set_entry, data.ids, data.tags, 'PHASE_PARM2', (*phtd.phase_parm_p)[2]

 if(phtd.n_phase_parm LE 0) then $
         grpht_set_entry, data.ids, data.tags, 'PHASE_PARM0', null
 if(phtd.n_phase_parm LE 1) then $
         grpht_set_entry, data.ids, data.tags, 'PHASE_PARM1', null
 if(phtd.n_phase_parm LE 2) then $
         grpht_set_entry, data.ids, data.tags, 'PHASE_PARM2', null

 refl_fn_index = (where(strupcase(data.refl_fns) EQ phtd.refl_fn))[0]
 grpht_set_entry, data.ids, data.tags, 'REFL_FN', refl_fn_index, /drop

 phase_fn_index = (where(strupcase(data.phase_fns) EQ phtd.phase_fn))[0]
 grpht_set_entry, data.ids, data.tags, 'PHASE_FN', phase_fn_index, /drop

 data.last_refl_fn = data.refl_fns[refl_fn_index]

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; gr_phttool_event</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="gr_phttool_event:source"></a>pro gr_phttool_event, event

 <span class="comments">;-----------------------------------------------</span>
 <span class="comments">; get pht form base and data structure</span>
 <span class="comments">;-----------------------------------------------</span>
 grim_data = grim_get_data(/primary)
 data = grim_get_user_data(grim_data, 'GRPHT_DATA')
 phtd = grpht_form_to_phtd(data)

 <span class="comments">;-----------------------------------------------</span>
 <span class="comments">; get form value structure</span>
 <span class="comments">;-----------------------------------------------</span>
 widget_control, event.id, get_value=value

 <span class="comments">;-----------------------------------------------</span>
 <span class="comments">; get tag names, widget ids, and fns</span>
 <span class="comments">;-----------------------------------------------</span>
 tags = data.tags
 ids = data.ids
 refl_fns = data.refl_fns
 phase_fns = data.phase_fns

 update = 1

 case event.tag of
  <span class="comments">;---------------------------------------------------------</span>
  <span class="comments">; 'Close' button --</span>
  <span class="comments">;  Just destroy the form and forget about it</span>
  <span class="comments">;---------------------------------------------------------</span>
  'CLOSE' : $
 	begin
	 widget_control, data.base, /destroy
	 return
	end

  'PHASE_PARM0'   :  update = 0
  'PHASE_PARM1'   :  update = 0
  'PHASE_PARM2'   :  update = 0

  'REFL_PARM0'   :  update = 0
  'REFL_PARM1'   :  update = 0
  'REFL_PARM2'   :  update = 0

  <span class="comments">;---------------------------------------------------------</span>
  <span class="comments">; 'Refresh' button --</span>
  <span class="comments">;  Refresh the reflectance function lists.</span>
  <span class="comments">;---------------------------------------------------------</span>
  'REFRESH_REFL' : $
	begin
	  grpht_refresh_fn, data, 'refl'
	end

  <span class="comments">;---------------------------------------------------------</span>
  <span class="comments">; 'Refresh' button --</span>
  <span class="comments">;  Refresh the phase function lists.</span>
  <span class="comments">;---------------------------------------------------------</span>
  'REFRESH_PHASE' : $
	begin
	  grpht_refresh_fn, data, 'phase'
	end

  <span class="comments">;---------------------------------------------------------</span>
  <span class="comments">; 'Apply' button --</span>
  <span class="comments">;  Apply the correction using the current settings.</span>
  <span class="comments">;---------------------------------------------------------</span>
  'APPLY' : $
	begin
	  grpht_apply_correction_primary, grim_data, data, phtd
	end

  <span class="comments">;--------------------------------------------------------------------</span>
  <span class="comments">; 'Apply All' button --</span>
  <span class="comments">;  Apply the correction to all planes using the current settings.</span>
  <span class="comments">;--------------------------------------------------------------------</span>
  'APPLY_ALL' : $
	begin
	  grpht_apply_correction_all, grim_data, data, phtd
	end

  <span class="comments">;---------------------------------------------------------------</span>
  <span class="comments">; Correction type --</span>
  <span class="comments">;  Save the current setting in the appropriate pht descriptor</span>
  <span class="comments">;  and restore the displayed settings to those of the new pht </span>
  <span class="comments">;  descriptor.</span>
  <span class="comments">;---------------------------------------------------------------</span>
  'REFL_FN' : $
	begin
	 phtd_form = grpht_form_to_phtd(data, refl_fn=data.last_refl_fn)
	 index = where(data.phtds.refl_fn EQ phtd_form.refl_fn)
	 data.phtds[index] = phtd_form

	 phtd = grpht_get_phtd(data, refl_fns[value.refl_fn])
         grpht_phtd_to_form, data, phtd
	end

  else:
 endcase


 if(update) then grpht_phtd_to_form, data, phtd
 data.phtd = phtd
 grim_set_user_data, grim_data, 'GRPHT_DATA', data


end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grpht_primary_notify</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grpht_primary_notify:source"></a>pro grpht_primary_notify, init_data_p

 grim_data = grim_get_data(/primary)
 data = grim_get_user_data(grim_data, 'GRPHT_DATA')
 if(NOT keyword_set(data)) then $
               grim_set_user_data, grim_data, 'GRPHT_DATA', *init_data_p $
 else grpht_phtd_to_form, data, data.phtd

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; grpht_cleanup</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="grpht_cleanup:source"></a>pro grpht_cleanup, base

 widget_control, base, get_uvalue=data_p
 grim_rm_primary_callback, data_p

end
<span class="comments">;=============================================================================</span>



<span class="comments">;=============================================================================</span>
<span class="comments">; gr_phttool</span>
<span class="comments">;</span>
<span class="comments">;=============================================================================</span>
<a id="gr_phttool:source"></a>pro gr_phttool, top

 if(xregistered('gr_phttool')) then return


 <span class="comments">;-----------------------------------------------</span>
 <span class="comments">; setup map form widget</span>
 <span class="comments">;-----------------------------------------------</span>
 base = widget_base(title = 'Photometry', group=top)

 refl_fns = strupcase(grpht_get_functions('refl'))
 nrefl = n_elements(refl_fns)
 dl_refl_fn = refl_fns[0]
 for i=1, nrefl-1 do dl_refl_fn = dl_refl_fn + '|' + refl_fns[i]

 phase_fns = strupcase(grpht_get_functions('phase'))
 nphase = n_elements(phase_fns)
 dl_phase_fn = phase_fns[0]
 for i=1, nphase-1 do dl_phase_fn = dl_phase_fn + '|' + phase_fns[i]

 desc = [ $
	'1, BASE,, COLUMN, FRAME', $
	'1, BASE,, ROW, FRAME', $
	'1, BASE,, COLUMN, FRAME', $
	  '0, LABEL, Reflectance function,,', $
	  '1, BASE,, ROW, FRAME', $
	    '0, DROPLIST,' + dl_refl_fn + ',SET_VALUE=0' + $
	           ',, TAG=refl_fn', $
	    '2, BUTTON, Refresh,, TAG=refresh_refl', $
	  '0, TEXT,, LABEL_LEFT=k0 :, WIDTH=20, TAG=refl_parm0', $
	  '0, TEXT,, LABEL_LEFT=k1 :, WIDTH=20, TAG=refl_parm1', $
	  '2, TEXT,, LABEL_LEFT=k2 :, WIDTH=20, TAG=refl_parm2', $
	'3, BASE,, COLUMN, FRAME', $
	  '0, LABEL, Phase function,,', $
	  '1, BASE,, ROW, FRAME', $
	    '0, DROPLIST,' + dl_phase_fn + ',SET_VALUE=0' + $
	           ',, TAG=phase_fn', $
	    '2, BUTTON, Refresh,, TAG=refresh_phase', $
	  '0, TEXT,, LABEL_LEFT=k0 :, WIDTH=20, TAG=phase_parm0', $
	  '0, TEXT,, LABEL_LEFT=k1 :, WIDTH=20, TAG=phase_parm1', $
	  '2, TEXT,, LABEL_LEFT=k2 :, WIDTH=20, TAG=phase_parm2', $

	'1, BASE,, ROW', $
	  '0, BUTTON, Apply,, TAG=apply', $
	  '0, BUTTON, Apply All,, TAG=apply_all', $
	  '2, BUTTON, Close, QUIT, TAG=close']

 form = cw__form(base, desc, ids=ids, tags=tags)
 widget_control, form, $
           set_uvalue={ids:ids, tags:tags, $
                       refl_fns:refl_fns, phase_fns:phase_fns}

 nids = n_elements(ids)
 for i=0, nids-1 do widget_control, ids[i], /all_text_events 

 <span class="comments">;-----------------------------------------------</span>
 <span class="comments">; main data structure</span>
 <span class="comments">;-----------------------------------------------</span>
 data = { $
	<span class="comments">;---------------</span>
	<span class="comments">; widgets</span>
	<span class="comments">;---------------</span>
		base		:	base, $
		phtd		:	grpht_descriptor(), $
		form		:	form, $
		ids		:	ids, $
		tags		:	tags, $
		refl_fns	:	refl_fns, $
		phase_fns	:	phase_fns, $
	<span class="comments">;---------------</span>
	<span class="comments">; book keeping</span>
	<span class="comments">;---------------</span>
		last_refl_fn	:	'', $
		grim_wnum	:	!d.window, $
	<span class="comments">;-----------------------------</span>
	<span class="comments">; default pht descriptors</span>
	<span class="comments">;-----------------------------</span>
		phtds 		:	[ grpht_descriptor( $
					   refl_fn='MINNEART', $
					   phase_fn='ISOTROPIC', $
					   n_refl=1, $
					   n_phase=0, $
					   refl_parm = [0.5, 0, 0]), $
					  grpht_descriptor( $
					   refl_fn='LUNAR', $
					   phase_fn='ISOTROPIC', $
					   n_refl=0, $
					   n_phase=0, $
					   refl_parm = [0, 0, 0]), $
					  grpht_descriptor( $
					   refl_fn='LUNAR_LAMBERT', $
					   phase_fn='ISOTROPIC', $
					   n_refl=2, $
					   n_phase=0, $
					   refl_parm = [0.5, 0.5, 0]) ] $
	     }

 data.refl_fns = data.phtds.refl_fn
<span class="comments">; widget_control, base, set_uvalue=data</span>


 <span class="comments">;-----------------------------------------------------</span>
 <span class="comments">; realize and register</span>
 <span class="comments">;-----------------------------------------------------</span>
 widget_control, base, /realize
 xmanager, 'gr_phttool', base, /no_block, cleanup='grpht_cleanup'

 <span class="comments">;-----------------------------------------------------</span>
 <span class="comments">; initial form settings</span>
 <span class="comments">;-----------------------------------------------------</span>
 data.phtd = grpht_get_phtd(data, 'MINNEART')
 grpht_phtd_to_form, data, data.phtd

 data_p = nv_ptr_new(data)
 grim_add_primary_callback, 'grpht_primary_notify', data_p
 widget_control, base, set_uvalue=data_p

 grim_data = grim_get_data(top)
 grim_set_user_data, grim_data, 'GRPHT_DATA', data


end
<span class="comments">;=============================================================================</span>
</code>
    </div>
  </body>
</html>