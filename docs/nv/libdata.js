/* Index used for searching */
/*
   Fields used:
     url, name, type, filename, authors, routine name, comments, parameters,
     categories, and attributes
*/
title = "OMINAS Documentation";
subtitle = "Generated by IDLdoc";
libdata = new Array();
libdataItem = 0;



libdata[libdataItem++] = new Array("obj/bod/_bod_aberration_mask.html", "_bod_aberration_mask.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "_bod_aberration_mask.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/cor/_cor_gd.html", "_cor_gd.pro", '.pro file in <a href="obj/cor/dir-overview.html">obj/cor/ directory</a>', "_cor_gd.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/cor/_cor_set_gd.html", "_cor_set_gd.pro", '.pro file in <a href="obj/cor/dir-overview.html">obj/cor/ directory</a>', "_cor_set_gd.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/cor/_cor_test_udata.html", "_cor_test_udata.pro", '.pro file in <a href="obj/cor/dir-overview.html">obj/cor/ directory</a>', "_cor_test_udata.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/glb/_glb_get_surface_normal_body.html", "_glb_get_surface_normal_body.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "_glb_get_surface_normal_body.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/map/_map_wrap_points.html", "_map_wrap_points.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "_map_wrap_points.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/pnt/_pnt_resize.html", "_pnt_resize.pro", '.pro file in <a href="obj/pnt/dir-overview.html">obj/pnt/ directory</a>', "_pnt_resize.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/tools/abcorr.html", "abcorr.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "abcorr.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/arr/arr_assign.html", "arr_assign.pro", '.pro file in <a href="obj/arr/dir-overview.html">obj/arr/ directory</a>', "arr_assign.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/arr/arr_assign.html#arr_assign", "arr_assign", 'routine in <a href="obj/arr/arr_assign.html">arr_assign.pro</a>', "arr_assign.pro", "", "arr_assign", "	Replaces fields in a ARRAY object.  This is a convenient way of 	setting multiple fields in one call, and only a single event is 	generated.    ", "noeventIf set, no event is generated.   xd@arr__keywords_tree.include", "NV/OBJ/ARR", " 	Written by:	Spitale		2/2017   ");
  
  

libdata[libdataItem++] = new Array("obj/arr/arr_create_descriptors.html", "arr_create_descriptors.pro", '.pro file in <a href="obj/arr/dir-overview.html">obj/arr/ directory</a>', "arr_create_descriptors.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/arr/arr_create_descriptors.html#arr_create_descriptors", "arr_create_descriptors", 'routine in <a href="obj/arr/arr_create_descriptors.html">arr_create_descriptors.pro</a>', "arr_create_descriptors.pro", "", "arr_create_descriptors", "	Init method for the ARRAY class.    ", "crdCore descriptor(s) to pass to cor_create_descriptors.   ardStation descriptor(s) to initialize, instead of creating new 		ones.   n     Number of array descriptors.   @arr__keywords_tree.include", "NV/LIB/arr", "       Written by:     Spitale  	Adapted by:	Spitale, 5/2016          An array (n) of array descriptors.   STATUS:        Completed.    ");
  
  

libdata[libdataItem++] = new Array("obj/arr/arr_query.html", "arr_query.pro", '.pro file in <a href="obj/arr/dir-overview.html">obj/arr/ directory</a>', "arr_query.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/arr/arr_query.html#arr_query", "arr_query", 'routine in <a href="obj/arr/arr_query.html">arr_query.pro</a>', "arr_query.pro", "", "arr_query", "	Returns the fields associated with a ARRAY object.  This is a 	convenient way of getting multiple fields in one call, and only a 	single event is generated.    ", "conditionStructure specifing a mask and a condition with which to 			match flag values.  The structure must contain the fields 			MASK and STATE.  MASK is a bitmask to test against 			the flags field of the POINT object, and STATE 			is either PS_TRUE and PS_FALSE.  Note that in this case, 			the values will be returned as a list, with no separation 			into nv and nt dimensions.   cat	If set, arrays from mulitple input objets are 			concatenated.  	<condition>:	All of the predefined conditions (e.g. /visible) are 			accepted; see pnt_condition_keywords.include.   noeventIf set, no event is generated.   xd@arr__keywords_tree.include", "NV/OBJ/ARR", " 	Written by:	Spitale, 2/2017   ");
  
  

libdata[libdataItem++] = new Array("obj/arr/arr_replicate.html", "arr_replicate.pro", '.pro file in <a href="obj/arr/dir-overview.html">obj/arr/ directory</a>', "arr_replicate.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/arr/arr_set_surface_pts.html", "arr_set_surface_pts.pro", '.pro file in <a href="obj/arr/dir-overview.html">obj/arr/ directory</a>', "arr_set_surface_pts.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/arr/arr_surface_pts.html", "arr_surface_pts.pro", '.pro file in <a href="obj/arr/dir-overview.html">obj/arr/ directory</a>', "arr_surface_pts.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/bod/bod_aberration.html", "bod_aberration.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_aberration.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/bod/bod_assign.html", "bod_assign.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_assign.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/bod/bod_assign.html#bod_assign", "bod_assign", 'routine in <a href="obj/bod/bod_assign.html">bod_assign.pro</a>', "bod_assign.pro", "", "bod_assign", "	Replaces fields in a BODY object.  This is a convenient way of 	setting multiple fields in one call, and only a single event is 	generated.    ", "noeventIf set, no event is generated.   xd@bod__keywords_tree.include", "NV/OBJ/BOD", " 	Written by:	Spitale		2/2017   ");
  
  

libdata[libdataItem++] = new Array("obj/bod/bod_avel.html", "bod_avel.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_avel.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/bod/bod_body_to_inertial.html", "bod_body_to_inertial.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_body_to_inertial.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/bod/bod_body_to_inertial_default.html", "bod_body_to_inertial_default.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_body_to_inertial_default.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/bod/bod_body_to_inertial_pos.html", "bod_body_to_inertial_pos.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_body_to_inertial_pos.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/bod/bod_body_to_inertial_vel.html", "bod_body_to_inertial_vel.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_body_to_inertial_vel.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/bod/bod_body_to_radec.html", "bod_body_to_radec.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_body_to_radec.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/bod/bod_body_to_radec_vel.html", "bod_body_to_radec_vel.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_body_to_radec_vel.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/bod/bod_create_descriptors.html", "bod_create_descriptors.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_create_descriptors.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/bod/bod_create_descriptors.html#bod_create_descriptors", "bod_create_descriptors", 'routine in <a href="obj/bod/bod_create_descriptors.html">bod_create_descriptors.pro</a>', "bod_create_descriptors.pro", "", "bod_create_descriptors", "	Init method for the BODY class.    ", "crdbdnNumber of descriptors to create.   @bod__keywords_tree.include", "NV/LIB/BOD", " 	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016  	Newly created or or freshly initialized body descriptors, depending 	on the presence of the bd keyword.    STATUS: 	Complete    ");
  
  

libdata[libdataItem++] = new Array("obj/bod/bod_dlibdt.html", "bod_dlibdt.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_dlibdt.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/bod/bod_evolve.html", "bod_evolve.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_evolve.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/bod/bod_get_radec_ranges.html", "bod_get_radec_ranges.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_get_radec_ranges.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/bod/bod_ib_data.html", "bod_ib_data.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_ib_data.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/bod/bod_inertial.html", "bod_inertial.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_inertial.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/bod/bod_inertial_to_body.html", "bod_inertial_to_body.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_inertial_to_body.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/bod/bod_inertial_to_body_default.html", "bod_inertial_to_body_default.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_inertial_to_body_default.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/bod/bod_inertial_to_body_pos.html", "bod_inertial_to_body_pos.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_inertial_to_body_pos.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/bod/bod_inertial_to_body_vel.html", "bod_inertial_to_body_vel.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_inertial_to_body_vel.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/bod/bod_lib.html", "bod_lib.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_lib.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/bod/bod_libv.html", "bod_libv.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_libv.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/bod/bod_ndv.html", "bod_ndv.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_ndv.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/bod/bod_opaque.html", "bod_opaque.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_opaque.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/bod/bod_orient.html", "bod_orient.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_orient.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/bod/bod_pos.html", "bod_pos.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_pos.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/bod/bod_query.html", "bod_query.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_query.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/bod/bod_query.html#bod_query", "bod_query", 'routine in <a href="obj/bod/bod_query.html">bod_query.pro</a>', "bod_query.pro", "", "bod_query", "	Returns the fields associated with a BODY object.  This is a 	convenient way of getting multiple fields in one call, and only a 	single event is generated.    ", "conditionStructure specifing a mask and a condition with which to 			match flag values.  The structure must contain the fields 			MASK and STATE.  MASK is a bitmask to test against 			the flags field of the POINT object, and STATE 			is either PS_TRUE and PS_FALSE.  Note that in this case, 			the values will be returned as a list, with no separation 			into nv and nt dimensions.   cat	If set, arrays from mulitple input objets are 			concatenated.  	<condition>:	All of the predefined conditions (e.g. /visible) are 			accepted; see pnt_condition_keywords.include.   noeventIf set, no event is generated.   xd@bod__keywords_tree.include", "NV/OBJ/BOD", " 	Written by:	Spitale, 2/2017   ");
  
  

libdata[libdataItem++] = new Array("obj/bod/bod_radec_to_body.html", "bod_radec_to_body.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_radec_to_body.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/bod/bod_radec_to_body_vel.html", "bod_radec_to_body_vel.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_radec_to_body_vel.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/bod/bod_recenter.html", "bod_recenter.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_recenter.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/bod/bod_reorient.html", "bod_reorient.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_reorient.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/bod/bod_replicate.html", "bod_replicate.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_replicate.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/bod/bod_rotate.html", "bod_rotate.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_rotate.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/bod/bod_set_aberration.html", "bod_set_aberration.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_set_aberration.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/bod/bod_set_avel.html", "bod_set_avel.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_set_avel.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/bod/bod_set_dlibdt.html", "bod_set_dlibdt.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_set_dlibdt.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/bod/bod_set_ib_data.html", "bod_set_ib_data.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_set_ib_data.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/bod/bod_set_lib.html", "bod_set_lib.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_set_lib.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/bod/bod_set_libv.html", "bod_set_libv.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_set_libv.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/bod/bod_set_opaque.html", "bod_set_opaque.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_set_opaque.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/bod/bod_set_orient.html", "bod_set_orient.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_set_orient.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/bod/bod_set_pos.html", "bod_set_pos.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_set_pos.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/bod/bod_set_time.html", "bod_set_time.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_set_time.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/bod/bod_set_vel.html", "bod_set_vel.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_set_vel.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/bod/bod_time.html", "bod_time.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_time.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/bod/bod_vel.html", "bod_vel.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_vel.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/tools/composite/body_radius.html", "body_radius.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "body_radius.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/tools/composite/body_to_image_pos.html", "body_to_image_pos.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "body_to_image_pos.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/tools/composite/body_to_surface.html", "body_to_surface.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "body_to_surface.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("grim/brim.html", "brim.pro", '.pro file in <a href="grim/dir-overview.html">grim/ directory</a>', "brim.pro", "", "", "	Image browser.    	brim may be run standalone or from within grim.  If no files or data 	descriptors are given, brim first prompts the user to select a list of 	files.  brim then displays thumbnails of all valid files.  Files may be 	selected by clicking with the left mouse button.  By default, the image 	is opened in a new grim window.  Alternate actions may be defined 	through procedures supplied by the caller.    EXAMPLES: 	To load files into brim using a file-selection widget:  	 IDL> brim   	To load all recognizeable images in the current directory into brim:  	 IDL> brim, '*'   	To browse a set of data descriptors:  	 IDL> dd = dat_read('*') 	 IDL> brim, dd    STATUS: 	Complete.    ", "", "          -1", " 	Written by:	Spitale, 10/2002   ");
  

libdata[libdataItem++] = new Array("obj/cam/cam_assign.html", "cam_assign.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_assign.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cam/cam_assign.html#cam_assign", "cam_assign", 'routine in <a href="obj/cam/cam_assign.html">cam_assign.pro</a>', "cam_assign.pro", "", "cam_assign", "	Replaces fields in a CAMERA object.  This is a convenient way of 	setting multiple fields in one call, and only a single event is 	generated.    ", "noeventIf set, no event is generated.   xd@cam__keywords_tree.include", "NV/OBJ/CAM", " 	Written by:	Spitale		2/2017   ");
  
  

libdata[libdataItem++] = new Array("obj/cam/cam_body_to_focal.html", "cam_body_to_focal.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_body_to_focal.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/cam/cam_create_descriptors.html", "cam_create_descriptors.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_create_descriptors.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cam/cam_create_descriptors.html#cam_create_descriptors", "cam_create_descriptors", 'routine in <a href="obj/cam/cam_create_descriptors.html">cam_create_descriptors.pro</a>', "cam_create_descriptors.pro", "", "cam_create_descriptors", "	Init method for the CAMERA class.    ", "crdbdcdnNumber of descriptors to create.   @cam__keywords_tree.include", "NV/LIB/CAM", " 	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   	Newly created or or freshly initialized camera descriptors, depending 	on the presence of the cd keyword.    STATUS: 	Complete    ");
  
  

libdata[libdataItem++] = new Array("obj/cam/cam_evolve.html", "cam_evolve.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_evolve.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/cam/cam_exposure.html", "cam_exposure.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_exposure.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/cam/cam_fi_data.html", "cam_fi_data.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_fi_data.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/cam/cam_filters.html", "cam_filters.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_filters.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/cam/cam_fn_focal_to_image.html", "cam_fn_focal_to_image.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_fn_focal_to_image.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/cam/cam_fn_image_to_focal.html", "cam_fn_image_to_focal.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_fn_image_to_focal.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/cam/cam_fn_psf.html", "cam_fn_psf.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_fn_psf.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/cam/cam_focal_to_body.html", "cam_focal_to_body.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_focal_to_body.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/cam/cam_focal_to_image.html", "cam_focal_to_image.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_focal_to_image.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/cam/cam_focal_to_image_linear.html", "cam_focal_to_image_linear.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_focal_to_image_linear.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/cam/cam_focal_to_image_poly.html", "cam_focal_to_image_poly.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_focal_to_image_poly.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/cam/cam_focal_to_image_radial.html", "cam_focal_to_image_radial.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_focal_to_image_radial.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/cam/cam_get_poly_matrices.html", "cam_get_poly_matrices.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_get_poly_matrices.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/cam/cam_get_radec_twist.html", "cam_get_radec_twist.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_get_radec_twist.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/cam/cam_image_to_focal.html", "cam_image_to_focal.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_image_to_focal.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/cam/cam_image_to_focal_linear.html", "cam_image_to_focal_linear.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_image_to_focal_linear.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/cam/cam_image_to_focal_poly.html", "cam_image_to_focal_poly.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_image_to_focal_poly.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/cam/cam_image_to_focal_radial.html", "cam_image_to_focal_radial.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_image_to_focal_radial.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/cam/cam_nfilters.html", "cam_nfilters.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_nfilters.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/cam/cam_oaxis.html", "cam_oaxis.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_oaxis.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/cam/cam_origin.html", "cam_origin.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_origin.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/cam/cam_psf.html", "cam_psf.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_psf.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/cam/cam_psf_attrib.html", "cam_psf_attrib.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_psf_attrib.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/cam/cam_query.html", "cam_query.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_query.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cam/cam_query.html#cam_query", "cam_query", 'routine in <a href="obj/cam/cam_query.html">cam_query.pro</a>', "cam_query.pro", "", "cam_query", "	Returns the fields associated with a CAMERA object.  This is a 	convenient way of getting multiple fields in one call, and only a 	single event is generated.    ", "conditionStructure specifing a mask and a condition with which to 			match flag values.  The structure must contain the fields 			MASK and STATE.  MASK is a bitmask to test against 			the flags field of the POINT object, and STATE 			is either PS_TRUE and PS_FALSE.  Note that in this case, 			the values will be returned as a list, with no separation 			into nv and nt dimensions.   cat	If set, arrays from mulitple input objets are 			concatenated.  	<condition>:	All of the predefined conditions (e.g. /visible) are 			accepted; see pnt_condition_keywords.include.   noeventIf set, no event is generated.   xd@cam__keywords_tree.include", "NV/OBJ/CAM", " 	Written by:	Spitale, 2/2017   ");
  
  

libdata[libdataItem++] = new Array("obj/cam/cam_rebin.html", "cam_rebin.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_rebin.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/cam/cam_reorient.html", "cam_reorient.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_reorient.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cam/cam_reorient.html#cam_reorient", "cam_reorient", 'routine in <a href="obj/cam/cam_reorient.html">cam_reorient.pro</a>', "cam_reorient.pro", "", "cam_reorient", "       Repoints the camera orientiation matrix based on x,y, and theta 	image offsets.    ", "absoluteIf set, the dxy argument represents an absolute image 		  position rather than an offset.   nsin_anglecos_anglecd0image_axisArray (2,1,nt) of image points corresponding to the 			rotation axis for each descriptor.   dxyArray (2,1,nt) of image offsets in x and y.   dtheta", "NV/LIB/CAM", " 	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ");
  
  

libdata[libdataItem++] = new Array("obj/cam/cam_replicate.html", "cam_replicate.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_replicate.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/cam/cam_rescale.html", "cam_rescale.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_rescale.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/cam/cam_resize.html", "cam_resize.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_resize.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/cam/cam_scale.html", "cam_scale.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_scale.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/cam/cam_set_exposure.html", "cam_set_exposure.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_set_exposure.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/cam/cam_set_fi_data.html", "cam_set_fi_data.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_set_fi_data.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/cam/cam_set_filters.html", "cam_set_filters.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_set_filters.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/cam/cam_set_fn_focal_to_image.html", "cam_set_fn_focal_to_image.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_set_fn_focal_to_image.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/cam/cam_set_fn_image_to_focal.html", "cam_set_fn_image_to_focal.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_set_fn_image_to_focal.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/cam/cam_set_fn_psf.html", "cam_set_fn_psf.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_set_fn_psf.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/cam/cam_set_oaxis.html", "cam_set_oaxis.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_set_oaxis.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/cam/cam_set_origin.html", "cam_set_origin.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_set_origin.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/cam/cam_set_poly_matrices.html", "cam_set_poly_matrices.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_set_poly_matrices.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/cam/cam_set_scale.html", "cam_set_scale.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_set_scale.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/cam/cam_set_size.html", "cam_set_size.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_set_size.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/cam/cam_size.html", "cam_size.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_size.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/cam/cam_subimage.html", "cam_subimage.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_subimage.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/tools/cd_to_radec_twist.html", "cd_to_radec_twist.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "cd_to_radec_twist.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/cor/cor_abbrev.html", "cor_abbrev.pro", '.pro file in <a href="obj/cor/dir-overview.html">obj/cor/ directory</a>', "cor_abbrev.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/cor/cor_add_task.html", "cor_add_task.pro", '.pro file in <a href="obj/cor/dir-overview.html">obj/cor/ directory</a>', "cor_add_task.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/cor/cor_assign.html", "cor_assign.pro", '.pro file in <a href="obj/cor/dir-overview.html">obj/cor/ directory</a>', "cor_assign.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cor/cor_assign.html#cor_assign", "cor_assign", 'routine in <a href="obj/cor/cor_assign.html">cor_assign.pro</a>', "cor_assign.pro", "", "cor_assign", "	Replaces fields in a POINT object.  This is a fast way of 	setting multiple fields in one call, and only a single event is 	generated.    ", "noeventIf set, no event is generated.   xd	CORE object.   @cor__keywords.include", "NV/OBJ/PNT", " 	Written by:	Spitale		1/2017   ");
  
  

libdata[libdataItem++] = new Array("obj/cor/cor_associate_gd.html", "cor_associate_gd.pro", '.pro file in <a href="obj/cor/dir-overview.html">obj/cor/ directory</a>', "cor_associate_gd.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/cor/cor_class.html", "cor_class.pro", '.pro file in <a href="obj/cor/dir-overview.html">obj/cor/ directory</a>', "cor_class.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/cor/cor_class_info.html", "cor_class_info.pro", '.pro file in <a href="obj/cor/dir-overview.html">obj/cor/ directory</a>', "cor_class_info.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/cor/cor_count_descriptors.html", "cor_count_descriptors.pro", '.pro file in <a href="obj/cor/dir-overview.html">obj/cor/ directory</a>', "cor_count_descriptors.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/cor/cor_create_descriptors.html", "cor_create_descriptors.pro", '.pro file in <a href="obj/cor/dir-overview.html">obj/cor/ directory</a>', "cor_create_descriptors.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cor/cor_create_descriptors.html#cor_create_descriptors", "cor_create_descriptors", 'routine in <a href="obj/cor/cor_create_descriptors.html">cor_create_descriptors.pro</a>', "cor_create_descriptors.pro", "", "cor_create_descriptors", "	Init method for the CORE class.    ", "crdCore descriptor(s) to initialize, instead of creating a new one.   n Number of descriptors to create.   @cor__keywords.include", "NV/LIB/COR", " 	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   	Newly created or or freshly initialized core descriptors depending 	on the presence of the crd keyword.    STATUS: 	Complete    ");
  
  

libdata[libdataItem++] = new Array("obj/cor/cor_create_gd.html", "cor_create_gd.pro", '.pro file in <a href="obj/cor/dir-overview.html">obj/cor/ directory</a>', "cor_create_gd.pro", "", "", "	Creates a generic descriptor from a set of given descriptors.    ", "", "          -1", " 	Written by:	Spitale 	Moved to CORE	Spitale		2/2017   ");
  

libdata[libdataItem++] = new Array("obj/cor/cor_cull.html", "cor_cull.pro", '.pro file in <a href="obj/cor/dir-overview.html">obj/cor/ directory</a>', "cor_cull.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/cor/cor_dereference.html", "cor_dereference.pro", '.pro file in <a href="obj/cor/dir-overview.html">obj/cor/ directory</a>', "cor_dereference.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/cor/cor_dereference_gd.html", "cor_dereference_gd.pro", '.pro file in <a href="obj/cor/dir-overview.html">obj/cor/ directory</a>', "cor_dereference_gd.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/cor/cor_evolve.html", "cor_evolve.pro", '.pro file in <a href="obj/cor/dir-overview.html">obj/cor/ directory</a>', "cor_evolve.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/cor/cor_gd.html", "cor_gd.pro", '.pro file in <a href="obj/cor/dir-overview.html">obj/cor/ directory</a>', "cor_gd.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/cor/cor_init_state.html", "cor_init_state.pro", '.pro file in <a href="obj/cor/dir-overview.html">obj/cor/ directory</a>', "cor_init_state.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/cor/cor_match_gd.html", "cor_match_gd.pro", '.pro file in <a href="obj/cor/dir-overview.html">obj/cor/ directory</a>', "cor_match_gd.pro", "", "", "	Compares generic descriptors.    ", "", "          -1", " 	Written by:	Spitale		2/2017   ");
  

libdata[libdataItem++] = new Array("obj/cor/cor_name.html", "cor_name.pro", '.pro file in <a href="obj/cor/dir-overview.html">obj/cor/ directory</a>', "cor_name.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/cor/cor_query.html", "cor_query.pro", '.pro file in <a href="obj/cor/dir-overview.html">obj/cor/ directory</a>', "cor_query.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cor/cor_query.html#cor_query", "cor_query", 'routine in <a href="obj/cor/cor_query.html">cor_query.pro</a>', "cor_query.pro", "", "cor_query", "	Returns fields associated with a CORE object.  This is a 	fast way of retrieving multiple fields in one call, and only a 	single event is generated.    ", "noeventIf set, no event is generated.   xdCORE object.   @cor__keywords.include", "NV/OBJ/COR", " 	Written by:	Spitale, 1/2017   ");
  
  

libdata[libdataItem++] = new Array("obj/cor/cor_replicate.html", "cor_replicate.pro", '.pro file in <a href="obj/cor/dir-overview.html">obj/cor/ directory</a>', "cor_replicate.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/cor/cor_rereference.html", "cor_rereference.pro", '.pro file in <a href="obj/cor/dir-overview.html">obj/cor/ directory</a>', "cor_rereference.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/cor/cor_select.html", "cor_select.pro", '.pro file in <a href="obj/cor/dir-overview.html">obj/cor/ directory</a>', "cor_select.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cor/cor_select.html#cor_select", "cor_select", 'routine in <a href="obj/cor/cor_select.html">cor_select.pro</a>', "cor_select.pro", "", "cor_select", "	Selects descriptors based on given criteria.    ", "indicesrmnoeventnameclasscrx Array of descriptors of any subclass of CORE.   key Array of key to select.   ", "NV/SYS/COR", " 	Written by:	Spitale, 1/1998  	Rewritten by:	Spitale, 4/2016   	All descriptors in crx whose parameters match the given key. 	0 if no matches found.    STATUS: 	Complete    ");
  
  

libdata[libdataItem++] = new Array("obj/cor/cor_set_gd.html", "cor_set_gd.pro", '.pro file in <a href="obj/cor/dir-overview.html">obj/cor/ directory</a>', "cor_set_gd.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/cor/cor_set_name.html", "cor_set_name.pro", '.pro file in <a href="obj/cor/dir-overview.html">obj/cor/ directory</a>', "cor_set_name.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/cor/cor_set_udata.html", "cor_set_udata.pro", '.pro file in <a href="obj/cor/dir-overview.html">obj/cor/ directory</a>', "cor_set_udata.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/cor/cor_state.html", "cor_state.pro", '.pro file in <a href="obj/cor/dir-overview.html">obj/cor/ directory</a>', "cor_state.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/cor/cor_tag.html", "cor_tag.pro", '.pro file in <a href="obj/cor/dir-overview.html">obj/cor/ directory</a>', "cor_tag.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/cor/cor_tasks.html", "cor_tasks.pro", '.pro file in <a href="obj/cor/dir-overview.html">obj/cor/ directory</a>', "cor_tasks.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/cor/cor_test.html", "cor_test.pro", '.pro file in <a href="obj/cor/dir-overview.html">obj/cor/ directory</a>', "cor_test.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/cor/cor_test_gd.html", "cor_test_gd.pro", '.pro file in <a href="obj/cor/dir-overview.html">obj/cor/ directory</a>', "cor_test_gd.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/cor/cor_test_udata.html", "cor_test_udata.pro", '.pro file in <a href="obj/cor/dir-overview.html">obj/cor/ directory</a>', "cor_test_udata.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/cor/cor_tree.html", "cor_tree.pro", '.pro file in <a href="obj/cor/dir-overview.html">obj/cor/ directory</a>', "cor_tree.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/cor/cor_udata.html", "cor_udata.pro", '.pro file in <a href="obj/cor/dir-overview.html">obj/cor/ directory</a>', "cor_udata.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/cor/cor_user.html", "cor_user.pro", '.pro file in <a href="obj/cor/dir-overview.html">obj/cor/ directory</a>', "cor_user.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/cor/core_state_struct__define.html", "core_state_struct__define.pro", '.pro file in <a href="obj/cor/dir-overview.html">obj/cor/ directory</a>', "core_state_struct__define.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dat/dat_add_transient_keyvals.html", "dat_add_transient_keyvals.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_add_transient_keyvals.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dat/dat_assign.html", "dat_assign.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_assign.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_assign.html#dat_assign", "dat_assign", 'routine in <a href="obj/dat/dat_assign.html">dat_assign.pro</a>', "dat_assign.pro", "", "dat_assign", "	Replaces fields in a CAMERA object.  This is a convenient way of 	setting multiple fields in one call, and only a single event is 	generated.    ", "noeventIf set, no event is generated.   xd@dat__keywords_tree.include", "NV/OBJ/CAM", " 	Written by:	Spitale		2/2017   ");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_cache.html", "dat_cache.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_cache.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dat/dat_compress.html", "dat_compress.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_compress.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dat/dat_create_descriptors.html", "dat_create_descriptors.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_create_descriptors.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_create_descriptors.html#dat_create_descriptors", "dat_create_descriptors", 'routine in <a href="obj/dat/dat_create_descriptors.html">dat_create_descriptors.pro</a>', "dat_create_descriptors.pro", "", "dat_create_descriptors", "	Creates and initializes a data descriptor.    ", "crdddn Number of descriptors to create.   @dat__keywords_tree.include", "NV/SYS", " 	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   	Newly created and initialized data descriptor.    STATUS: 	Complete    ");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_data.html", "dat_data.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_data.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_data.html#dat_data", "dat_data", 'routine in <a href="obj/dat/dat_data.html">dat_data.pro</a>', "dat_data.pro", "", "dat_data", "	Returns the data array associated with a data descriptor.    ", "samples Output sample indices for /current.    current If set, the current loaded samples are returned.  In this 		  case, the sample indices are returned in the  samples  		  keyword.   slice  Slice coordinates.   nd      If set, the samples input is taken to be an ND coordinate 	          rather than a 1D subscript.  dat_data can normally tell 	          the difference automatically, but there is an ambiguity 	          if a single ND point is requested.  In that case, dat_data 	          interprets that as an array of 1D subscripts, unless /nd 	          is set.   true    If set, the actual data array is returned, even if there is 	          a sampling function.   noeventabscissaThe abscissa is returned in this array.   ddData descriptor.   ", "NV/SYS", " 	Written by:	Spitale, 2/1998  	Adapted by:	Spitale, 5/2016   	The data array associated with the data descriptor.    STATUS: 	Complete    SEE ALSO: 	dat_set_data    ");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_detect_filetype.html", "dat_detect_filetype.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_detect_filetype.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dat/dat_detect_instrument.html", "dat_detect_instrument.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_detect_instrument.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dat/dat_dh.html", "dat_dh.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_dh.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dat/dat_dim.html", "dat_dim.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_dim.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dat/dat_dim_data.html", "dat_dim_data.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_dim_data.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dat/dat_dim_fn.html", "dat_dim_fn.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_dim_fn.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dat/dat_filename.html", "dat_filename.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_filename.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dat/dat_filetype.html", "dat_filetype.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_filetype.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dat/dat_gd.html", "dat_gd.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_gd.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dat/dat_get_value.html", "dat_get_value.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_get_value.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_get_value.html#dat_get_value", "dat_get_value", 'routine in <a href="obj/dat/dat_get_value.html">dat_get_value.pro</a>', "dat_get_value.pro", "", "dat_get_value", "	Calls input translators, supplying the given keyword, and builds 	a list of returned descriptors.    ", "status	0 if at least one translator call was successful, 			-1 otherwise.    trs	Transient argument string.   dd	Data descriptors.  Must all have the same instrument 			string.   keywordKeyword to pass to translators, describing the 			requested quantity.   @nv_trs_keywords_include.pro", "NV/SYS", " 	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   	Array of descriptors returned from all successful translator calls. 	Descriptors are returned in the same order that the corresponding 	translators were called.  Each translator may produce multiple 	descriptors.    STATUS: 	Complete    ");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_gff.html", "dat_gff.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_gff.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dat/dat_header.html", "dat_header.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_header.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dat/dat_header_value.html", "dat_header_value.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_header_value.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dat/dat_input_fn.html", "dat_input_fn.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_input_fn.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dat/dat_input_keyvals.html", "dat_input_keyvals.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_input_keyvals.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dat/dat_input_transforms.html", "dat_input_transforms.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_input_transforms.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dat/dat_input_translators.html", "dat_input_translators.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_input_translators.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dat/dat_instrument.html", "dat_instrument.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_instrument.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dat/dat_keyword_fn.html", "dat_keyword_fn.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_keyword_fn.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dat/dat_load_data.html", "dat_load_data.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_load_data.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dat/dat_lookup_io.html", "dat_lookup_io.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_lookup_io.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dat/dat_lookup_transforms.html", "dat_lookup_transforms.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_lookup_transforms.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_lookup_transforms.html#dat_lookup_transforms", "dat_lookup_transforms", 'routine in <a href="obj/dat/dat_lookup_transforms.html">dat_lookup_transforms.pro</a>', "dat_lookup_transforms.pro", "", "dat_lookup_transforms", "	Looks up the names of the data input and output functions in 	the I/O table.    ", "tab_transformsinstrumentInstrument string from dat_detect_instrument.   input_transformsoutput_transforms", "NV/SYS", " 	Written by:	Spitale   	input_transforms:	Array giving the names of the input transform 				functions.  	output_transforms:	Array giving the names of the output transform 				functions.    ");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_lookup_translators.html", "dat_lookup_translators.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_lookup_translators.pro", "", "", "	Looks up the names of the data input and output tranlators in 	the translators table.    ", "", "          -1", " 	Written by:	Spitale   ");
  

libdata[libdataItem++] = new Array("obj/dat/dat_maintain.html", "dat_maintain.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_maintain.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dat/dat_manage_dd.html", "dat_manage_dd.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_manage_dd.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dat/dat_max.html", "dat_max.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_max.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dat/dat_min.html", "dat_min.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_min.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dat/dat_n.html", "dat_n.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_n.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dat/dat_ndd.html", "dat_ndd.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_ndd.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dat/dat_nhist.html", "dat_nhist.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_nhist.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dat/dat_output_fn.html", "dat_output_fn.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_output_fn.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dat/dat_output_keyvals.html", "dat_output_keyvals.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_output_keyvals.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dat/dat_output_transforms.html", "dat_output_transforms.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_output_transforms.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dat/dat_output_translators.html", "dat_output_translators.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_output_translators.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dat/dat_parse_keyval.html", "dat_parse_keyval.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_parse_keyval.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dat/dat_parse_keyvals.html", "dat_parse_keyvals.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_parse_keyvals.pro", "", "", "	Parses an array strings containing keyword=value pairs.    ", "", "          -1", " 	Written by:	Spitale   ");
  

libdata[libdataItem++] = new Array("obj/dat/dat_parse_transient_keyvals.html", "dat_parse_transient_keyvals.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_parse_transient_keyvals.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dat/dat_put_value.html", "dat_put_value.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_put_value.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_put_value.html#dat_put_value", "dat_put_value", 'routine in <a href="obj/dat/dat_put_value.html">dat_put_value.pro</a>', "dat_put_value.pro", "", "dat_put_value", "	Calls output translators, supplying the given keyword and value.    ", "trs	Transient argument string.   status	0 if at least one translator call was successful, 			-1 otherwise.    dd	Data descriptor.   keywordKeyword to pass to translators, describing the 			requested quantity.   value	Value to write through the translators.   @nv_trs_keywords_include.pro", "NV/SYS", " 	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_query.html", "dat_query.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_query.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_query.html#dat_query", "dat_query", 'routine in <a href="obj/dat/dat_query.html">dat_query.pro</a>', "dat_query.pro", "", "dat_query", "	Returns the fields associated with a CAMERA object.  This is a 	convenient way of getting multiple fields in one call, and only a 	single event is generated.    ", "conditionStructure specifing a mask and a condition with which to 			match flag values.  The structure must contain the fields 			MASK and STATE.  MASK is a bitmask to test against 			the flags field of the POINT object, and STATE 			is either PS_TRUE and PS_FALSE.  Note that in this case, 			the values will be returned as a list, with no separation 			into nv and nt dimensions.   cat	If set, arrays from mulitple input objets are 			concatenated.  	<condition>:	All of the predefined conditions (e.g. /visible) are 			accepted; see pnt_condition_keywords.include.   noeventIf set, no event is generated.   xd@dat__keywords_tree.include", "NV/OBJ/CAM", " 	Written by:	Spitale, 2/2017   ");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_read.html", "dat_read.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_read.pro", "", "", "	Reads a data file of arbitrary format and produces a data descriptor.    	dat_read expands all file specifications and then attempts to detect 	the filetype for each resulting filename using the filetype detectors 	table.  If a filetype is detected, dat_read looks up the I/O functions 	and calls the input function to read the file.  Finally, it calls 	nv_init_descriptor to obtain a data descriptor.    STATUS: 	Complete    SEE ALSO: 	dat_write    ", "", "          -1", " 	Written by:	Spitale, 2/1998   ");
  

libdata[libdataItem++] = new Array("obj/dat/dat_read_config.html", "dat_read_config.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_read_config.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dat/dat_redo.html", "dat_redo.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_redo.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dat/dat_replicate.html", "dat_replicate.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_replicate.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dat/dat_sampling_data.html", "dat_sampling_data.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_sampling_data.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dat/dat_sampling_fn.html", "dat_sampling_fn.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_sampling_fn.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dat/dat_set_compress.html", "dat_set_compress.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_set_compress.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dat/dat_set_data.html", "dat_set_data.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_set_data.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_set_data.html#dat_set_data", "dat_set_data", 'routine in <a href="obj/dat/dat_set_data.html">dat_set_data.pro</a>', "dat_set_data.pro", "", "dat_set_data", "	Replaces the data array associated with a data descriptor.    ", "updateUpdate mode flag.  If not given, it will be taken from dd.   noeventabscissaIf set, the given array is taken as the abscissa.   sampleddData descriptor.   _dataNew data array.   ", "NV/SYS", " 	Written by:	Spitale, 2/1998  	Adapted by:	Spitale, 5/2016   	dd:	Modified data descriptor.    ");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_set_dh.html", "dat_set_dh.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_set_dh.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dat/dat_set_dim.html", "dat_set_dim.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_set_dim.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dat/dat_set_dim_data.html", "dat_set_dim_data.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_set_dim_data.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dat/dat_set_dim_fn.html", "dat_set_dim_fn.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_set_dim_fn.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dat/dat_set_filename.html", "dat_set_filename.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_set_filename.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dat/dat_set_filetype.html", "dat_set_filetype.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_set_filetype.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dat/dat_set_gd.html", "dat_set_gd.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_set_gd.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dat/dat_set_gff.html", "dat_set_gff.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_set_gff.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dat/dat_set_header.html", "dat_set_header.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_set_header.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dat/dat_set_input_fn.html", "dat_set_input_fn.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_set_input_fn.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dat/dat_set_input_keyvals.html", "dat_set_input_keyvals.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_set_input_keyvals.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dat/dat_set_input_transforms.html", "dat_set_input_transforms.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_set_input_transforms.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dat/dat_set_input_translators.html", "dat_set_input_translators.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_set_input_translators.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dat/dat_set_instrument.html", "dat_set_instrument.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_set_instrument.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dat/dat_set_keyword_fn.html", "dat_set_keyword_fn.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_set_keyword_fn.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dat/dat_set_maintain.html", "dat_set_maintain.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_set_maintain.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dat/dat_set_max.html", "dat_set_max.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_set_max.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dat/dat_set_min.html", "dat_set_min.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_set_min.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dat/dat_set_ndd.html", "dat_set_ndd.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_set_ndd.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dat/dat_set_nhist.html", "dat_set_nhist.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_set_nhist.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dat/dat_set_output_fn.html", "dat_set_output_fn.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_set_output_fn.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dat/dat_set_output_keyvals.html", "dat_set_output_keyvals.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_set_output_keyvals.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dat/dat_set_output_transforms.html", "dat_set_output_transforms.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_set_output_transforms.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dat/dat_set_output_translators.html", "dat_set_output_translators.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_set_output_translators.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dat/dat_set_sampling_data.html", "dat_set_sampling_data.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_set_sampling_data.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dat/dat_set_sampling_fn.html", "dat_set_sampling_fn.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_set_sampling_fn.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dat/dat_set_sibling.html", "dat_set_sibling.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_set_sibling.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dat/dat_set_slice.html", "dat_set_slice.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_set_slice.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dat/dat_set_typecode.html", "dat_set_typecode.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_set_typecode.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dat/dat_set_update.html", "dat_set_update.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_set_update.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dat/dat_sibling.html", "dat_sibling.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_sibling.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dat/dat_slice.html", "dat_slice.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_slice.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dat/dat_slices.html", "dat_slices.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_slices.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dat/dat_test_dd.html", "dat_test_dd.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_test_dd.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dat/dat_typecode.html", "dat_typecode.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_typecode.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dat/dat_undo.html", "dat_undo.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_undo.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dat/dat_unload_data.html", "dat_unload_data.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_unload_data.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dat/dat_update.html", "dat_update.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_update.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dat/dat_valid_descriptor.html", "dat_valid_descriptor.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_valid_descriptor.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dat/dat_write.html", "dat_write.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_write.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_write.html#dat_write", "dat_write", 'routine in <a href="obj/dat/dat_write.html">dat_write.pro</a>', "dat_write.pro", "", "dat_write", "	Writes a data file of arbitrary format.    	dat_write expands all file specifications and attempts to write a 	file corresponding to each given data descriptor.  An error results 	if the filespec expands to a different number of files than the number 	of given data descriptors.    STATUS: 	Complete    SEE ALSO: 	dat_read    ", "nodatafiletypeOverrides data descriptor filetype (and thus the 			output function).  Data descriptor filetype is 			updated unless /override.   output_fnOverrides data descriptor output function.  Data 			descriptor output_fn is updated unless /override.   overrideIf set, filespec, filetype, and output_fn inputs 			are used for this call, but not updated in the data 			descriptor.    arg1arg2", "NV/SYS", " 	Written by:	Spitale, 7/1998  	Adapted by:	Spitale, 5/2016   ");
  
  

libdata[libdataItem++] = new Array("obj/dat/dh/util/dh_create.html", "dh_create.pro", '.pro file in <a href="obj/dat/dh/util/dir-overview.html">obj/dat/dh/util/ directory</a>', "dh_create.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dat/dh/util/dh_create_section.html", "dh_create_section.pro", '.pro file in <a href="obj/dat/dh/util/dir-overview.html">obj/dat/dh/util/ directory</a>', "dh_create_section.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dat/dh/util/dh_get_value.html", "dh_get_value.pro", '.pro file in <a href="obj/dat/dh/util/dir-overview.html">obj/dat/dh/util/ directory</a>', "dh_get_value.pro", "", "", "	Gets the value of a specified keyword.    ", "", "          -1", " 	Written by:	Spitale, 7/1998 	Added 'section' keyword: Spitale; 11/2001   ");
  

libdata[libdataItem++] = new Array("obj/dat/dh/util/dh_put_value.html", "dh_put_value.pro", '.pro file in <a href="obj/dat/dh/util/dir-overview.html">obj/dat/dh/util/ directory</a>', "dh_put_value.pro", "", "", "	Sets the value of a specified keyword.    	See procedure below; 'utime' and 'history' keywords are modified.    	The data is appended to the top of the specified section of the detached 	header using the given object index and a history index that is one 	greater than the current value found in the detached header for this 	keyword.  The value of the 'utime' keyword corresponding to this history 	index is modified to reflect the current time.  If this history index is 	greater than that given by the 'history' keyword, then that value is 	modified as well.  	If 'value' is an array, then each element is written on a different line 	using the keyword with the same object index, history index, and 	comment, but whose element indices reflect the order that the data 	appear in the array.  	If 'value' is of string type, then each entry is enclosed in quotes.    ", "", "          -1", " 	Written by:	Spitale, 7/1998 	Added 'section' keyword: Spitale; 11/2001   	The following commands:  		IDL> val=[7,6,5,4,3] 		IDL> dh_put_value, dh, 'test_key', val  	produce the following detached header:  	 history = -1 / Current history value 	 <updates> 	 utime = 2451022.404086 / Julian day of update - Mon Jul 27 9:41:53 1998 	 test_key(0) = 7 	 test_key(1) = 6 	 test_key(2) = 5 	 test_key(3) = 4 	 test_key(4) = 3     STATUS: 	Complete    SEE ALSO: 	dh_get_value, dh_rm_value ");
  

libdata[libdataItem++] = new Array("obj/dat/dh/util/dh_read.html", "dh_read.pro", '.pro file in <a href="obj/dat/dh/util/dir-overview.html">obj/dat/dh/util/ directory</a>', "dh_read.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dat/dh/util/dh_rm_value.html", "dh_rm_value.pro", '.pro file in <a href="obj/dat/dh/util/dir-overview.html">obj/dat/dh/util/ directory</a>', "dh_rm_value.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dh/util/dh_rm_value.html#dh_rm_value", "dh_rm_value", 'routine in <a href="obj/dat/dh/util/dh_rm_value.html">dh_rm_value.pro</a>', "dh_rm_value.pro", "", "dh_rm_value", "	Deletes a specified keyword/value pair.    ", "n_matchMaximum number of matches to return.  If not given, 			all matches are returned.   all_matchIf set, match all occurrences.   all_objectIf set, match all object indices.  If not set, then 			match only object index 0.   all_historyIf set, match all history indices.  If not set, 			then only the highest history index is matched.   count	Integer giving the numebr of keywords matched.    object_indexIf given, then match only this object index.   history_indexIf given, then match only this history index.   prefix	If set, then match any keyword which begins with the 			given keyword string instead of requiring an exact 			match.   dh	String giving the detached header.   keywordString giving the keyword to be deleted.   ", "UTIL/DH", " 	Written by:	Spitale, 7/1998   	dh:		dh is modified on return.     ");
  
  

libdata[libdataItem++] = new Array("obj/dat/dh/dh_std_input.html", "dh_std_input.pro", '.pro file in <a href="obj/dat/dh/dir-overview.html">obj/dat/dh/ directory</a>', "dh_std_input.pro", "", "", "	Input translator for detached header    ", "", "          -1", " 	Written by:	Spitale, 1998   ");
  

libdata[libdataItem++] = new Array("obj/dat/dh/dh_std_output.html", "dh_std_output.pro", '.pro file in <a href="obj/dat/dh/dir-overview.html">obj/dat/dh/ directory</a>', "dh_std_output.pro", "", "", "	Output translator for detached headers.    	The detached header in the data descriptor is modified.    STATUS: 	Complete    SEE ALSO: 	dh_std_input    ", "", "          -1", " 	Written by:	Spitale, 1998   ");
  

libdata[libdataItem++] = new Array("obj/dat/dh/util/dh_validate.html", "dh_validate.pro", '.pro file in <a href="obj/dat/dh/util/dir-overview.html">obj/dat/dh/util/ directory</a>', "dh_validate.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dat/dh/util/dh_write.html", "dh_write.pro", '.pro file in <a href="obj/dat/dh/util/dir-overview.html">obj/dat/dh/util/ directory</a>', "dh_write.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/tools/composite/disk_to_image.html", "disk_to_image.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "disk_to_image.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/tools/composite/disk_to_inertial_pos.html", "disk_to_inertial_pos.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "disk_to_inertial_pos.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/tools/composite/disk_to_map.html", "disk_to_map.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "disk_to_map.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_apply_radial_scale.html", "dsk_apply_radial_scale.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_apply_radial_scale.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_assign.html", "dsk_assign.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_assign.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_assign.html#dsk_assign", "dsk_assign", 'routine in <a href="obj/dsk/dsk_assign.html">dsk_assign.pro</a>', "dsk_assign.pro", "", "dsk_assign", "	Replaces fields in a DISK object.  This is a convenient way of 	setting multiple fields in one call, and only a single event is 	generated.    ", "noeventIf set, no event is generated.   xd@dsk__keywords_tree.include", "NV/OBJ/DSK", " 	Written by:	Spitale		2/2017   ");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_body_to_disk.html", "dsk_body_to_disk.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_body_to_disk.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/tools/dsk_cat.html", "dsk_cat.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "dsk_cat.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/tools/dsk_cat_by_name.html", "dsk_cat_by_name.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "dsk_cat_by_name.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_create_descriptors.html", "dsk_create_descriptors.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_create_descriptors.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_create_descriptors.html#dsk_create_descriptors", "dsk_create_descriptors", 'routine in <a href="obj/dsk/dsk_create_descriptors.html">dsk_create_descriptors.pro</a>', "dsk_create_descriptors.pro", "", "dsk_create_descriptors", "	Init method for the DISK class.    ", "crdbdslddkdnNumber of descriptors to create.   @dsk__keywords_tree.include", "NV/LIB/DSK", " 	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   	Newly created or or freshly initialized disk descriptors, depending 	on the presence of the dkd keyword.    STATUS: 	Complete    ");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_dap.html", "dsk_dap.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_dap.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_disk_to_body.html", "dsk_disk_to_body.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_disk_to_body.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_dlibldt.html", "dsk_dlibldt.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_dlibldt.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_dlibmdt.html", "dsk_dlibmdt.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_dlibmdt.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_dtaanldt.html", "dsk_dtaanldt.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_dtaanldt.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_dtapmdt.html", "dsk_dtapmdt.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_dtapmdt.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_ecc.html", "dsk_ecc.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_ecc.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_em.html", "dsk_em.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_em.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_evolve.html", "dsk_evolve.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_evolve.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_get_ap.html", "dsk_get_ap.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_get_ap.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_get_dapdt.html", "dsk_get_dapdt.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_get_dapdt.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_get_disk_points.html", "dsk_get_disk_points.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_get_disk_points.pro", "", "", "	Computes points on the inner and outer edges of a disk.    ", "", "          -1", " 	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ");
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_get_dlandt.html", "dsk_get_dlandt.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_get_dlandt.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_get_dlibdt_ap.html", "dsk_get_dlibdt_ap.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_get_dlibdt_ap.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_get_dlibdt_lan.html", "dsk_get_dlibdt_lan.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_get_dlibdt_lan.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_get_edge_elevation.html", "dsk_get_edge_elevation.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_get_edge_elevation.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_get_edge_elevation.html#dsk_get_edge_elevation", "dsk_get_edge_elevation", 'routine in <a href="obj/dsk/dsk_get_edge_elevation.html">dsk_get_edge_elevation.pro</a>', "dsk_get_edge_elevation.pro", "", "dsk_get_edge_elevation", "	Computes elevations along the edge of a disk.    ", "innerIf set, the inner edge is used.   outerIf set, the outer edge is used.   one_to_onenoeventdkd Array (nt) of any subclass of DISK.   ta Array (nta) of true anomalies at which to compute elevations.    ", "NV/LIB/DSK", " 	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   	Array (nt x nta) of elevations computed at each true anomaly on each 	disk.    STATUS: 	Complete    ");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_get_edge_radius.html", "dsk_get_edge_radius.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_get_edge_radius.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_get_edge_radius.html#dsk_get_edge_radius", "dsk_get_edge_radius", 'routine in <a href="obj/dsk/dsk_get_edge_radius.html">dsk_get_edge_radius.pro</a>', "dsk_get_edge_radius.pro", "", "dsk_get_edge_radius", "	Computes radii along the edge of a disk.    ", "innerIf set, the inner edge is used.   outerIf set, the outer edge is used.   timenoeventdkd Array (nt) of any subclass of DISK.   ta Array (nv x nt) of true anomalies at which to compute radii.   ", "NV/LIB/DSK", " 	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   	Array (nv x nt) of radii computed at each true anomaly on each 	disk.    STATUS: 	Complete    ");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_get_inc.html", "dsk_get_inc.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_get_inc.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_get_inner_disk_points.html", "dsk_get_inner_disk_points.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_get_inner_disk_points.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_get_inner_disk_points.html#dsk_get_inner_disk_points", "dsk_get_inner_disk_points", 'routine in <a href="obj/dsk/dsk_get_inner_disk_points.html">dsk_get_inner_disk_points.pro</a>', "dsk_get_inner_disk_points.pro", "", "dsk_get_inner_disk_points", "	Computes points on the inner edge of a disk.    ", "taTrue anomalies for the points.  Default is the full circle.   disk_ptsdkd Array (nt) of any subclass of DISK.   n_points", "NV/LIB/DSK", " 	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   	Array (np x 3 x nt) of points on the outer edge of each disk, 	in disk body coordinates.    STATUS: 	Complete    ");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_get_lan.html", "dsk_get_lan.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_get_lan.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_get_lib_ap.html", "dsk_get_lib_ap.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_get_lib_ap.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_get_lib_lan.html", "dsk_get_lib_lan.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_get_lib_lan.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_get_liba_ap.html", "dsk_get_liba_ap.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_get_liba_ap.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_get_liba_lan.html", "dsk_get_liba_lan.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_get_liba_lan.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_get_nl.html", "dsk_get_nl.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_get_nl.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_get_nm.html", "dsk_get_nm.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_get_nm.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_get_node.html", "dsk_get_node.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_get_node.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_get_outer_disk_points.html", "dsk_get_outer_disk_points.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_get_outer_disk_points.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_get_outer_disk_points.html#dsk_get_outer_disk_points", "dsk_get_outer_disk_points", 'routine in <a href="obj/dsk/dsk_get_outer_disk_points.html">dsk_get_outer_disk_points.pro</a>', "dsk_get_outer_disk_points.pro", "", "dsk_get_outer_disk_points", "	Computes points on the outer edge of a disk.    ", "taTrue anomalies for the points.  Default is the full circle.   disk_ptsdkd Array (nt) of any subclass of DISK.   n_points", "NV/LIB/DSK", " 	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   	Array (np x 3 x nt) of points on the outer edge of each disk, 	in disk body coordinates.    STATUS: 	Complete    ");
  
  

libdata[libdataItem++] = new Array("obj/tools/dsk_get_perp.html", "dsk_get_perp.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "dsk_get_perp.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_get_radius.html", "dsk_get_radius.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_get_radius.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_get_ranges.html", "dsk_get_ranges.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_get_ranges.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_hide_points.html", "dsk_hide_points.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_hide_points.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_il.html", "dsk_il.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_il.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/tools/dsk_image_bounds.html", "dsk_image_bounds.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "dsk_image_bounds.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/dsk_image_bounds.html#dsk_image_bounds", "dsk_image_bounds", 'routine in <a href="obj/tools/dsk_image_bounds.html">dsk_image_bounds.pro</a>', "dsk_image_bounds.pro", "", "dsk_image_bounds", "	Determines disk coordinate ranges visible in an image described 	by a given camera descriptor.    ", "slopborder_pts_imradminradmaxlonminlonmaxnpplanestatuscropcdCamera descripor.   dkxAny subclass of DISK.   ", "NV/LIB/TOOLS", "       Written by:     Spitale   	radmin:	Minimum disk radius in image.  	radmax:	Maximum disk radius in image.  	lonmin:	Minimum disk longitude in image.  	lonmax:	Maximum disk longitude in image.  	border_pts_im:	Array (2,np) of points along the edge of the image.  	status:	-1 if no disk in the image, 0 otherwise.    ");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_intersect.html", "dsk_intersect.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_intersect.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_intersect_inertial.html", "dsk_intersect_inertial.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_intersect_inertial.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_l.html", "dsk_l.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_l.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_libal.html", "dsk_libal.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_libal.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_libam.html", "dsk_libam.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_libam.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_libl.html", "dsk_libl.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_libl.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_libm.html", "dsk_libm.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_libm.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_m.html", "dsk_m.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_m.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_nl.html", "dsk_nl.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_nl.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_nm.html", "dsk_nm.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_nm.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/tools/dsk_projected_resolution.html", "dsk_projected_resolution.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "dsk_projected_resolution.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/dsk_projected_resolution.html#dsk_projected_resolution", "dsk_projected_resolution", 'routine in <a href="obj/tools/dsk_projected_resolution.html">dsk_projected_resolution.pro</a>', "dsk_projected_resolution.pro", "", "dsk_projected_resolution", "	Computes the resolution (actually scale) components at a point on a 	disk in a given camera.    ", "radlonperprrdkdcdCamera descriptor.   pPoint on the dkx in inertial coordinates.   scale", "NV/LIB/TOOLS", "       Written by:     Spitale, usning an approach suggested by M. Tiscareno   	Radial resolution on dkx at r, computed as the length of a 	segment bisecting the intersection ellipse in the radial direction.    ");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_query.html", "dsk_query.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_query.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_query.html#dsk_query", "dsk_query", 'routine in <a href="obj/dsk/dsk_query.html">dsk_query.pro</a>', "dsk_query.pro", "", "dsk_query", "	Returns the fields associated with a DISK object.  This is a 	convenient way of getting multiple fields in one call, and only a 	single event is generated.    ", "conditionStructure specifing a mask and a condition with which to 			match flag values.  The structure must contain the fields 			MASK and STATE.  MASK is a bitmask to test against 			the flags field of the POINT object, and STATE 			is either PS_TRUE and PS_FALSE.  Note that in this case, 			the values will be returned as a list, with no separation 			into nv and nt dimensions.   cat	If set, arrays from mulitple input objets are 			concatenated.  	<condition>:	All of the predefined conditions (e.g. /visible) are 			accepted; see pnt_condition_keywords.include.   noeventIf set, no event is generated.   xd@dsk__keywords_tree.include", "NV/OBJ/DSK", " 	Written by:	Spitale, 2/2017   ");
  
  

libdata[libdataItem++] = new Array("obj/tools/dsk_radial_resolution.html", "dsk_radial_resolution.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "dsk_radial_resolution.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_radial_scale.html", "dsk_radial_scale.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_radial_scale.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_reflect.html", "dsk_reflect.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_reflect.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_replicate.html", "dsk_replicate.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_replicate.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_set_ap.html", "dsk_set_ap.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_set_ap.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_set_dap.html", "dsk_set_dap.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_set_dap.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_set_dapdt.html", "dsk_set_dapdt.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_set_dapdt.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_set_dlandt.html", "dsk_set_dlandt.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_set_dlandt.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_set_dlibdt_ap.html", "dsk_set_dlibdt_ap.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_set_dlibdt_ap.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_set_dlibdt_lan.html", "dsk_set_dlibdt_lan.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_set_dlibdt_lan.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_set_dlibldt.html", "dsk_set_dlibldt.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_set_dlibldt.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_set_dlibmdt.html", "dsk_set_dlibmdt.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_set_dlibmdt.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_set_dtaanldt.html", "dsk_set_dtaanldt.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_set_dtaanldt.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_set_dtapmdt.html", "dsk_set_dtapmdt.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_set_dtapmdt.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_set_ecc.html", "dsk_set_ecc.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_set_ecc.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_set_em.html", "dsk_set_em.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_set_em.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_set_il.html", "dsk_set_il.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_set_il.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_set_inc.html", "dsk_set_inc.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_set_inc.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_set_l.html", "dsk_set_l.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_set_l.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_set_lan.html", "dsk_set_lan.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_set_lan.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_set_lib_ap.html", "dsk_set_lib_ap.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_set_lib_ap.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_set_lib_lan.html", "dsk_set_lib_lan.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_set_lib_lan.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_set_liba_ap.html", "dsk_set_liba_ap.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_set_liba_ap.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_set_liba_lan.html", "dsk_set_liba_lan.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_set_liba_lan.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_set_libal.html", "dsk_set_libal.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_set_libal.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_set_libam.html", "dsk_set_libam.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_set_libam.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_set_libl.html", "dsk_set_libl.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_set_libl.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_set_libm.html", "dsk_set_libm.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_set_libm.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_set_m.html", "dsk_set_m.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_set_m.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_set_nl.html", "dsk_set_nl.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_set_nl.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_set_nm.html", "dsk_set_nm.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_set_nm.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_set_phase_fn.html", "dsk_set_phase_fn.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_set_phase_fn.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_set_radial_scale.html", "dsk_set_radial_scale.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_set_radial_scale.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_set_refl_fn.html", "dsk_set_refl_fn.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_set_refl_fn.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_set_sma.html", "dsk_set_sma.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_set_sma.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_set_taanl.html", "dsk_set_taanl.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_set_taanl.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_set_tapm.html", "dsk_set_tapm.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_set_tapm.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_shape_radial.html", "dsk_shape_radial.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_shape_radial.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_shape_radial.html#dsk_shape_radial", "dsk_shape_radial", 'routine in <a href="obj/dsk/dsk_shape_radial.html">dsk_shape_radial.pro</a>', "dsk_shape_radial.pro", "", "dsk_shape_radial", "	Computes radii along the edge of a disk using disk elements.    ", "mmIf set, only the radius component for this wavenumber 		is returned.   miiIf set, only the radius component with this index 		is returned.   _a Array (nt) of semimajor axis values.   _e Array (nt) of eccentricity values.   _dap Array (nt) of apsidal shift values.   ta Array (nv x nt) of true anomalies at which to compute radii.   _m Array (nt x nm) of radial wavenumbers.   _em Array (nt x nm) of eccentricities for each m.   _tapm Array (nt x nm) of true anomalies of periapse for each m.    ", "NV/LIB/DSK", " 	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   	Array (nv x nt) of radii computed at each true anomaly on each 	disk.    STATUS: 	Complete    ");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_shape_vertical.html", "dsk_shape_vertical.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_shape_vertical.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_shape_vertical.html#dsk_shape_vertical", "dsk_shape_vertical", 'routine in <a href="obj/dsk/dsk_shape_vertical.html">dsk_shape_vertical.pro</a>', "dsk_shape_vertical.pro", "", "dsk_shape_vertical", "	Computes elevations along the edge of a disk using disk elements.    ", "dkdllIf set, only the elevation component for this wavenumber 		is returned.   liiIf set, only the elevation component with this index 		is returned.   a Array (nt) of semimajor axis values.   ta Array (nta) of true anomalies at which to compute elevations.   l Array (nt) of vertical wavenumbers.   il Array (nt) of inclinations for each l.   taanl Array (nt) of true anomalies of ascending node for each l.    ", "NV/LIB/DSK", " 	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   	Array (nt x nta) of elevations computed at each true anomaly on each 	disk.    STATUS: 	Complete    ");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_sma.html", "dsk_sma.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_sma.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_surface_normal.html", "dsk_surface_normal.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_surface_normal.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_taanl.html", "dsk_taanl.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_taanl.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_tapm.html", "dsk_tapm.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_tapm.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_valid_edges.html", "dsk_valid_edges.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_valid_edges.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/tools/icv/edge_model_atan.html", "edge_model_atan.pro", '.pro file in <a href="obj/tools/icv/dir-overview.html">obj/tools/icv/ directory</a>', "edge_model_atan.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/tools/icv/edge_model_gauss.html", "edge_model_gauss.pro", '.pro file in <a href="obj/tools/icv/dir-overview.html">obj/tools/icv/ directory</a>', "edge_model_gauss.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/tools/icv/edge_model_nav_limb.html", "edge_model_nav_limb.pro", '.pro file in <a href="obj/tools/icv/dir-overview.html">obj/tools/icv/ directory</a>', "edge_model_nav_limb.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/tools/icv/edge_model_nav_ring.html", "edge_model_nav_ring.pro", '.pro file in <a href="obj/tools/icv/dir-overview.html">obj/tools/icv/ directory</a>', "edge_model_nav_ring.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/tools/icv/edge_model_psf_ring.html", "edge_model_psf_ring.pro", '.pro file in <a href="obj/tools/icv/dir-overview.html">obj/tools/icv/ directory</a>', "edge_model_psf_ring.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/tools/footprint.html", "footprint.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "footprint.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/footprint.html#footprint", "footprint", 'routine in <a href="obj/tools/footprint.html">footprint.pro</a>', "footprint.pro", "", "footprint", "	Computes the footprint of a camera on a given body.    ", "slop	Number of pixels by which to expand the image in each 			direction.   cornersArray(2,2) giving corers of image region to consider.   hit_indicesArray (nhit) of bx indices.   image_ptsFootprint points in the image frame.   body_p	Array (nhit) of pointers to body footprint points for 			each body hit.   sample	Sampling rate; default is 1 pixel.    cd	Camera descripor.  Only one allowed.   bx	Body descriptors.   ", "NV/LIB/TOOLS", "       Written by:     Spitale		5/2014   	Array (nhit) of pointers to inertial footprint points for each body hit. 	Zero is returned if no bodies are hit.    ");
  
  

libdata[libdataItem++] = new Array("obj/tools/get_disk_ref.html", "get_disk_ref.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "get_disk_ref.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/tools/get_image_border_pts.html", "get_image_border_pts.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "get_image_border_pts.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/get_image_border_pts.html#get_image_border_pts", "get_image_border_pts", 'routine in <a href="obj/tools/get_image_border_pts.html">get_image_border_pts.pro</a>', "get_image_border_pts.pro", "", "get_image_border_pts", "	Computes points around the edge of an image.    ", "cornerscentercropsampleaperturecdCamera descripor.   ", "NV/LIB/TOOLS", "       Written by:     Spitale   	Array (2,np) of image points on the image border.  np is computed 	such that points are spaced by one pixel.    ");
  
  

libdata[libdataItem++] = new Array("obj/tools/get_image_profile.html", "get_image_profile.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "get_image_profile.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/get_image_profile.html#get_image_profile", "get_image_profile", 'routine in <a href="obj/tools/get_image_profile.html">get_image_profile.pro</a>', "get_image_profile.pro", "", "get_image_profile", "	Extracts a profile from a rectangular, but not necessarily axis-aligned, 	image region using interpolation.    ", "distanceArray (nl) giving the distance along the scan.   interp	Type of interpolation, see image_interp_cam.   arg_interpInterpolation argument, see image_interp_cam.   sigma	Standard deviation across the profile at each sample 			along the profile.    image_ptsArray (2,nl) of image points along the center of 			the scan.   imcdCamera descriptor.   pArray (2,2) of image points giving the start and end points 		for the scan.   nlNumber of samples along the scan.   nwNumber of samples across the scan.    sample", "NV/LIB/TOOLS", "       Written by:     Spitale   	Array (nl) containing the profile.    ");
  
  

libdata[libdataItem++] = new Array("obj/tools/get_image_profile_outline.html", "get_image_profile_outline.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "get_image_profile_outline.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/tools/get_image_vector.html", "get_image_vector.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "get_image_vector.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/tools/get_limb_profile_outline.html", "get_limb_profile_outline.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "get_limb_profile_outline.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/get_limb_profile_outline.html#get_limb_profile_outline", "get_limb_profile_outline", 'routine in <a href="obj/tools/get_limb_profile_outline.html">get_limb_profile_outline.pro</a>', "get_limb_profile_outline.pro", "", "get_limb_profile_outline", "       Generates an outline of a limb sector.   ", "altaznaltnazinertialInertial vectors corresponding to the limb sector 			outline points.   dkdDisk descriptor corresponding to the skyplane.    save_azsscan_altscan_azlimb_pts_bodygraphiccdCamera descriptor.   gbxGlobe descriptor.   pointsArray (2,2) of image points defining opposite corners 		of the sector.   ", "NV/LIB/TOOLS", "       Written by:     Spitale, 8/2006          Array of image points defining the outline of the sector.    ");
  
  

libdata[libdataItem++] = new Array("obj/tools/get_limb_profile_outline_linear.html", "get_limb_profile_outline_linear.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "get_limb_profile_outline_linear.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/get_limb_profile_outline_linear.html#get_limb_profile_outline_linear", "get_limb_profile_outline_linear", 'routine in <a href="obj/tools/get_limb_profile_outline_linear.html">get_limb_profile_outline_linear.pro</a>', "get_limb_profile_outline_linear.pro", "", "get_limb_profile_outline_linear", "       Generates an outline of a rectangular limb sector.   ", "altaz0rimpointsnaltnriminertialInertial vectors corresponding to the limb sector 			outline points.    save_rimsscan_altscan_rimlimb_pts_bodygraphiccdCamera descriptor.   gbxGlobe descriptor.   ", "NV/LIB/TOOLS", "       Written by:     Spitale, 1/2009          Array of image points defining the outline of the sector.    ");
  
  

libdata[libdataItem++] = new Array("obj/tools/get_limb_profile_outline_oblique.html", "get_limb_profile_outline_oblique.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "get_limb_profile_outline_oblique.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/get_limb_profile_outline_oblique.html#get_limb_profile_outline_oblique", "get_limb_profile_outline_oblique", 'routine in <a href="obj/tools/get_limb_profile_outline_oblique.html">get_limb_profile_outline_oblique.pro</a>', "get_limb_profile_outline_oblique.pro", "", "get_limb_profile_outline_oblique", "       Generates an outline of an oblique limb sector.   ", "naltnazdkdcdCamera descriptor.   gbxGlobe descriptor.   pointsArray (2,2) of image points defining opposite corners 		of the sector.   point   ", "NV/LIB/TOOLS", "       Written by:     Spitale, 1/2009          Array of image points defining the outline of the sector.    ");
  
  

libdata[libdataItem++] = new Array("obj/tools/get_object_by_name.html", "get_object_by_name.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "get_object_by_name.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/tools/get_primary.html", "get_primary.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "get_primary.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/tools/get_ring_profile.html", "get_ring_profile.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "get_ring_profile.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/get_ring_profile.html#get_ring_profile", "get_ring_profile", 'routine in <a href="obj/tools/get_ring_profile.html">get_ring_profile.pro</a>', "get_ring_profile.pro", "", "get_ring_profile", "       Generates a ring profile in radius or longitude.           The profile is calculated by applying a grid of (radius, longitude)        given by rad and lon on a ring sector, interpolating the dn in        the image, and averaging along a direction to give a radius profile,        or a longitudinal profile.   STATUS:        Completed.    ", "azimuthal     If set, a longitudinal scan is done instead.   interpim_ptsdxdsk_ptssigmawidthnnarg_interpimage     The image to scan   cd     Camera descriptor   dkd     Disk descriptor   lon_ptsrad_pts", "NV/LIB/TOOLS", "       Written by:     Haemmerle, 6/1998          An array of averaged dn values that match the given rad or        match the given lon if /azimuthal selected.    ");
  
  

libdata[libdataItem++] = new Array("obj/tools/get_ring_profile_bin.html", "get_ring_profile_bin.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "get_ring_profile_bin.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/get_ring_profile_bin.html#get_ring_profile_bin", "get_ring_profile_bin", 'routine in <a href="obj/tools/get_ring_profile_bin.html">get_ring_profile_bin.pro</a>', "get_ring_profile_bin.pro", "", "get_ring_profile_bin", "       Generates a ring profile in radius or longitude using binning.           A ring sector polygon is calculated from the given dlon and rad        arrays.  All the pixels of the image within this polygon are        binned in an equally-spaced histogram in radius or longitude.          The dlon and rad arrays are treated as equally spaced, that is,        the binsize is calculated by dividing the spacing in radius by        number of points minus one.   STATUS:        Completed.    ", "slopeazimuthal     If set, a longitudinal scan is done instead.   image     The image to scan   cd     Camera descriptor   dkd     Disk descriptor   lon_ptsrad_pts", "NV/LIB/TOOLS", "       Written by:     Haemmerle, 6/1998          An array of averaged dn values that match the given rad or        match the given dlon if /azimuthal selected.    ");
  
  

libdata[libdataItem++] = new Array("obj/tools/get_ring_profile_n.html", "get_ring_profile_n.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "get_ring_profile_n.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/get_ring_profile_n.html#get_ring_profile_n", "get_ring_profile_n", 'routine in <a href="obj/tools/get_ring_profile_n.html">get_ring_profile_n.pro</a>', "get_ring_profile_n.pro", "", "get_ring_profile_n", "       Calculate the number of points in radius and longitude for        a ring profile.           Routine goes along the radial and longitudinal edges of a ring        profile sector and calculates the minimum spacing between the        points in image space, then derives the n_rad and n_lon points        to make the minimum spacing 1 pixel.  If the oversamp parameter        is given, the numbers are multiplied by this factor.   STATUS:        Completed.    ", "oversamp   Oversample factor compared to regular calculation of                        radius and longitude spacing which would put maximum                        spacing at 1 pixel.   outline_pts   Outline sector image points which are the result                        of calling get_ring_profile_outline()   cd   Camera descriptor   dkd   Disk descriptor   lon   Equally spaced longitude array   rad   Equally spaced radius array   ", "NV/LIB/TOOLS", "       Written by:     Haemmerle, 6/1998          Array containg n_rad and n_lon to be used by get_ring_profile() or        get_ring_profile_bin().    ");
  
  

libdata[libdataItem++] = new Array("obj/tools/get_ring_profile_outline.html", "get_ring_profile_outline.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "get_ring_profile_outline.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/get_ring_profile_outline.html#get_ring_profile_outline", "get_ring_profile_outline", 'routine in <a href="obj/tools/get_ring_profile_outline.html">get_ring_profile_outline.pro</a>', "get_ring_profile_outline.pro", "", "get_ring_profile_outline", "       Generates an outline of a ring sector.   ", "radArray of disk radii for sector   lonArray of disk longitudes for sector   xlondirnradNumber of points in the radial direction.   nlonNumber of points in the longitudinal direction.   slopeinertialInertial vectors corresponding to the ring sector 			outline points.    cdCamera descriptor.   dkdpointsArray (2,2) of image points defining corners of the sector.   ", "NV/LIB/TOOLS", "       Written by:     Vance Haemmerle & Joe Spitale, 6/1998          Output is set of image points (x,y) defining the outline of the        ring sector.   ");
  
  

libdata[libdataItem++] = new Array("obj/tools/get_ring_profile_outline_oblique.html", "get_ring_profile_outline_oblique.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "get_ring_profile_outline_oblique.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/get_ring_profile_outline_oblique.html#get_ring_profile_outline_oblique", "get_ring_profile_outline_oblique", 'routine in <a href="obj/tools/get_ring_profile_outline_oblique.html">get_ring_profile_outline_oblique.pro</a>', "get_ring_profile_outline_oblique.pro", "", "get_ring_profile_outline_oblique", "       Generates an outline of an oblique ring sector.   ", "dirnradNumber of points in the radial direction.   nlonNumber of points in the longitudinal direction.   cdCamera descriptor.   dkxpointsArray (2,2) of image points defining corners at opposite ends 		on one side of the sector.   pointImage point defining and third corner.   ", "NV/LIB/TOOLS", "       Written by:     Spitale, 8/2006          Array of image points defining the outline of the sector.    ");
  
  

libdata[libdataItem++] = new Array("obj/tools/get_ring_profile_outline_perp.html", "get_ring_profile_outline_perp.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "get_ring_profile_outline_perp.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/get_ring_profile_outline_perp.html#get_ring_profile_outline_perp", "get_ring_profile_outline_perp", 'routine in <a href="obj/tools/get_ring_profile_outline_perp.html">get_ring_profile_outline_perp.pro</a>', "get_ring_profile_outline_perp.pro", "", "get_ring_profile_outline_perp", "       Generates an outline of a ring sector perpendicular to the 	image-projected radial direction.   ", "dirnradNumber of points in the radial direction.   nlonNumber of points in the longitudinal direction.   cdCamera descriptor.   dkxpointsArray (2,2) of image points defining corners of the sector.   ", "NV/LIB/TOOLS", "       Written by:     Spitale, 8/2006          Array of image points defining the outline of the sector.    ");
  
  

libdata[libdataItem++] = new Array("obj/tools/get_solar_ref.html", "get_solar_ref.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "get_solar_ref.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/tools/composite/get_surface_ranges.html", "get_surface_ranges.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "get_surface_ranges.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/glb/glb_altaz_to_local.html", "glb_altaz_to_local.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "glb_altaz_to_local.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/glb/glb_assign.html", "glb_assign.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "glb_assign.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/glb/glb_assign.html#glb_assign", "glb_assign", 'routine in <a href="obj/glb/glb_assign.html">glb_assign.pro</a>', "glb_assign.pro", "", "glb_assign", "	Replaces fields in a GLOBE object.  This is a convenient way of 	setting multiple fields in one call, and only a single event is 	generated.    ", "noeventIf set, no event is generated.   xd@glb__keywords_tree.include", "NV/OBJ/GLB", " 	Written by:	Spitale		2/2017   ");
  
  

libdata[libdataItem++] = new Array("obj/glb/glb_body_to_globe.html", "glb_body_to_globe.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "glb_body_to_globe.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/glb/glb_body_to_local.html", "glb_body_to_local.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "glb_body_to_local.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/glb/glb_create_descriptors.html", "glb_create_descriptors.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "glb_create_descriptors.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/glb/glb_create_descriptors.html#glb_create_descriptors", "glb_create_descriptors", 'routine in <a href="obj/glb/glb_create_descriptors.html">glb_create_descriptors.pro</a>', "glb_create_descriptors.pro", "", "glb_create_descriptors", "	Init method for the GLOBE class.    ", "crdbdsldgbdnNumber of descriptors to create.   @glb__keywords_tree.include", "NV/LIB/GLB", " 	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   	Newly created or or freshly initialized globe descriptors, depending 	on the presence of the bd keyword.    STATUS: 	Complete    ");
  
  

libdata[libdataItem++] = new Array("obj/glb/glb_evolve.html", "glb_evolve.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "glb_evolve.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/glb/glb_get_cusp_points.html", "glb_get_cusp_points.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "glb_get_cusp_points.pro", "", "", "	Iteratively computes the two points that occupy the limb from two 	different viewpoints for each given globe object.    ", "", "          -1", " 	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ");
  

libdata[libdataItem++] = new Array("obj/glb/glb_get_limb_points.html", "glb_get_limb_points.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "glb_get_limb_points.pro", "", "", "	Iteratively computes the points on the limb for each given globe 	object.    ", "", "          -1", " 	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ");
  

libdata[libdataItem++] = new Array("obj/glb/glb_get_radius.html", "glb_get_radius.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "glb_get_radius.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/glb/glb_get_ranges.html", "glb_get_ranges.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "glb_get_ranges.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/glb/glb_get_surface_normal.html", "glb_get_surface_normal.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "glb_get_surface_normal.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/glb/glb_get_surface_normal.html#glb_get_surface_normal", "glb_get_surface_normal", 'routine in <a href="obj/glb/glb_get_surface_normal.html">glb_get_surface_normal.pro</a>', "glb_get_surface_normal.pro", "", "glb_get_surface_normal", "	Computes the surface normal of a GLOBE object at the given 	globe position.   ", "noeventnonormIf set, the returned vectors are not normalized.   bodyIf set, the inputs given in the BODY system instead of GLOBE.   gbdArray (nt) of any subclass of GLOBE descriptors.   globe_pts", "NV/LIB/GLB", " 	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   	Array (nv, 3, nt) of surface normals in the BODY frame.    STATUS: 	Complete    ");
  
  

libdata[libdataItem++] = new Array("obj/glb/glb_globe_to_body.html", "glb_globe_to_body.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "glb_globe_to_body.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/glb/glb_globe_to_graphic.html", "glb_globe_to_graphic.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "glb_globe_to_graphic.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/glb/glb_graphic_to_globe.html", "glb_graphic_to_globe.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "glb_graphic_to_globe.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/glb/glb_hide_points.html", "glb_hide_points.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "glb_hide_points.pro", "", "", "	Identifies points that are obscured by a GLOBE with respect to a given 	viewpoint.    ", "", "          -1", " 	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ");
  

libdata[libdataItem++] = new Array("obj/glb/glb_hide_points_limb.html", "glb_hide_points_limb.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "glb_hide_points_limb.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/tools/glb_image_bounds.html", "glb_image_bounds.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "glb_image_bounds.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/glb_image_bounds.html#glb_image_bounds", "glb_image_bounds", 'routine in <a href="obj/tools/glb_image_bounds.html">glb_image_bounds.pro</a>', "glb_image_bounds.pro", "", "glb_image_bounds", "	Determines globe coordinate ranges visible in an image described 	by a given camera descriptor.    ", "slopborder_pts_imcornerscenterlatminlatmaxlonminlonmaxstatuscdCamera descripor.   pd", "NV/LIB/TOOLS", "       Written by:     Spitale   	latmin:	Minimum latitude in image.  	latmax:	Maximum latitude in image.  	lonmin:	Minimum longitude in image.  	lonmax:	Maximum longitude in image.  	border_pts_im:	Array (2,np) of points along the edge of the image.  	status:	-1 if no globe in the image, 0 otherwise.    ");
  
  

libdata[libdataItem++] = new Array("obj/glb/glb_intersect.html", "glb_intersect.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "glb_intersect.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/glb/glb_intersect.html#glb_intersect", "glb_intersect", 'routine in <a href="obj/glb/glb_intersect.html">glb_intersect.pro</a>', "glb_intersect.pro", "", "glb_intersect", "	Computes the intersection of rays with GLOBE objects.    ", "hitArray giving the indices of rays that hit the object.   missArray giving the indices of rays that miss the object.   nearIf set, only the  near  points are returned.  More specifically, 		these points correspond to the nearest along the ray from the 		observer to the globe.  If the observer is exterior, these are 		the nearest interesections to the observer; if the observer is 		interior, these intersections are behind the observer.   farIf set, only the  far  points are returned.  See above; if the 		observer is exterior, these are the furthest interesections from 		the observer; if the observer is interior, these intersections 		are in front of the observer.   discriminantDiscriminant of the quadriatic equation used to 			determine the intersections.    nosolveIf set, the intersections are not computed, though the 		 discrimiant is.   validArray in which each element indicates whether the object 		was hit.   gbd	Array (nt) of any subclass of GLOBE descriptors.   view_ptsArray (nv,3,nt) giving ray origins in the BODY frame.   ray_ptsArray (nv,3,nt) giving ray directions in the BODY frame.    ", "NV/LIB/GLB", " 	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   	Array (2*nv,3,nt) of points in the BODY frame, where 	int_pts[0:nv-1,*,*] correspond to the near-side intersections 	and int_pts[nv:2*nv-1,*,1] correspond to the far side.  Zero 	vector is returned for points with no solution.    STATUS: 	Complete    ");
  
  

libdata[libdataItem++] = new Array("obj/glb/glb_intersect_plane.html", "glb_intersect_plane.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "glb_intersect_plane.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/glb/glb_j.html", "glb_j.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "glb_j.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/glb/glb_local_to_altaz.html", "glb_local_to_altaz.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "glb_local_to_altaz.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/glb/glb_local_to_body.html", "glb_local_to_body.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "glb_local_to_body.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/glb/glb_lora.html", "glb_lora.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "glb_lora.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/glb/glb_lref.html", "glb_lref.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "glb_lref.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/glb/glb_model.html", "glb_model.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "glb_model.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/glb/glb_nj.html", "glb_nj.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "glb_nj.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/glb/glb_query.html", "glb_query.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "glb_query.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/glb/glb_query.html#glb_query", "glb_query", 'routine in <a href="obj/glb/glb_query.html">glb_query.pro</a>', "glb_query.pro", "", "glb_query", "	Returns the fields associated with a GLOBE object.  This is a 	convenient way of getting multiple fields in one call, and only a 	single event is generated.    ", "conditionStructure specifing a mask and a condition with which to 			match flag values.  The structure must contain the fields 			MASK and STATE.  MASK is a bitmask to test against 			the flags field of the POINT object, and STATE 			is either PS_TRUE and PS_FALSE.  Note that in this case, 			the values will be returned as a list, with no separation 			into nv and nt dimensions.   cat	If set, arrays from mulitple input objets are 			concatenated.  	<condition>:	All of the predefined conditions (e.g. /visible) are 			accepted; see pnt_condition_keywords.include.   noeventIf set, no event is generated.   xd@glb__keywords_tree.include", "NV/OBJ/GLB", " 	Written by:	Spitale, 2/2017   ");
  
  

libdata[libdataItem++] = new Array("obj/glb/glb_radii.html", "glb_radii.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "glb_radii.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/glb/glb_reflect.html", "glb_reflect.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "glb_reflect.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/glb/glb_reflect.html#glb_reflect", "glb_reflect", 'routine in <a href="obj/glb/glb_reflect.html">glb_reflect.pro</a>', "glb_reflect.pro", "", "glb_reflect", "	Computes the reflection of rays with GLOBE objects.    ", "hitmissnearIf set, near-side reflections are computed.  This is the default.   far	If set, far-side reflections are computed.   allvalidgbdArray (nt) of any subclass of GLOBE descriptors.   vArray (nv,3,nt) giving observer positions in the BODY frame.   rArray (nv,3,nt) giving point positions in the BODY frame.   epsilonControls the precision of the iteration.  Default 			is 1d-3.   niterMaximum number of iterations, default is 1000    ", "NV/LIB/GLB", " 	Written by:	Spitale, 6/2016   	Array (2*nv,3,nt) of points in the BODY frame, where 	int_pts[0:nv-1,*,*] correspond to the near-side reflections 	and int_pts[nv:2*nv-1,*,1] correspond to the far side.  Zero 	vector is returned for points with no solution.    STATUS: 	Not well tested    ");
  
  

libdata[libdataItem++] = new Array("obj/glb/glb_replicate.html", "glb_replicate.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "glb_replicate.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/glb/glb_rref.html", "glb_rref.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "glb_rref.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/glb/glb_set_j.html", "glb_set_j.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "glb_set_j.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/glb/glb_set_lora.html", "glb_set_lora.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "glb_set_lora.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/glb/glb_set_lref.html", "glb_set_lref.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "glb_set_lref.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/glb/glb_set_model.html", "glb_set_model.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "glb_set_model.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/glb/glb_set_radii.html", "glb_set_radii.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "glb_set_radii.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/glb/glb_set_rref.html", "glb_set_rref.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "glb_set_rref.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/glb/glb_sub_point.html", "glb_sub_point.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "glb_sub_point.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/glb/glb_sub_point_graphic.html", "glb_sub_point_graphic.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "glb_sub_point_graphic.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/tools/composite/globe_to_image.html", "globe_to_image.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "globe_to_image.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/tools/composite/globe_to_map.html", "globe_to_map.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "globe_to_map.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("grim/tools/gr_colortool.html", "gr_colortool.pro", '.pro file in <a href="grim/tools/dir-overview.html">grim/tools/ directory</a>', "gr_colortool.pro", "", "", "	Tool for adjusting colors in GRIM.    ", "", "          -1", " 	Written by:	Spitale   ");
  

libdata[libdataItem++] = new Array("grim/tools/gr_lsqtool.html", "gr_lsqtool.pro", '.pro file in <a href="grim/tools/dir-overview.html">grim/tools/ directory</a>', "gr_lsqtool.pro", "", "", "", "", "          -1", " 	Written by:	Spitale 7/2002   ");
  

libdata[libdataItem++] = new Array("grim/tools/gr_maptool.html", "gr_maptool.pro", '.pro file in <a href="grim/tools/dir-overview.html">grim/tools/ directory</a>', "gr_maptool.pro", "", "", "", "", "          -1", " 	Written by:	Spitale 7/2002   ");
  

libdata[libdataItem++] = new Array("grim/tools/gr_phttool.html", "gr_phttool.pro", '.pro file in <a href="grim/tools/dir-overview.html">grim/tools/ directory</a>', "gr_phttool.pro", "", "", "", "", "          -1", " 	Written by:	Spitale 7/2002   ");
  

libdata[libdataItem++] = new Array("grim/interface/graft.html", "graft.pro", '.pro file in <a href="grim/interface/dir-overview.html">grim/interface/ directory</a>', "graft.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("grim/interface/graft.html#graft", "graft", 'routine in <a href="grim/interface/graft.html">graft.pro</a>', "graft.pro", "", "graft", "	Grafts POINT arrays into GRIM.    ", "psym Plotting symbol.     symsizePlotting symbol size.   color Plotting color.   tag If given, the array is added as user data with this tag name.   pn Plane number to access.  If not given, then current plane 		 is used.   grn ID of GRIM instance to use.  If not given, then current one 		 is used.   argPOINT object or array of image points.   ", "NV/GR", " 	Written by:	Spitale   	(1) Open a GRIM window, load an image, and compute planet centers.  	(2) At the command line, type:  		IDL> grift, gd=gd 		IDL> limb_ptd = pg_limb(gd=gd, gbx=gd.pd) 		IDL> graft, limb_ptd  	GRIM should plot the new overlay.    SEE ALSO: 	grim, grift ");
  
  

libdata[libdataItem++] = new Array("grim/interface/grift.html", "grift.pro", '.pro file in <a href="grim/interface/dir-overview.html">grim/interface/ directory</a>', "grift.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("grim/interface/grift.html#grift", "grift", 'routine in <a href="grim/interface/grift.html">grift.pro</a>', "grift.pro", "", "grift", "	External access to GRIM data.  Purloins object and array references 	from GRIM so that they may be manipulated on the command line or by an 	external agent.  The returned descriptors allow direct access to the 	memory images of GRIM's objects, so any changes made affect the 	objects that GRIM is using.  GRIM monitors those objects and updates 	itself whenever a change occurs.    ", "planeGrim plane structure(s) instead of giving pn.  Note all planes 		must belong to the same grim instance.   pnPlane number(s) to access.  If not given, then current plane 		is used.   allIf set, all planes are used.   activeIf set, only active memebrs of the selected objects are 		returned.   grngdGeneric descriptor containing all of GRIM's descriptors. 		For multiple planes, a list is returned with each element 		corresponding to a plane.  	<xd>:	Any descriptor maintained by GRIM.  	<xdx>:	Returnds all descriptors containing the given class, e.g., 		bx, gbx, dkx.   Not implemented.  	<overlay>_ptd: 		POINT object giving the points for the overlay of type <overlay>.   ddcdpdrdsdstdardltdodbxbbxdkxlimb_ptdring_ptdstar_ptdstation_ptdarray_ptdterm_ptdplgrid_ptdcenter_ptdshadow_ptdreflection_ptdobject_ptd 		POINT object giving all overlay points.   tie_ptd 		POINT object giving the tie points.  For multiple planes, a 		list is returned with each element corresponding to a plane.   curve_ptd 		POINT object giving the curve points.  For multiple planes, a 		list is returned with each element corresponding to a plane.    _ref_extraargGRIM window number or GRIM data struture.  If not given, the 		most recently accessed grim instance is used.   ", "NV/GR", " 	Written by:	Spitale, 7/2002   	(1) Open a GRIM window, load an image, and compute limb points.  	(2) At the command line, type:  		IDL> grift, cd=cd 		IDL> pg_repoint, [50,50], 0d, cd=cd  	GRIM should detect the change to the camera descriptor and update 	itself by recomputing the limb points and refreshing the display.    SEE ALSO: 	grim, graft ");
  
  

libdata[libdataItem++] = new Array("grim/grim.html", "grim.pro", '.pro file in <a href="grim/dir-overview.html">grim/ directory</a>', "grim.pro", "", "", " GRIM        General-purpose GRaphical Interface for oMinas   CATEGORY: NV/GR   CALLING SEQUENCE: <span class= code-output >          grim, arg1, arg2</span>    ARGUMENTS:    INPUT:        arg1, arg2:              Grim accepts up to two arguments, which can appear in either             order.  Possible arguments are:                    data descriptors (object)                   file specification (string)                   grn (scalar)                   plot (1d array)                   image (2d array)                   cube (3d array)        Plots are displayed as graphs whose abscissa are the array index, unless       an abscissa is present in the data descriptor.  Many functions are not       available in this mode.        Cubes are handled as multiple image planes unless /rgb is used       (see below).  All grim planes will contain the same data array,       but display only data ranges corresponding to one channel of the cube.       For /rgb (assuming the cube has three channels), the data are placed       on a single image plane with each cube channel assigned the R, G, or B       color channel.    OUTPUT:        None    KEYWORDS:     INPUT:        Descriptor Keywords        The following inputs replace objects already maintained by GRIM.  They       must be given as either a single element, which is applied to the       current plane, or as an array with one element for each plane.        cd:  Replaces the current camera descriptor.  This may also be               a map descriptor, in which case some of GRIM's functions              will not be available.  When using a map descriptor instead              of a camera descriptor, you can specify a camera descriptor              as the observer descriptor (see the 'od' keyword below) and              some additional geometry functions will be available.        od:  Replaces the current observer descriptor.  The observer              descriptor is used to allow some geometry objects (limb,              terminator) to be computed when using a map descriptor instead              of a camera descriptor.        The following inputs replace or augment objects already maintained       by GRIM.  They are sorted into their respective planes by comparing       their internal generic descriptors with the data descriptor or       observer descriptor (in the case of a map) for each plane.  Objects       whose names match those already maintained by GRIM replace them.        ltd: Replaces the current light descriptor.        pd:   Adds/replaces planet descriptors.        rd:   Adds/replaces ring descriptors.        sd:   Adds/replaces star descriptors.        std:  Adds/replaces station descriptors        ard:  Adds/replaces array descriptors        gd:   Generic descriptor containing some or all of the above               descriptors.    assoc_xd:    If given, use these descriptors to sort descriptors into    planes instead of matching the data descriptors or observer    descriptors in their internal generic descriptors.        Descriptor Select Keywords        Descriptor select keywords (see pg_get_*) are specified using the       standard prefix corresponding to the descriptor type.  For example,       the fov keyword to pg_get_planets would be given to grim as plt_fov.        Initial Colormap Keywords        The colormap structure (see colormap_descriptor__define) can be       be initialized via keywords prefied with 'cmd_', e.g., 'cmd_shade'.       In addition, the following keywords apply to the initial color map:        *auto_stretch:             If set, the color table for each plane is automatically             stretched.  This is identical to using the 'Auto' button             on on the grim color tool.        Translator Keywords        The following keywords are passed directly to the translators, which       are responsible for interpreting their meanings.        *cam_trs: String giving translator keywords for the camera descriptors.        *lgt_trs: String giving translator keywords for the light descriptors.        *plt_trs: String giving translator keywords for the planet descriptors.        *rng_trs: String giving translator keywords for the ring descriptors.        *str_trs: String giving translator keywords for the star descriptors.        *stn_trs: String giving translator keywords for the stations descriptors.        *arr_trs: String giving translator keywords for the array descriptors.        TVIM Keywords        The following keywords set the initial viewing parameters and are       simply passed to TVIM.        *xsize:  Size of the graphics window in the x direction.        *ysize:  Size of the graphics window in the y direction.        *zoom:   Initial zoom to be applied to the image.  If not given, grim                  computes an initial zoom such that the entire image fits on the                  screen.        *rotate: Initial rotate value to be applied to the image (as in the IDL                  ROTATE routine).  If not given, 0 is assumed.        *order:  Initial display order to be applied to the image.        *offset: Initial offset (dx,dy) to be applied to the image.        doffset: Change the offset viewing parameter by this amount.        default: If set, use default tvim properties (zoom=[1,1], offset=[0,0]                  order=0 [bottom-up])        previous: If set, restore last-used tvim viewing parameters.        restore: If set, use saved tvim viewing paramters.        Customization Keywords        *menu_extensions:             Array of strings giving the names of functions that return             menu definitions, as defined by cw_pdmenu.  These menus are             added to the built-in GRIM menus between the Overlays menu             and the Help menu.  The default is 'grim_default_menus'.  If             the first character in the first menu function is '+', then             grim_default_menus is retained an the new menu are appended             after that menu.  Otherwise, 'grim_default_menus' is replaced.        *button_extensions:             Array of strings giving the names of definition functions             for custom cursor modes to be added after the built-in             cursor modes.  The definition function takes one argument             (see arg_extensions below) and returns a grim_user_mode_struct.        *arg_extensions:             Argument to be provided to the button extension definition             function above.        *menu_fname:             Name of a file containing additional menus to add to             the grim widget.  The file syntax follows that for cw_pdmenu.        Other Keywords        *extensions:                String array giving extensions to try for each input file.                see dat_read.        *new:  If set, a new grim instance is created and all keywords apply                to that instance.        erase: If set, erase the current image before doing anything else.        *mode_init:                Initial cursor mode.  See below.        *mode_args:                Array giving arguments for the cursor modes initialization                functions.  If a string, then syntax is NAME:ARG, where NAME                is the name of the cursor mode, and ARG is the argument for                that mode.  For example: <span class= code-output >  mode_args='READOUT:myreadout_fn'</span>                would cause the function 'myreadout_fn' to be added to                the list of functions called by pg_cursor and pg_measure                via the readout cursor mode.  If not a string, the argument                is passed to the initialization function with no processing.        *retain:                Retain settings for backing store (see  backing store  in                the IDL reference guide).  Defaults to 2.        *clip: Controls the number of fields of view in which overlays are                computed.        *fov:  Controls the number of fields of view in which to request                planet, ring and star descriptors.  Values are as follows:                     0 : get all descriptors                   &lt;0 : relative to viewport                   &gt;0 : relative to image / optic axis                 Note that fov &gt; 0 is the same as setting the fov descriptor                select keywords (see above).  Default is 0, but stars operate                best when fov &gt; 0.        *hide: If set, overlays are hidden w.r.t shadows and obstructions.                Default is on.        no_erase:                If set, GRIM does not erase the draw windoww.        no_refresh:                If set, grim does not refresh.        *rgb:  If set, grim interprets a 3-plane cube as a 3-channel image                to be displayed on a single plane.        *channel:                Array of bitmasks specifying the color channel in which to                display each given image: 1b, 2b, or 4b.        *visibility:                Initial visibility setting for planes:                    0: Only the current plane is drawn.                   1: All planes are drawn.                 Default is 0.        *max:  Maximum data value to scale to when displaying images.                Values larger than this are set to the maximum color table                index.  If not set, the maximum value in the data set is used.                In cases where the data array is being subsampled, this value                may not be known, resulting in varying image scaling as more                and more data values are sampled.  That problem may be                eliminated via this keyword.        exit:  If set, GRIM immediately exits.  This can be used to kill an                existing GRIM window.        modal: If set, grim is run as a modal widget, i.e., there is no command                prompt.        *frame:If set, the initial view is set such that all members of the                named overlay types are are visible.  If /frame, then all                overlays are framed.  Note that object types that rely on the                view to determine which objects to compute (e.g., stars)                cannot be framed in this way.        refresh_callbacks:                Array of strings giving the names of procedures to be                called after each refresh.  See CALLBACK PROCEDURES                below.  Refresh callbacks receive only the data argument.        refresh_callback_data_ps:                Array of pointers (one per callback) to data for the refresh                callback procedures specified using the refresh_callbacks                keyword.  See CALLBACK PROCEDURES below.        plane_callbacks:                Array of strings giving the names of procedures to be                called after each plane change.  See CALLBACK PROCEDURES                below.  Plane callbacks receive only the data argument.        plane_callback_data_ps:                Array of pointers (one per callback) to data for the plane                callback procedures specified using the plane_callbacks                keyword.  See CALLBACK PROCEDURES below.        *nhist:History setting to be applied to data decriptor (see                ominas_data__define).  GRIM uses data descriptor history to                undo changes to the data array.  If nhist is not set, or is                equal to 1, the undo menu option will not function.        *maintain:                If given, this maintainance setting is applied to the data                descriptor (see ominas_data__define).        *compress:                Compression setting to be applied to data decriptor (see                ominas_data__define).        *filter:                Initial filter to use when loading or browsing files.        *load_path:                Initial path for the file loading dialog.        *save_path:                Initial path for the file saving dialog.        *path:  Sets both load_path and save_path to this value.        *workdir:                Default directory for saving user points, masks, tie                points, curves        user_psym:                Default plotting symbol for user overlays.        grn:   Identifies a specific GRIM window by number.  Grim numbers are                displayed in the status bar, e.g.: grim &lt;grn&gt;.        pn:    Directs GRIM to change to the plane corresponding to this plane                number.        *cursor_swap:                If set, cursor bitmaps are byte-order swapped.        *loadct:                Index of color table to load.        *beta: If set beta features are enabled.        *npoints:                Number of point to compute for various overlays.  Default is 1000.        *plane_syncing:                Turns plane syncing on (1) or off(0).  Default is 0.        *tiepoint_syncing:                Turns tiepoint syncing on (1) or off(0).  Default is 0.        *curve_syncing:                Turns curve syncing on (1) or off(0).  Default is 0.        position:                Sets the plot position; see the POSITION grahics keyword.        color: Sets the line color index for plots.  One element per plane.        xrange:Sets the X-axis range for plots.        yrange:Sets the Y-axis range for plots.        thick: Sets the line thickness for plots.  One element per plane.        title: For plots, sets the plot title for plots; one element per plane.                For images, sets the base default title.        xtitle:Sets the X-axis label for plots.  One element per plane.        ytitle:Sets the Y-axis label for plots.  One element per plane.        psym:  Sets the plotting symbol for plots.  One element per plane.        nsum:  See OPLOT.  One element per plane.        *lights:                List of bodies to use as light sources.  Default is 'SUN'.        *overlays:                List of initial overlays to compute on startup.  Each element                is of the form: <span class= code-output >          type[:name1,name2,...]</span>                where 'type' is one of {limb, terminator, center,                star, ring, planet_grid, array, station} and the names                identify the name of the desired object.  Note that grim                will load more objects than named if required by another                startup overlay.  For example: <span class= code-output >        overlays='ring:a_ring'</span>                will cause only one ring descriptor to load, whereas: <span class= code-output >        overlays=['limb:saturn', 'ring:a_ring']</span>                will cause all of Saturn's rings to load because they are                required in computing the limb points (for hiding).                 Different results may be obtained using translator keywords,                because those keywords are evaluated at the translator level.                For example: <span class= code-output >        overlays='ring:fn54'</span>                may result in no ring, while: <span class= code-output >        overlays='ring', trs_rd='name=fn54'</span>                would be more likely to yield a ring.  In the former example,                the specified name is compared against whatever default ring                descriptors are returned by the tranlators, while in the latter                case, the 'name' translator keyword is compared against all                rings available to the translator.        *delay_overlays:                If set, initial overlays (see 'overlays' above) are not computed                until the first time they are accessed.  This option can greatly                improve performance in cases where a large number of image planes                are loaded with initial overlays, particularly if it is not                expected that all planes will necesarily be viewed or otherwise                accessed.  Typically this option will cause overlays to be                computed only for the initially visible planes, with other                planes loading overlays only as they are made visible.  However,                there may be other cirumstances that can cause initial overlays                to be loaded without actually viewing a plane.        *activate:                If set, inital overlay are activated.        *ndd:  Sets the global ndd value in the OMINAS sate structure, which                controls the maximum number of data descriptors with maintain == 1                to keep in memory at any given time        *render_sample:                Over-sampling value for rendering.  See PG_RENDER.        *render_pht_min:                Minimum value to assign to photometric output in renderings.                See pg_render.        *rendering:                If set, perform a rendering on the initial descriptor set. 		(not yet implemented)    OUTPUT:        None        Resource File         The keywords marked above with an asterisk may be overridden using        the file $HOME/.ominas/grimrc.  Keyword=value pairs may be entered, one per        line, using the same syntax as if the keyword were entered on the IDL        command line to invoke grim.  Lines beginning with '#' are ignored.        Keywords entered in the resource file override the default values, and        are themselves overridden by keywords entered on the command line.        Shell Interface         The grim alias may be used to start grim from the shell prompt        via the XIDL interface.  The shell interface accepts all keywords        marked above with an asterisk.  See grim.bat.         Example (assuming the grim alias described in grim.bat): <span class= code-output >    % grim -beta data/*.img overlay=center,limb:JUPITER</span>         Grim currently defines no environment variables..        Environment Variables        Common Blocks          grim_block:          Keeps track of most recent grim instance and which ones are          selected.        Side Effects         Grim operates directly on the memory images of the descriptors that        it is given.  Therefore, those descriptors are modified during        a session.  This architecture allows data to be operated on concurrently        through grim and from the command line; see grift.pro for details.        Layout         The philosphy that drives GRIM's layout is that the maximum possible        screen space should be devoted to displaying the data.  This policy        allows for many GRIM windows to be used simultaneously without being        obscured by crazy control panels full of buttons, gadgets, widgets,        doodads, whirly-gigs, and what-nots.  The grim layout consists of the        following items:              Title bar                 The title bar displays the grim window number (grn),                the current plane number (pn), the total number of planes, the                name field of the data descriptor for the current plane, the                default title (if given; see the title keyword above), and                a string indicating which RGB channels are associated with the                current plane.              Menu bar                 Most of grim's functionality is accessed through the                system of pulldown menus at the top.  Individual menu                items are described in their own sections.              Shortcut buttons                 Some commonly used menu options are duplicated as shortcut                buttons arranged horizontally just beneath the menu bar.  The                function of each button is displayed in the status bar (see                below) when the mouse cursor is hovered ove the button.        Cursor mode buttons                 Cursor mode shortcut buttons are arranged vertically along the                left side of the GRIM window, and as provided as shortcuts                for the corresponding options in the Mode menu.  The following                modes are available:                    Activate:                        In activate mode, overlay objects may be activated                        or deactivated by clicking and/or dragging using the                        left or right mouse buttons respectively.  This                        activation mechanism allows the user to select which                        among a certain type of objects should be used in a                        given menu selection.  A left click on an overlay                        activates that overlay and a right click deactivates                        it.  A double click activates or deactivates all                        overlays associated with a given descriptor, or all                        stars.  Active overlays appear in the colors selected                        in the 'Overlay Settings' menu selection.  Inactive                        overlays appear in cyan.  A descriptor is active                        whenever any of its overlays are active.                    Zoom:The zoom button puts grim in a zoom cursor mode, wherein                        the image zoom and offset are controlled by selecting                        a box in the image.  When the box is created using the                        left mouse button, zoom and offset are changed so that                        the contents of the box best fill the current graphics                        window.  When the right button is used, the contents of                        the current graphics window are shrunken so as to best                        fill the box.  In other words, the left button zooms in                        and the right button zooms out.                    Pan: The pan button puts grim in a pan cursor mode, wherein the                        image offset is controlled by selecting an offset vector                        using the left mouse button.  The middle button may be                        used to center the image on a selected point.                    Pixel Readout:                        In pixel readout mode, a text window appears                        and displays data about the pixel selected                        using the left mouse button.                    Tiepoint:                        In tiepoint mode, tiepoints are added using the                        left mouse button and deleted using the right button.                        Tiepoints appear as crosses identified by numbers.                        The use of tiepoints is determined by the particular                        option selected by the user.                    Curve:                        In curve mode, curves are added using the                        left mouse button and deleted using the right button.                        Curves appear as red lines identified by numbers at                        each end.  The use of curves is determined by the                        particular option selected by the user.                    Mask:GRIM maintains a mask for each plane whose use is                        appication-dependent.  Mask mode allows pixels in the                        mask to be toggled on and off.                    Magnify:                        In magnify mode, image pixels in the graphics                        window may be magnifed using either the right or left                        mouse buttons.  The left button magnifies the displayed                        pixels, directly from the graphics window.  The right                        button magnifies the data itself, without the overlays.                    XY Zoom:                        Same as 'zoom' above, except the aspect ratio is                        set by the proportions of the selected box.                    Remove overlays:                        Allows the user to remove overlay arrays.                    Trim overlays:                        Allows the user to trim points from overlay arrays.                    Select within overlays:                        Allows the user to select points within overlay arrays.                    Define Region:                        Allows the user to define GRIM's region of interest.                    Smooth:                        Allows the user to select a smoothing box to be applied                        to the data array.                    Select Plane:                        Allows the user to change planes using the pointer.                        This option is only useful in cases where multiple                        planes are displayed.                    Drag Image:                        Allows the user to reposition the current plane by                        clicking and dragging.                    Navigate:                        Allows the user to modify the camera position and                        orientation usng the mouse.              Graphics window                 The graphics window displays the data associated with the                given data descriptor using the current zoom, offset, and                display order.  The edges of an image are indicated by a dotted                line.  The camera optic axis is indicated by a large red cross.              Pixel readout                 The cursor position and corresponding data value are are                displayed beneath the graphics window, next to the message line.              Message line                 The message line displays short messages pertaining GRIM's                 current state, or displayng button functions.        Callback Procedures         GRIM callback procedures are called with one or two arguments:        the first argument is a pointer to data that was provided        when the callback was added.  The second argument, if present, depends        on the applicatation.        Resource Names         The following X-windows resource names apply to grim:          grim_base:   top level base         grim_mbar:   menu bar         grim_shortcuts_base: base containing shortcut buttons         grim_modes_base: base containing modes buttons         grim_draw:   grim draw widget         grim_label:    grim bottom label widget         To turn off the confusing higlight box around the modes buttons,        put the following line in your ~/.Xdefaults file: <span class= code-output >    Idl*grim_modes_base*highlightThickness:  0</span>         GRIM displays 1-, 2-, and 3-dimensional data sets.  1-dimensional        data arrays are displayed as plots.  In that case, the abscissa is        the sample number unless the data descriptor contains an abscissa.        2- and 3-dimensional arrays are displaye as image planes.  The only        difference between images and cubes in GRIM is that images planes        each have their own data descriptor, while cubes are represented by        multiple image planes that share a common data descriptor; each plane        in a cube corresponds to a unique offset in the data array stored in        the common data descriptor.  Some functionality is not available when        working with plots.  In that case, those options do not appear in the        menus.        Operation         GRIM requests only the data samples needed for the current viewing        parameters.  Therefore, GRIM can display data sets of arbitrary size        when used with a file reader that supports subsampling.  However, note        that specific menu options may request the entire data array, depending        on the application.         Each GRIM window may contain any number of planes as well as        associated geometric data (i.e. object descriptors) and overlay arrays        for displaying various geometric objects -- limbs, rings, stars, etc.        An array of user overlay points is maintained to be used for application-        specific purposes.  Generally, a set of overlay points or a descriptor        must be activated in order to be used as input to a menu item; see        activate mode above.         There are exclusive and non-exclusive mechanisms for selecting grim        windows.  Grim windows may be non-exclusively selected using the select        mode button mentioned above (upper-left corner).  The exclusive        selection mechanism consists of a  primary  GRIM window, indicated by        a red outline in the graphics window.  The primary selection is        changed by pressing any mode or shortcut button, or by clicking in        the graphics area of the desired grim window.  The meaning of the        various selections depends on the application.         The functions of the left and right mouse buttons are determined by the        cursor mode; some cursor modes define modifier keys to broaden the number        of functions available in that mode.  The middle mouse button toggles        the activation state of overlay arrays, or pans the image if no overlay        appears beneath the cursor.  The mouse wheel cycles among cursor modes,        or zooms about the cursor position if the control key is held down.         Objects maintained by GRIM are accessible via the grift interface,        for example:     <span class= code-prompt >IDL&gt;</span> grift, dd=dd, cd=cd, pd=pd, limb_ptd=limb_ptd        returns the data desciptor, camera descriptor, planet descriptors,        and limb points associated with the current plane.         GRIM registers event handlers for all of its objects, so the window        is updated any time an object is modifed, whether by GRIM or by some        other program, or from the command line.   ", "", "          -1", "   Written by: Spitale 7/2002               (1) To create a new grim instance with no data:      <span class= code-prompt >IDL&gt;</span> grim, /new             (2) To create a new grim instance with data from a file of name                  filename :  <span class= code-prompt >IDL&gt;</span> dd = dat_read(filename)  <span class= code-prompt >IDL&gt;</span> grim, dd  <span class= code-output >       or:</span>                   IDL&gt; grim, filename              (3) To give an existing grim instance a new camera descriptor:      <span class= code-prompt >IDL&gt;</span> grim, cd=cd         Window resizing is not precise.  GRIM tries to resize to the selected        size, but typically overshoots.  This is probably platform-dependent.        Known bugs         Objects inherited by rendering planes do not respond to events.         Image shifting:         -  Descriptors not updated if shift performed form another window            because the there's no way for the irst window to know to            update its descriptors               - fix wrap-around; clip instead         Plane-&gt;Coregister does not update descriptors         Navigate mode gets weird when you do certain modifer key presses           --&gt; maybe a conflict with &lt;ctrl&gt; wheel zoom action         Crashes occur with File-&gt;Close         /no_erase is not enabled for images, just plots.  Probably should fix        that.         Initial visibility setting does not seem to work until applied        using plane settings window.         /frame causes a crash if there are no initial overlays.         It's not clear whether the symsize keyword is actually used.         pn keyword does not function.         Crash when tiepoint syncing is on and tiepoint selected with        multiple planes.         Title keyword does not properly map multiple elements to multiple        planes.         Nsum keyword does not properly map multiple elements to multiple        planes.         Plane syncing appears to be incomplete and I don't remember what it        was supposed to be.  I'm sure it was awesome, though.         Not sure what slave_overlays keyword does, or was supposed to do.         Overlays on rendered planes do not respond to events         Menu toggles don't update propoerly in some circumsumstances.         grim_message sometimes pops up messages from nv_message, which can        be pretty obnxious.  This probably has to do with the calls to        grim_message in grim_compute.include         Overlay point selections are not retained after recomputing         Undo does not seem to be working reliably         Events on overlays copied to rendering planes do not function         The help menu is currently not working because it relied on the old        documentation system.         Navigation mode control is poor for the Shift-Right motion        SEE ALSO         GRIFT, GRAFT   ");
  

libdata[libdataItem++] = new Array("grim/grim_default_menus.html", "grim_default_menus.pro", '.pro file in <a href="grim/dir-overview.html">grim/ directory</a>', "grim_default_menus.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("grim/grim_mode_activate.html", "grim_mode_activate.pro", '.pro file in <a href="grim/dir-overview.html">grim/ directory</a>', "grim_mode_activate.pro", "", "", "	Selects the activate cursor mode.    ", "", "          -1", " 	Written by:	Spitale, 7/2002   ");
  

libdata[libdataItem++] = new Array("grim/grim_mode_curves.html", "grim_mode_curves.pro", '.pro file in <a href="grim/dir-overview.html">grim/ directory</a>', "grim_mode_curves.pro", "", "", "	Selects the curves cursor mode.    ", "", "          -1", " 	Written by:	Spitale, 10/2012   ");
  

libdata[libdataItem++] = new Array("grim/grim_mode_drag.html", "grim_mode_drag.pro", '.pro file in <a href="grim/dir-overview.html">grim/ directory</a>', "grim_mode_drag.pro", "", "", "	Selects the drag cursor mode.    ", "", "          -1", " 	Written by:	Spitale, 2/2009   ");
  

libdata[libdataItem++] = new Array("grim/grim_mode_magnify.html", "grim_mode_magnify.pro", '.pro file in <a href="grim/dir-overview.html">grim/ directory</a>', "grim_mode_magnify.pro", "", "", "	Selects the magnify cursor mode.    ", "", "          -1", " 	Written by:	Spitale, 7/2002   ");
  

libdata[libdataItem++] = new Array("grim/grim_mode_mask.html", "grim_mode_mask.pro", '.pro file in <a href="grim/dir-overview.html">grim/ directory</a>', "grim_mode_mask.pro", "", "", "	Selects the mask cursor mode.    ", "", "          -1", " 	Written by:	Spitale, 8/2013   ");
  

libdata[libdataItem++] = new Array("grim/grim_mode_navigate.html", "grim_mode_navigate.pro", '.pro file in <a href="grim/dir-overview.html">grim/ directory</a>', "grim_mode_navigate.pro", "", "", "	Selects the navigate cursor mode.  	 Camera orientation: 	   Left button:		Allows the optic axis to be repointed.  	   Right button:	Allows the camera to twist about an axis 				corresponding to the selected pixel location.  	 Camera position: 	   <Shift> Left:	Allows the camera to be repositioned in the 				X-Z plane (image plane).  Speeds depend on 				the object under the cursor.  	   <Shift> Right:	Allows the camera to be repositioned and 				reoriented simultaneosly by tracking the 				object under the cursor.  	   <Shift> Wheel:	Allows the camera to be repositioned in the 				Y (optic axis) direction.  Speeds depend on 				the object under the cursor.    ", "", "          -1", " 	Written by:	Spitale, 2/2009   ");
  

libdata[libdataItem++] = new Array("grim/grim_mode_pan.html", "grim_mode_pan.pro", '.pro file in <a href="grim/dir-overview.html">grim/ directory</a>', "grim_mode_pan.pro", "", "", "	Selects the pan cursor mode.    ", "", "          -1", " 	Written by:	Spitale, 7/2002   ");
  

libdata[libdataItem++] = new Array("grim/grim_mode_pan_plot.html", "grim_mode_pan_plot.pro", '.pro file in <a href="grim/dir-overview.html">grim/ directory</a>', "grim_mode_pan_plot.pro", "", "", "	Selects the pan cursor mode.    ", "", "          -1", " 	Written by:	Spitale, 7/2002   ");
  

libdata[libdataItem++] = new Array("grim/grim_mode_plane.html", "grim_mode_plane.pro", '.pro file in <a href="grim/dir-overview.html">grim/ directory</a>', "grim_mode_plane.pro", "", "", "	Selects the plane cursor mode.    ", "", "          -1", " 	Written by:	Spitale, 8/2008   ");
  

libdata[libdataItem++] = new Array("grim/grim_mode_readout.html", "grim_mode_readout.pro", '.pro file in <a href="grim/dir-overview.html">grim/ directory</a>', "grim_mode_readout.pro", "", "", "	Selects the readout cursor mode.    ", "", "          -1", " 	Written by:	Spitale, 7/2002   ");
  

libdata[libdataItem++] = new Array("grim/grim_mode_region.html", "grim_mode_region.pro", '.pro file in <a href="grim/dir-overview.html">grim/ directory</a>', "grim_mode_region.pro", "", "", "	Selects the 'region' cursor mode.    ", "", "          -1", " 	Written by:	Spitale, 2/2014   ");
  

libdata[libdataItem++] = new Array("grim/grim_mode_remove.html", "grim_mode_remove.pro", '.pro file in <a href="grim/dir-overview.html">grim/ directory</a>', "grim_mode_remove.pro", "", "", "	Selects the remove cursor mode.    ", "", "          -1", " 	Written by:	Spitale, 8/2006   ");
  

libdata[libdataItem++] = new Array("grim/grim_mode_select.html", "grim_mode_select.pro", '.pro file in <a href="grim/dir-overview.html">grim/ directory</a>', "grim_mode_select.pro", "", "", "	Selects the 'select' cursor mode.    ", "", "          -1", " 	Written by:	Spitale, 2/2014   ");
  

libdata[libdataItem++] = new Array("grim/grim_mode_smooth.html", "grim_mode_smooth.pro", '.pro file in <a href="grim/dir-overview.html">grim/ directory</a>', "grim_mode_smooth.pro", "", "", "	Selects the smooth cursor mode.    ", "", "          -1", " 	Written by:	Spitale, 10/2006   ");
  

libdata[libdataItem++] = new Array("grim/grim_mode_tiepoints.html", "grim_mode_tiepoints.pro", '.pro file in <a href="grim/dir-overview.html">grim/ directory</a>', "grim_mode_tiepoints.pro", "", "", "	Selects the tiepoints cursor mode.    ", "", "          -1", " 	Written by:	Spitale, 7/2002   ");
  

libdata[libdataItem++] = new Array("grim/grim_mode_trim.html", "grim_mode_trim.pro", '.pro file in <a href="grim/dir-overview.html">grim/ directory</a>', "grim_mode_trim.pro", "", "", "	Selects the trim cursor mode.    ", "", "          -1", " 	Written by:	Spitale, 8/2006   ");
  

libdata[libdataItem++] = new Array("grim/grim_mode_xyzoom.html", "grim_mode_xyzoom.pro", '.pro file in <a href="grim/dir-overview.html">grim/ directory</a>', "grim_mode_xyzoom.pro", "", "", "	Selects the xy-zoom cursor mode.    ", "", "          -1", " 	Written by:	Spitale, 5/2005   ");
  

libdata[libdataItem++] = new Array("grim/grim_mode_zoom.html", "grim_mode_zoom.pro", '.pro file in <a href="grim/dir-overview.html">grim/ directory</a>', "grim_mode_zoom.pro", "", "", "	Selects the zoom cursor mode.    ", "", "          -1", " 	Written by:	Spitale, 7/2002   ");
  

libdata[libdataItem++] = new Array("grim/grim_mode_zoom_plot.html", "grim_mode_zoom_plot.pro", '.pro file in <a href="grim/dir-overview.html">grim/ directory</a>', "grim_mode_zoom_plot.pro", "", "", "	Selects the zoom cursor mode.    ", "", "          -1", " 	Written by:	Spitale, 7/2002   ");
  

libdata[libdataItem++] = new Array("obj/tools/composite/hide_points.html", "hide_points.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "hide_points.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/tools/icv/icv_chisq.html", "icv_chisq.pro", '.pro file in <a href="obj/tools/icv/dir-overview.html">obj/tools/icv/ directory</a>', "icv_chisq.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/icv/icv_chisq.html#icv_chisq", "icv_chisq", 'routine in <a href="obj/tools/icv/icv_chisq.html">icv_chisq.pro</a>', "icv_chisq.pro", "", "icv_chisq", "	Computes chi-squared value for given curve fit parameters.    ", "norm	If set, the returned value is normalized by dividing 			it by the number of degrees of freedom.   dxy	Array (2) giving x- and y-offset solution.   dtheta	Scalar giving theta-offset solution.   fix	Array specifying which parameters to fix as 			[dx,dy,dtheta].   cos_alphaArray (n_points) of direction cosines computed by 			icv_compute_directions.   sin_alphaArray (n_points) of direction sines computed by 			icv_compute_directions.   scan_offsetsArray (n_points) containing offset of best correlation 			at each point on the curve.  Produced by icv_scan_strip.   scan_ptsArray (2, n_points) of image coordinates corresponding 			to each scan offset.   axis	Array (2) giving image coordinates of rotation axis 			in the case of a 3-parameter fit.   ", "NV/LIB/TOOLS/ICV", " 	Written by:	Spitale, 6/1998   	The chi-squared value is returned.    STATUS: 	Complete.    ");
  
  

libdata[libdataItem++] = new Array("obj/tools/icv/icv_coeff.html", "icv_coeff.pro", '.pro file in <a href="obj/tools/icv/dir-overview.html">obj/tools/icv/ directory</a>', "icv_coeff.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/icv/icv_coeff.html#icv_coeff", "icv_coeff", 'routine in <a href="obj/tools/icv/icv_coeff.html">icv_coeff.pro</a>', "icv_coeff.pro", "", "icv_coeff", "	Computes coefficients for the 2- or 3-parameter linear least-square fit.    	Since the fit has been linearized, it can be written as a matrix 	equation:  				Mx = b,  	where x is the 3-element column vector [dx, dy, dtheta] of the 	independent variables. 	This routine computes the matrix M and the 	vector b.  Once these are known, mbfit can be used to solve the 	linear system.  Moreover, since the fit is linear, a simultaneous 	fit can be performed by simply adding together any number of 	coefficient matrices and vectors, which can also be done using 	mbfit.    	The fit associated with these coefficients has been linearized 	and is only valid for small corrections.  For larger corrections, 	this procedure can be iterated.    STATUS: 	Complete.    ", "sigmaUncertainty in each scan_offset.  Defaults to 1.   M3x3 matrix of coefficients for the linear fit.   b3-element column vector rhs of the linear fit.    _cos_alphaArray (n_points) of direction cosines computed by 			icv_compute_directions.   _sin_alphaArray (n_points) of direction sines computed by 			icv_compute_directions.   scan_offsetsArray (n_points) containing offset of best correlation 			at each point on the curve.  Produced by icv_scan_strip.   scan_ptsArray (2, n_points) of image coordinates corresponding 			to each scan offset.   axis	Array (2) giving image coordinates of rotation axis 			in the case of a 3-parameter fit.   ", "NV/LIB/TOOLS/ICV", " 	Written by:	Spitale, 2/1998   ");
  
  

libdata[libdataItem++] = new Array("obj/tools/icv/icv_compute_directions.html", "icv_compute_directions.pro", '.pro file in <a href="obj/tools/icv/dir-overview.html">obj/tools/icv/ directory</a>', "icv_compute_directions.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/icv/icv_compute_directions.html#icv_compute_directions", "icv_compute_directions", 'routine in <a href="obj/tools/icv/icv_compute_directions.html">icv_compute_directions.pro</a>', "icv_compute_directions.pro", "", "icv_compute_directions", "	Computes the normal to a specified curve at every point.    	It is assumed that the curve is closed; if this is not the case, then 	the results will not be meaningful at the endpoints of the curve.    	At each point on the specified curve, the two nearest neighbors are 	used to compute the components of the normal.    STATUS: 	Complete    ", "centercos_alphasin_alphacurve_ptsArray (2, n_points) of image points making up the curve.   ", "NV/LIB/TOOLS/ICV", " 	Written by:	Spitale, 2/1998   	NONE    ");
  
  

libdata[libdataItem++] = new Array("obj/tools/icv/icv_convert_scan_offsets.html", "icv_convert_scan_offsets.pro", '.pro file in <a href="obj/tools/icv/dir-overview.html">obj/tools/icv/ directory</a>', "icv_convert_scan_offsets.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/icv/icv_convert_scan_offsets.html#icv_convert_scan_offsets", "icv_convert_scan_offsets", 'routine in <a href="obj/tools/icv/icv_convert_scan_offsets.html">icv_convert_scan_offsets.pro</a>', "icv_convert_scan_offsets.pro", "", "icv_convert_scan_offsets", "	Converts offsets produced by icv_scan_strip to image coordinates.    ", "curve_ptsArray (2, n_points) of image points making up the curve.   scan_offsetsArray (n_points) containing offset of best correlation 			at each point on the curve.  Produced by icv_scan_strip.   cos_alphaArray (n_points) of direction cosines computed by 			icv_compute_directions.   sin_alphaArray (n_points) of direction sines computed by 			icv_compute_directions.   ", "NV/LIB/TOOLS/ICV", " 	Written by:	Spitale, 2/1998   	Array (2, n_points) of image coordinates corresponding to each scan 	offset.    STATUS: 	Complete.    ");
  
  

libdata[libdataItem++] = new Array("obj/tools/icv/icv_invert_scan_offsets.html", "icv_invert_scan_offsets.pro", '.pro file in <a href="obj/tools/icv/dir-overview.html">obj/tools/icv/ directory</a>', "icv_invert_scan_offsets.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/tools/icv/icv_reset_scan_precision.html", "icv_reset_scan_precision.pro", '.pro file in <a href="obj/tools/icv/dir-overview.html">obj/tools/icv/ directory</a>', "icv_reset_scan_precision.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/tools/icv/icv_scan_strip.html", "icv_scan_strip.pro", '.pro file in <a href="obj/tools/icv/dir-overview.html">obj/tools/icv/ directory</a>', "icv_scan_strip.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/icv/icv_scan_strip.html#icv_scan_strip", "icv_scan_strip", 'routine in <a href="obj/tools/icv/icv_scan_strip.html">icv_scan_strip.pro</a>', "icv_scan_strip.pro", "", "icv_scan_strip", "	At each point along an image strip, determines the point at which 	some criterion is optimized, depending on an externally-supplied 	function.    	This program is a wrapper for a number of functions that use various 	algorithms determined by the 'algorithm' keyword.    STATUS: 	Complete.    ", "ccsigmaalgorithmargstripImage strip (n_points,ns) to be scanned.  Output from 		icv_strip_curve ns must be even.   modelModel (n_points,nm) to correlate with strip at each point 		on the curve.  Must have nm < ns.   szeroZero-offset position in the strip.   mzeroZero-offset position in the model.   ", "NV/LIB/TOOLS/ICV", " 	Written by:	Spitale, 2/1998   	Offset of best correlation at each point on the curve.    ");
  
  

libdata[libdataItem++] = new Array("obj/tools/icv/icv_scan_strip_grad.html", "icv_scan_strip_grad.pro", '.pro file in <a href="obj/tools/icv/dir-overview.html">obj/tools/icv/ directory</a>', "icv_scan_strip_grad.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/icv/icv_scan_strip_grad.html#icv_scan_strip_grad", "icv_scan_strip_grad", 'routine in <a href="obj/tools/icv/icv_scan_strip_grad.html">icv_scan_strip_grad.pro</a>', "icv_scan_strip_grad.pro", "", "icv_scan_strip_grad", "	At each point along an image strip, finds a sharp edge using the 	maximum-gradient method.    ", "argccNot used, hardwired to 0.9999999d.   sigmaOffset uncertainty for each point on the curve, computed as 		one half of the half-width of the gradient peak.    normIf set, only the absolute value of the gradient is evaluated.   stripImage strip (n_points,ns) to be scanned.  Output from 		icv_strip_curve ns must be even.   modelNot used.   szeroZero-offset position in the strip.   mzeroNot used.   ", "NV/LIB/TOOLS/ICV", " 	Written by:	Spitale   	Offset of maximum gradient points at each point on the curve.    STATUS: 	Complete.    ");
  
  

libdata[libdataItem++] = new Array("obj/tools/icv/icv_scan_strip_grad_norm.html", "icv_scan_strip_grad_norm.pro", '.pro file in <a href="obj/tools/icv/dir-overview.html">obj/tools/icv/ directory</a>', "icv_scan_strip_grad_norm.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/icv/icv_scan_strip_grad_norm.html#icv_scan_strip_grad_norm", "icv_scan_strip_grad_norm", 'routine in <a href="obj/tools/icv/icv_scan_strip_grad_norm.html">icv_scan_strip_grad_norm.pro</a>', "icv_scan_strip_grad_norm.pro", "", "icv_scan_strip_grad_norm", "	Calls icv_scan_strip_grad with /norm set.    ", "argccsigmastripImage strip (n_points,ns) to be scanned.  Output from 		icv_strip_curve ns must be even.   modelNot used.   szeroZero-offset position in the strip.   mzeroNot used.   ", "NV/LIB/TOOLS/ICV", " 	Written by:	Spitale   	Offset of maximum gradient points at each point on the curve.    STATUS: 	Complete.    ");
  
  

libdata[libdataItem++] = new Array("obj/tools/icv/icv_scan_strip_half.html", "icv_scan_strip_half.pro", '.pro file in <a href="obj/tools/icv/dir-overview.html">obj/tools/icv/ directory</a>', "icv_scan_strip_half.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/icv/icv_scan_strip_half.html#icv_scan_strip_half", "icv_scan_strip_half", 'routine in <a href="obj/tools/icv/icv_scan_strip_half.html">icv_scan_strip_half.pro</a>', "icv_scan_strip_half.pro", "", "icv_scan_strip_half", "	At each point along an image strip, finds a sharp edge using the 	half-power method.    ", "argccsigmacenterstripImage strip (n_points,ns) to be scanned.  Output from 		icv_strip_curve ns must be even.   modelNot used.   szeroZero-offset position in the strip.   mzeroNot used.   ", "NV/LIB/TOOLS/ICV", " 	Written by:	Spitale   	Offset of half-power points at each point on the curve.    STATUS: 	Complete.    ");
  
  

libdata[libdataItem++] = new Array("obj/tools/icv/icv_scan_strip_model.html", "icv_scan_strip_model.pro", '.pro file in <a href="obj/tools/icv/dir-overview.html">obj/tools/icv/ directory</a>', "icv_scan_strip_model.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/icv/icv_scan_strip_model.html#icv_scan_strip_model", "icv_scan_strip_model", 'routine in <a href="obj/tools/icv/icv_scan_strip_model.html">icv_scan_strip_model.pro</a>', "icv_scan_strip_model.pro", "", "icv_scan_strip_model", "	At each point along an image strip, determines the subpixel offset at 	which the correlation coefficient between a specified model and the 	image is maximum.    	At every point on the curve, a correlation coefficient is computed 	for every offset at which the model completely overlays the strip. 	In other words, the model is swept across the strip.  	At each point, Lagrange interpolation is used on the three correlations 	surrounding the correlation peak to find the subpixel offset of maximum 	correlation.    STATUS: 	Complete.    ", "argccsigmacenterstripImage strip (n_points,ns) to be scanned.  Output from 		icv_strip_curve ns must be even.   modelModel (n_points,nm) to correlate with strip at each point 		on the curve.  Must have nm < ns.   szeroZero-offset position in the strip.   mzeroZero-offset position in the model.   ", "NV/LIB/TOOLS/ICV", " 	Written by:	Spitale, 2/1998   	Offset of best correlation at each point on the curve.    ");
  
  

libdata[libdataItem++] = new Array("obj/tools/icv/icv_strip_curve.html", "icv_strip_curve.pro", '.pro file in <a href="obj/tools/icv/dir-overview.html">obj/tools/icv/ directory</a>', "icv_strip_curve.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/icv/icv_strip_curve.html#icv_strip_curve", "icv_strip_curve", 'routine in <a href="obj/tools/icv/icv_strip_curve.html">icv_strip_curve.pro</a>', "icv_strip_curve.pro", "", "icv_strip_curve", "	Using Lagrange interpolation, extracts an image strip of a specified 	width centered on the specified curve.    ", "zerogrid_xgrid_ycd	Camera descriptor.   image	Image from which to extract the strip.   curve_ptsArray (2, n_points) of image points making up the curve.   width	Width of the strip in pixels.   nD	Number of samples across the width of the strip.   cos_alphaArray (n_points) of direction cosines computed by 			icv_compute_directions.   sin_alphaArray (n_points) of direction sines computed by 			icv_compute_directions.   ", "NV/LIB/TOOLS/ICV", " 	Written by:	Spitale, 2/1998   	Image strip (n_points, nD).    STATUS: 	Complete    ");
  
  

libdata[libdataItem++] = new Array("obj/tools/illumination_fraction.html", "illumination_fraction.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "illumination_fraction.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/tools/image_ansa.html", "image_ansa.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "image_ansa.pro", "", "", "	Computes ring ansa true anomalies.    ", "", "          -1", "       Written by:     Spitale   ");
  

libdata[libdataItem++] = new Array("obj/tools/image_ansa_far.html", "image_ansa_far.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "image_ansa_far.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/tools/image_azimuth.html", "image_azimuth.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "image_azimuth.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/tools/image_azimuth_pos.html", "image_azimuth_pos.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "image_azimuth_pos.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/tools/image_celestial_northangle.html", "image_celestial_northangle.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "image_celestial_northangle.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/tools/image_interp_cam.html", "image_interp_cam.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "image_interp_cam.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/image_interp_cam.html#image_interp_cam", "image_interp_cam", 'routine in <a href="obj/tools/image_interp_cam.html">image_interp_cam.pro</a>', "image_interp_cam.pro", "", "image_interp_cam", "       Extracts a region from an image using the desired interpolation, 	accouting for the camera point-spread function is applicable.    ", "cdvalidkinterpkmaxmaskzmaskimageAn array of image point arrays.   grid_xThe grid of x positions for interpolation   grid_yThe grid of y positions for interpolation   argsArguments to pass to the interpolation function.   ", "NV/LIB/TOOLS", "       Written by:     Spitale          Array of interpolated points at the (grid_x, grid_y) points.     ");
  
  

libdata[libdataItem++] = new Array("obj/tools/image_northangle.html", "image_northangle.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "image_northangle.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/tools/composite/image_origin.html", "image_origin.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "image_origin.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/tools/image_shift.html", "image_shift.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "image_shift.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/tools/composite/image_size.html", "image_size.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "image_size.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/tools/composite/image_to_body.html", "image_to_body.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "image_to_body.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/tools/composite/image_to_disk.html", "image_to_disk.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "image_to_disk.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/tools/composite/image_to_globe.html", "image_to_globe.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "image_to_globe.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/composite/image_to_globe.html#image_to_globe", "image_to_globe", 'routine in <a href="obj/tools/composite/image_to_globe.html">image_to_globe.pro</a>', "image_to_globe.pro", "", "image_to_globe", "       Transforms points in image coordinates to body globe coordinates    ", "body_ptsdiscriminantvalidcd      Array of nt camera or map descriptors.   gbx     Array of nt object descriptors (of type GLOBE).   p       Array (2 x nv x nt) of image points.   ", "NV/LIB/TOOLS/COMPOSITE", "       Array (nv x 3 x nt) of globe positions.   STATUS:        Completed.    ");
  
  

libdata[libdataItem++] = new Array("obj/tools/composite/image_to_inertial.html", "image_to_inertial.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "image_to_inertial.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/tools/composite/image_to_map.html", "image_to_map.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "image_to_map.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/tools/composite/image_to_orbit.html", "image_to_orbit.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "image_to_orbit.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/tools/composite/image_to_radec.html", "image_to_radec.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "image_to_radec.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/tools/composite/image_to_surface.html", "image_to_surface.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "image_to_surface.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/composite/image_to_surface.html#image_to_surface", "image_to_surface", 'routine in <a href="obj/tools/composite/image_to_surface.html">image_to_surface.pro</a>', "image_to_surface.pro", "", "image_to_surface", "       Transforms points in image coordinates to surface coordinates.    ", "body_ptsdiscriminanthitvalidcd     Array of nt camera or map descriptor   bx     Array of nt object descriptors (subclass of BODY).   p      Array (2 x nv x nt) of image points.   ", "NV/LIB/TOOLS/COMPOSITE", "       Array (nv x 3 x nt) of surface points.  In the case of a camera descriptor, ray 	tracing is used.   STATUS:        Completed.    ");
  
  

libdata[libdataItem++] = new Array("obj/tools/impact_param.html", "impact_param.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "impact_param.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/tools/in_image.html", "in_image.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "in_image.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/in_image.html#in_image", "in_image", 'routine in <a href="obj/tools/in_image.html">in_image.pro</a>', "in_image.pro", "", "in_image", "	Determines which input points lie within an image described by the 	given camera descriptor.    ", "xminxmaxyminymaxslopcornerscdCamera descriptor.   _image_pts", "NV/LIB/TOOLS", "       Written by:     Spitale          Subscripts of points that lie in the image.  -1 if there are none.     ");
  
  

libdata[libdataItem++] = new Array("obj/tools/composite/inertial_to_disk.html", "inertial_to_disk.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "inertial_to_disk.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/tools/composite/inertial_to_disk_pos.html", "inertial_to_disk_pos.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "inertial_to_disk_pos.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/tools/composite/inertial_to_globe.html", "inertial_to_globe.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "inertial_to_globe.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/tools/composite/inertial_to_globe_pos.html", "inertial_to_globe_pos.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "inertial_to_globe_pos.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/tools/composite/inertial_to_image.html", "inertial_to_image.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "inertial_to_image.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/tools/composite/inertial_to_image_pos.html", "inertial_to_image_pos.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "inertial_to_image_pos.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/tools/ipt/ipt_chisq.html", "ipt_chisq.pro", '.pro file in <a href="obj/tools/ipt/dir-overview.html">obj/tools/ipt/ directory</a>', "ipt_chisq.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/tools/ipt/ipt_coeff.html", "ipt_coeff.pro", '.pro file in <a href="obj/tools/ipt/dir-overview.html">obj/tools/ipt/ directory</a>', "ipt_coeff.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dat/keyval_struct__define.html", "keyval_struct__define.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "keyval_struct__define.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/tools/ltcorr.html", "ltcorr.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "ltcorr.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/map/map_assign.html", "map_assign.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_assign.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_assign.html#map_assign", "map_assign", 'routine in <a href="obj/map/map_assign.html">map_assign.pro</a>', "map_assign.pro", "", "map_assign", "	Replaces fields in a MAP object.  This is a convenient way of 	setting multiple fields in one call, and only a single event is 	generated.    ", "noeventIf set, no event is generated.   xd@map__keywords_tree.include", "NV/OBJ/MAP", " 	Written by:	Spitale		2/2017   ");
  
  

libdata[libdataItem++] = new Array("obj/map/map_center.html", "map_center.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_center.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/map/map_centric_to_graphic.html", "map_centric_to_graphic.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_centric_to_graphic.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/map/map_create_descriptors.html", "map_create_descriptors.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_create_descriptors.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_create_descriptors.html#map_create_descriptors", "map_create_descriptors", 'routine in <a href="obj/map/map_create_descriptors.html">map_create_descriptors.pro</a>', "map_create_descriptors.pro", "", "map_create_descriptors", "	Init method for the MAP class.    ", "crdmdnNumber of descriptors to create.   @map__keywords_tree.include", "NV/LIB/DSK", " 	Written by:	Spitale, 1/1998   	Newly created or or freshly initialized disk descriptors, depending 	on the presence of the dkd keyword.    STATUS: 	Complete    ");
  
  

libdata[libdataItem++] = new Array("obj/map/map_fn_data.html", "map_fn_data.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_fn_data.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/map/map_fn_image_to_map.html", "map_fn_image_to_map.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_fn_image_to_map.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/map/map_fn_map_to_image.html", "map_fn_map_to_image.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_fn_map_to_image.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/map/map_fn_valid.html", "map_fn_valid.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_fn_valid.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/map/map_get_grid_points.html", "map_get_grid_points.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_get_grid_points.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_get_grid_points.html#map_get_grid_points", "map_get_grid_points", 'routine in <a href="obj/map/map_get_grid_points.html">map_get_grid_points.pro</a>', "map_get_grid_points.pro", "", "map_get_grid_points", "	Generates a lat/lon grid of points.    ", "latArray giving the latitudes for each constant latitude line.   lonArray giving the longitudes for each constant longitude line.   ntNumber of grids to produce.   scan_latLatitudes to scan for each constant longitude line.   scan_lonLongitudes to scan for each constant latitude line.   ", "NV/LIB/MAP", " 	Written by:	Spitale, 1/1998   	Array (2,np,nt) of map coordinate points where np is the number of 	scan_lats times the number of scan_lons.    STATUS: 	Complete  	Adapted by:	Spitale, 5/2016    ");
  
  

libdata[libdataItem++] = new Array("obj/map/map_get_ranges.html", "map_get_ranges.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_get_ranges.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/map/map_graphic.html", "map_graphic.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_graphic.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/map/map_graphic_to_centric.html", "map_graphic_to_centric.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_graphic_to_centric.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/map/map_image_to_map.html", "map_image_to_map.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_image_to_map.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/map/map_image_to_map_equatorial_ring.html", "map_image_to_map_equatorial_ring.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_image_to_map_equatorial_ring.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/map/map_image_to_map_mercator.html", "map_image_to_map_mercator.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_image_to_map_mercator.pro", "", "", "	Transforms the given image points to map coordinate points 	using a mercator projection.    ", "", "          -1", " 	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ");
  

libdata[libdataItem++] = new Array("obj/map/map_image_to_map_orthographic.html", "map_image_to_map_orthographic.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_image_to_map_orthographic.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/map/map_image_to_map_orthographic_disk.html", "map_image_to_map_orthographic_disk.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_image_to_map_orthographic_disk.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/map/map_image_to_map_rectangular.html", "map_image_to_map_rectangular.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_image_to_map_rectangular.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/map/map_image_to_map_rectangular_disk.html", "map_image_to_map_rectangular_disk.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_image_to_map_rectangular_disk.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/map/map_image_to_map_ring.html", "map_image_to_map_ring.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_image_to_map_ring.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/map/map_image_to_map_stereographic.html", "map_image_to_map_stereographic.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_image_to_map_stereographic.pro", "", "", "	Transforms the given image points to map coordinate points 	using an stereographic projection.    ", "", "          -1", " 	Written by:	Spitale, 1/1998   ");
  

libdata[libdataItem++] = new Array("obj/map/map_map_to_image.html", "map_map_to_image.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_map_to_image.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/map/map_map_to_image_equatorial_ring.html", "map_map_to_image_equatorial_ring.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_map_to_image_equatorial_ring.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/map/map_map_to_image_mercator.html", "map_map_to_image_mercator.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_map_to_image_mercator.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/map/map_map_to_image_orthographic.html", "map_map_to_image_orthographic.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_map_to_image_orthographic.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/map/map_map_to_image_orthographic_disk.html", "map_map_to_image_orthographic_disk.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_map_to_image_orthographic_disk.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/map/map_map_to_image_rectangular.html", "map_map_to_image_rectangular.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_map_to_image_rectangular.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/map/map_map_to_image_rectangular_disk.html", "map_map_to_image_rectangular_disk.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_map_to_image_rectangular_disk.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/map/map_map_to_image_ring.html", "map_map_to_image_ring.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_map_to_image_ring.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/map/map_map_to_image_stereographic.html", "map_map_to_image_stereographic.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_map_to_image_stereographic.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/map/map_origin.html", "map_origin.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_origin.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/map/map_pole.html", "map_pole.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_pole.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/map/map_projection.html", "map_projection.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_projection.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/map/map_query.html", "map_query.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_query.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_query.html#map_query", "map_query", 'routine in <a href="obj/map/map_query.html">map_query.pro</a>', "map_query.pro", "", "map_query", "	Returns the fields associated with a MAP object.  This is a 	convenient way of getting multiple fields in one call, and only a 	single event is generated.    ", "conditionStructure specifing a mask and a condition with which to 			match flag values.  The structure must contain the fields 			MASK and STATE.  MASK is a bitmask to test against 			the flags field of the POINT object, and STATE 			is either PS_TRUE and PS_FALSE.  Note that in this case, 			the values will be returned as a list, with no separation 			into nv and nt dimensions.   cat	If set, arrays from mulitple input objets are 			concatenated.  	<condition>:	All of the predefined conditions (e.g. /visible) are 			accepted; see pnt_condition_keywords.include.   noeventIf set, no event is generated.   xd@map__keywords_tree.include", "NV/OBJ/MAP", " 	Written by:	Spitale, 2/2017   ");
  
  

libdata[libdataItem++] = new Array("obj/map/map_radii.html", "map_radii.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_radii.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/map/map_range.html", "map_range.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_range.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/map/map_replicate.html", "map_replicate.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_replicate.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/map/map_rotate.html", "map_rotate.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_rotate.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/map/map_scale.html", "map_scale.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_scale.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/map/map_set_center.html", "map_set_center.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_set_center.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/map/map_set_fn_data.html", "map_set_fn_data.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_set_fn_data.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/map/map_set_graphic.html", "map_set_graphic.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_set_graphic.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/map/map_set_origin.html", "map_set_origin.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_set_origin.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/map/map_set_pole.html", "map_set_pole.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_set_pole.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/map/map_set_projection.html", "map_set_projection.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_set_projection.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/map/map_set_radii.html", "map_set_radii.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_set_radii.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/map/map_set_range.html", "map_set_range.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_set_range.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/map/map_set_rotate.html", "map_set_rotate.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_set_rotate.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/map/map_set_scale.html", "map_set_scale.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_set_scale.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/map/map_set_size.html", "map_set_size.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_set_size.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/map/map_set_units.html", "map_set_units.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_set_units.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/map/map_size.html", "map_size.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_size.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/tools/composite/map_to_disk.html", "map_to_disk.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "map_to_disk.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/tools/composite/map_to_globe.html", "map_to_globe.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "map_to_globe.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/tools/composite/map_to_image.html", "map_to_image.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "map_to_image.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/tools/composite/map_to_surface.html", "map_to_surface.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "map_to_surface.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/map/map_units.html", "map_units.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_units.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/tools/map_units_disk.html", "map_units_disk.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "map_units_disk.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/tools/mask_globe.html", "mask_globe.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "mask_globe.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/tools/minmax_latlon.html", "minmax_latlon.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "minmax_latlon.pro", "", "", "	Computes latitide/longitude ranges visible in a given camera.    ", "", "          -1", "       Written by:     Spitale   ");
  

libdata[libdataItem++] = new Array("sys/util/nv_clone.html", "nv_clone.pro", '.pro file in <a href="sys/util/dir-overview.html">sys/util/ directory</a>', "nv_clone.pro", "", "", "       Allocates a new object as a copy of the given (existing) 	object.  All pointers in the new object are newly allocated.    ", "", "          -1", " 	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ");
  

libdata[libdataItem++] = new Array("sys/event/nv_compress_events.html", "nv_compress_events.pro", '.pro file in <a href="sys/event/dir-overview.html">sys/event/ directory</a>', "nv_compress_events.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("sys/util/nv_copy.html", "nv_copy.pro", '.pro file in <a href="sys/util/dir-overview.html">sys/util/ directory</a>', "nv_copy.pro", "", "", "	Copies all fields from one descriptor to another.  New pointers 	are allocated only when the destination field is null.    ", "", "          -1", " 	Written by:	Spitale		3/2016   ");
  

libdata[libdataItem++] = new Array("sys/util/nv_directive_stop__define.html", "nv_directive_stop__define.pro", '.pro file in <a href="sys/util/dir-overview.html">sys/util/ directory</a>', "nv_directive_stop__define.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("sys/event/nv_event_struct__define.html", "nv_event_struct__define.pro", '.pro file in <a href="sys/event/dir-overview.html">sys/event/ directory</a>', "nv_event_struct__define.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("sys/event/nv_flush.html", "nv_flush.pro", '.pro file in <a href="sys/event/dir-overview.html">sys/event/ directory</a>', "nv_flush.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("sys/util/nv_free.html", "nv_free.pro", '.pro file in <a href="sys/util/dir-overview.html">sys/util/ directory</a>', "nv_free.pro", "", "", "	Recursively frees a descriptor.  Pointers and structures are 	dereferenced and descended, freeing any pointers encountered.    ", "", "          -1", " 	Written by:	Spitale   ");
  

libdata[libdataItem++] = new Array("sys/util/nv_help.html", "nv_help.pro", '.pro file in <a href="sys/util/dir-overview.html">sys/util/ directory</a>', "nv_help.pro", "", "", "	Prints information about various OMINAS objects.    ", "", "          -1", " 	Written by:	Spitale, 2/1998   ");
  

libdata[libdataItem++] = new Array("sys/state/nv_init_state.html", "nv_init_state.pro", '.pro file in <a href="sys/state/dir-overview.html">sys/state/ directory</a>', "nv_init_state.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("sys/util/nv_message.html", "nv_message.pro", '.pro file in <a href="sys/util/dir-overview.html">sys/util/ directory</a>', "nv_message.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("sys/util/nv_message.html#nv_message", "nv_message", 'routine in <a href="sys/util/nv_message.html">nv_message.pro</a>', "nv_message.pro", "", "nv_message", "	Prints an error message and halts execution.    Environment variables:   	NV_VERBOSITY:	Initial verbosity setting.    ", "nameanonymouscontinueclearget_messageformatmessageexplanationcallbackcb_data_pdisconnectcb_tagverbosesilentstopstringMessage to print.   ", "NV/SYS", " 	Written by:	Spitale, 2/1998   	message:	If /get_message, this keyword will return the last 			message sent through nv_message.    ");
  
  

libdata[libdataItem++] = new Array("sys/event/nv_notify.html", "nv_notify.pro", '.pro file in <a href="sys/event/dir-overview.html">sys/event/ directory</a>', "nv_notify.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("sys/event/nv_notify_list_struct__define.html", "nv_notify_list_struct__define.pro", '.pro file in <a href="sys/event/dir-overview.html">sys/event/ directory</a>', "nv_notify_list_struct__define.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("sys/event/nv_notify_register.html", "nv_notify_register.pro", '.pro file in <a href="sys/event/dir-overview.html">sys/event/ directory</a>', "nv_notify_register.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("sys/event/nv_notify_register.html#nv_notify_register", "nv_notify_register", 'routine in <a href="sys/event/nv_notify_register.html">nv_notify_register.pro</a>', "nv_notify_register.pro", "", "nv_notify_register", "	Register descriptor event handlers.    	nv_notify_block    STATUS: 	Complete    SEE ALSO: 	nv_notify_unregister    ", "data	Arbitrary user data to associate with events on these 			descriptors.  A pointer to this data is allocated and 			returned in the 'data_p' field of the event structure. 			Note that only one descriptor xd may be specified 			per call when using this argument.   scalar_dataScalar user data to associate with events on these 			descriptors.  This data is returned in the 'data' 			field of the event structure.   compressEvent compression flag.   _xd	Array of descriptors.   handlerName of event handler functions.  If only one element, 			then this function will be registered for every given 			descriptor.  Otherwise must have the same number of 			elements as xd.   type	Type of data event to respond to: 			 0 - set value 			 1 - get value 			0 is default.  If only one element, then this type 			will be registered for every given descriptor. 			Otherwise must have the same number of elements as xd.   ", "NV/SYS", " 	Written by:	Spitale, 6/2002   	NONE    ");
  
  

libdata[libdataItem++] = new Array("sys/event/nv_notify_unregister.html", "nv_notify_unregister.pro", '.pro file in <a href="sys/event/dir-overview.html">sys/event/ directory</a>', "nv_notify_unregister.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("sys/event/nv_ping.html", "nv_ping.pro", '.pro file in <a href="sys/event/dir-overview.html">sys/event/ directory</a>', "nv_ping.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("sys/util/nv_protected.html", "nv_protected.pro", '.pro file in <a href="sys/util/dir-overview.html">sys/util/ directory</a>', "nv_protected.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("sys/util/nv_ptr_free.html", "nv_ptr_free.pro", '.pro file in <a href="sys/util/dir-overview.html">sys/util/ directory</a>', "nv_ptr_free.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("sys/util/nv_ptr_new.html", "nv_ptr_new.pro", '.pro file in <a href="sys/util/dir-overview.html">sys/util/ directory</a>', "nv_ptr_new.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("sys/state/nv_reset.html", "nv_reset.pro", '.pro file in <a href="sys/state/dir-overview.html">sys/state/ directory</a>', "nv_reset.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("sys/event/nv_resume_events.html", "nv_resume_events.pro", '.pro file in <a href="sys/event/dir-overview.html">sys/event/ directory</a>', "nv_resume_events.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("sys/state/nv_state_struct__define.html", "nv_state_struct__define.pro", '.pro file in <a href="sys/state/dir-overview.html">sys/state/ directory</a>', "nv_state_struct__define.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("sys/event/nv_suspend_events.html", "nv_suspend_events.pro", '.pro file in <a href="sys/event/dir-overview.html">sys/event/ directory</a>', "nv_suspend_events.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/arr/ominas_array__define.html", "ominas_array__define.pro", '.pro file in <a href="obj/arr/dir-overview.html">obj/arr/ directory</a>', "ominas_array__define.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/bod/ominas_body__define.html", "ominas_body__define.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "ominas_body__define.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/cam/ominas_camera__define.html", "ominas_camera__define.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "ominas_camera__define.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/cor/ominas_core__define.html", "ominas_core__define.pro", '.pro file in <a href="obj/cor/dir-overview.html">obj/cor/ directory</a>', "ominas_core__define.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dat/ominas_data__define.html", "ominas_data__define.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "ominas_data__define.pro", "", "", "	Structure defining the data descriptor.    ", "", "          -1", " 	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016   ");
  

libdata[libdataItem++] = new Array("obj/dsk/ominas_disk__define.html", "ominas_disk__define.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "ominas_disk__define.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/glb/ominas_globe__define.html", "ominas_globe__define.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "ominas_globe__define.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/map/ominas_map__define.html", "ominas_map__define.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "ominas_map__define.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/plt/ominas_planet__define.html", "ominas_planet__define.pro", '.pro file in <a href="obj/plt/dir-overview.html">obj/plt/ directory</a>', "ominas_planet__define.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/pnt/ominas_point__define.html", "ominas_point__define.pro", '.pro file in <a href="obj/pnt/dir-overview.html">obj/pnt/ directory</a>', "ominas_point__define.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/rng/ominas_ring__define.html", "ominas_ring__define.pro", '.pro file in <a href="obj/rng/dir-overview.html">obj/rng/ directory</a>', "ominas_ring__define.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/sld/ominas_solid__define.html", "ominas_solid__define.pro", '.pro file in <a href="obj/sld/dir-overview.html">obj/sld/ directory</a>', "ominas_solid__define.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/str/ominas_star__define.html", "ominas_star__define.pro", '.pro file in <a href="obj/str/dir-overview.html">obj/str/ directory</a>', "ominas_star__define.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/stn/ominas_station__define.html", "ominas_station__define.pro", '.pro file in <a href="obj/stn/dir-overview.html">obj/stn/ directory</a>', "ominas_station__define.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("com/pg/pg_array.html", "pg_array.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_array.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_array.html#pg_array", "pg_array", 'routine in <a href="com/pg/pg_array.html">pg_array.pro</a>', "pg_array.pro", "", "pg_array", "	Computes image points for given array descriptors.    ", "cdArray (n_timesteps) of camera descriptors.   ardArray (n_objects, n_timesteps) of descriptors of objects 		that must be a subclass of array.   gbxArray (n_xd, n_timesteps) of descriptors of objects 		that must be a subclass of GLOBE.   dkxArray (n_xd, n_timesteps) of descriptors of objects 		that must be a subclass of DISK.   bxArray (n_xd, n_timesteps) of descriptors of objects 		that must be a subclass of BODY, instead of gbx or dkx.   ddData descriptor containing a generic descriptor to use 		if gd not given.   gdGeneric descriptor.  If given, the descriptor inputs 		are taken from this structure if not explicitly given.   clip If set points are computed only within this many camera 		 fields of view.   cull If set, POINT objects excluded by the clip keyword 		 are not returned.  Normally, empty POINT objects 		 are returned as placeholders.    ", "NV/PG", " 	Written by:	Spitale, 10/2012   	Array (n_objects) of objects containing image points and 	the corresponding inertial vectors.    STATUS: 	Complete    ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_bad_data.html", "pg_bad_data.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_bad_data.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_bad_data.html#pg_bad_data", "pg_bad_data", 'routine in <a href="com/pg/pg_bad_data.html">pg_bad_data.pro</a>', "pg_bad_data.pro", "", "pg_bad_data", "	Locates areas of bad data values like saturation and dropouts.    ", "dropoutValue to use for dropouts.  Default is 0   sat	If given, value above which to flag as saturated, 			inclusive.   mask	Byte image of the same size as the input image 			in which nonzero pixel values indicate locations 			where problems should not be flagged.   extend	Number of pixels away from masked pixels before 			locations may be flagged as spikes.   edge	Regions closer than this to the edge of the image 			will be ignored.  Default is 0.   subscriptsSubscript of each bad point.    dd	Data descriptor containing the image to be despiked.   ", "NV/PG", " 	Written by:	Spitale, 7/2013   	POINT objects containing the detected bad points.    STATUS: 	Complete    SEE ALSO: 	pg_spikes    ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_blemish.html", "pg_blemish.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_blemish.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("com/pg/pg_center.html", "pg_center.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_center.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("com/pg/pg_chisq.html", "pg_chisq.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_chisq.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("com/pg/pg_cntrd.html", "pg_cntrd.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_cntrd.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_cntrd.html#pg_cntrd", "pg_cntrd", 'routine in <a href="com/pg/pg_cntrd.html">pg_cntrd.pro</a>', "pg_cntrd.pro", "", "pg_cntrd", "	Calculates the centroids centered near given features in 	an image.    	Currently does not work for multiple time steps.    	For each visible object, a centroid is calcualted using the 	astronlib cntrd routine.    SEE ALSO: 	ptscan, pg_ptscan, pg_ptcntrd   STATUS: 	Complete.    ", "fwhm          Full-Width Half-maximum to use around expected point                        location.  If not given, a default fwhm of 2 pixels                        is used.   edge          Distance from edge from which to ignore points.  If                        not given, an edge distance of 0 is used.   sigmin          If given, points are discarded if the sigma above                        the mean for the centroid pixel is below this value.    dd	Data descriptor   object_ptd	Array (n_pts) of POINT objects giving the points. 			Only the image coordinates of the points need to be 			specified.   ", "NV/PG", " 	Written by:	Haemmerle, 2/1999   	An array of type POINT objects giving the detected position for        each object.  The max values for each detection is        saved in the data portion of object with tag 'scan_cc'.        The x and y offset from the given position is also saved.    ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_coadd.html", "pg_coadd.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_coadd.pro", "", "", "	Averages the given images and geometries.    ", "", "          -1", " 	Written by:	Spitale, 4/2014   ");
  

libdata[libdataItem++] = new Array("com/pg/pg_core.html", "pg_core.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_core.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_core.html#pg_core", "pg_core", 'routine in <a href="com/pg/pg_core.html">pg_core.pro</a>', "pg_core.pro", "", "pg_core", "	Generates a dn profile through a cube, or stack of images.   ", "cdCamera descriptor.  Needed for sinc interpolation. (to get PSF)   gd  Optional generic descriptor containing cd.   distance Array giving the distance, in pixels, along the profile.   interp  Type of interpolation to use.  Options are:                'nearest', 'mean', 'bilinear', 'cubic', 'sinc'.   arg_interp  Arguments to pass to the interpolation function.    sigma  Array giving the standard deviation at each point in the 		profile.   profile  The profile.   image_pts Image point for each point along the profile.    bgUniform value to subtract from profile.   dd Data descriptor(s).   outline_ptd  POINT descriptor giving the outline of the region to plot,                 as produced by the pg_select_region.   ", "NV/PG", "       Written by:     Spitale, 7/2016   	Two data descriptors: the first contains the profile; the second contains 	the profile sigma.    ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_coregister.html", "pg_coregister.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_coregister.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_coregister.html#pg_coregister", "pg_coregister", 'routine in <a href="com/pg/pg_coregister.html">pg_coregister.pro</a>', "pg_coregister.pro", "", "pg_coregister", "	Using the given geometry information, shifts the given images so as 	to center the given bodies at the same pixel in each image, or aligns 	images based on pointing.    	The given data and camera descriptors are modified: the images are 	shifted and the camera descriptor optic axes are changed accordingly.    STATUS: 	Complete    ", "cdArray of camera descripors, one for each input image.   bxArray of descriptors of any superclass of BODY, one for each 		input image.   gdGeneric descriptor containing the camera and body 		descriptors or an array of generic descriptors, one for each 		input image.   shiftOffset applied to each image.    centerImage coordinates at which to center each body.  By default, 		the average center among all the bodies is used.  If this input 		contains a single element, it is taken as the index of the 		input image to use as the reference.   pArray (1,3) giving surface coordinates at which to center 		each body.   xshiftAdditional image offset by which to shift each image.   wrapIf set shifted pixels are wrapped to the opposite side 		of the image.   subpixelBy default, each image is shifted by an integer number of 		  pixels in each direction. If this keyword is set, the 		  image is interpolated onto a new pixel grid such that the 		  sub-pixel shift is obtained.  (Not currently implemented)   no_shiftddArray of data descriptors giving images to shift.   ", "NV/PG", " 	Written by:	Spitale, 11/2002   ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_covariance.html", "pg_covariance.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_covariance.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("com/pg/pg_crop.html", "pg_crop.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_crop.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("com/pg/pg_crop_points.html", "pg_crop_points.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_crop_points.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("com/pg/pg_cull_bodies.html", "pg_cull_bodies.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_cull_bodies.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("com/pg/pg_cursor.html", "pg_cursor.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_cursor.pro", "", "", "	Allows the user to obtain information about image pixels selected 	using the mouse in the current graphics window.    ", "", "          -1", " 	Written by:	Spitale, 3/2002   ");
  

libdata[libdataItem++] = new Array("com/pg/pg_cusps.html", "pg_cusps.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_cusps.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("com/pg/pg_cvchisq.html", "pg_cvchisq.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_cvchisq.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("com/pg/pg_cvscan.html", "pg_cvscan.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_cvscan.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_cvscan.html#pg_cvscan", "pg_cvscan", 'routine in <a href="com/pg/pg_cvscan.html">pg_cvscan.pro</a>', "pg_cvscan.pro", "", "pg_cvscan", "	Attempts to find points of highest correlation with a given model along 	curves in an image.    	Currently does not work for multiple time steps.    	Normal sines and cosines are computed using icv_compute_directions. 	These directions are input to icv_strip_curve along with the image 	in order to extract an image strip to be scanned.  icv_scan_strip is 	then used to find the optimum scan offsets and icv_convert_scan_offsets 	is used to obtain image coordinates corresponding to each scan offset. 	See the documentation for each of those routines for more details.    ", "algorithmName of alrogithm to use to detect the edge. 			Choices are 'MODEL', 'GRAD', and 'HALF'. 			Default is 'MODEL'.   cdbxgdmodel_pArray (n_curves) of pointers to model arrays.  Each 			model array has dimensions (n_points,nm), where n_points 			is the number of points in the curve and nm is the 			number of points in the model.  Thus, a model may be 			specified for each point on the curve.  Default 			model is edge_model_atan().   mzero	Array (n_curves) or (n_curves,n_points) of zero-point 			offsets for each model in model_p.  mzero must be 			specified if model_p is given.   dir	If given the scan will be performed in this direction 			instead of normal to the curve.  Must be a 2-element 			unit vector.   width	Number of pixels to scan on either side of the curve. 			Default is 20.   edge	Distance from the edge of the image within which 			curve points will not be scanned.  Default is 0.   arg	Argument passed to the edge detection routine. 			For the GRAD algorithm, this argument specifies 			whether each edge is interior (arg=1) or 			exterior (arg=0).   scan_ptdIf given, these previously scanned points are updated 			to be consistent with the given data points.  The image 			is not scanned.   dd	Data descriptor   object_ptd", "NV/PG", " 	Written by:	Spitale, 2/1998   	The following command scans for a limb in the image contained in the 	given data descriptor, dd:  	scan_ptd = pg_cvscan(dd, limb_ptd, width=40, edge=20)  	In this call, limb_ptd is a POINT containing computed limb 	points.    STATUS: 	Complete    SEE ALSO: 	pg_cvscan_coeff, pg_cvchisq, pg_ptscan, pg_ptscan_coeff, pg_ptchisq, 	pg_fit, pg_threshold 	Array (n_curves) of POINT objects containing resulting image points, 	as well as additional scan data to be used by pg_cvscan_coeff and 	possibly other programs.  The scan data is as follows:  		 tag			 description 	 	-----			------------- 		scan_cos		Cosine of normal at each point. 		scan_sin		Sine of normal at each point. 		scan_offsets		Raw offsets from computed curve. 		scan_cc			Correlation coefficient for each scanned 					point. 		scan_sigma		Scan offset uncertainties. 		scan_model_xpts		Model points corresponding to each 		scan_model_ypts		 scanned point    ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_cvscan_coeff.html", "pg_cvscan_coeff.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_cvscan_coeff.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("com/pg/pg_data_adjust.html", "pg_data_adjust.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_data_adjust.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("com/pg/pg_despike.html", "pg_despike.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_despike.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_despike.html#pg_despike", "pg_despike", 'routine in <a href="com/pg/pg_despike.html">pg_despike.pro</a>', "pg_despike.pro", "", "pg_despike", "	Removes previously-located spurious features like cosmic-ray hits.    	pg_despike replaces the values of the desired pixels with those 	computed by smoothing the input image using a box filter of size 	'scale' repeatedly, 'n' times.    STATUS: 	Complete.    SEE ALSO: 	pg_spikes    ", "image	The corrected image.    scale	Typical size of features to be removed.  Default 			is 10.  	n=n:		Number of timers to repeat the box filter.  Default 			is 5.   nkernel	If set, this kernel is used to weight the replacement 			of all pixels in a box of size scale around each 			spike point, instead of replacing only the spike 			point.  If this is a scalar, then this is taken as the 			width of a Gaussian kernel.   noclonedd	Data descriptor containing the image to be despiked.   spike_ptdPOINT specifying the points to replace; 			typically computed by pg_spikes.   ", "NV/PG", " 	Written by:	Spitale, 2/2004   	Data descriptor containing the corrected image.  If /noclone 	is not set, set input data descriptor is modified.    ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_disk.html", "pg_disk.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_disk.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_disk.html#pg_disk", "pg_disk", 'routine in <a href="com/pg/pg_disk.html">pg_disk.pro</a>', "pg_disk.pro", "", "pg_disk", "	Computes image points on the inner and outer edges of each given disk 	object at all given time steps.    ", "cd Array (n_timesteps) of camera descriptors.   dkx Array (n_objects, n_timesteps) of descriptors of objects 		 which must be a subclass of DISK.   ddData descriptor containing a generic descriptor to use 		if gd not given.  	inner/outer: If either of these keywords are set, then only 	             that edge is computed.   gdGeneric descriptor.  If given, the descriptor inputs 		are taken from this structure if not explicitly given.   clip If set points are computed only within this many camera 		 fields of view.   cull If set, POINT objects excluded by the clip keyword 		 are not returned.  Normally, empty POINT objects 		 are returned as placeholders.   innerouternpointsNumber of points to compute around each edge.  Default is 		 1000.   reveal Normally, points computed for objects whose opaque flag 		 is set are made invisible.  /reveal suppresses this behavior.   countNumber of descriptors returned.    ", "NV/PG", " 	Written by:	Spitale, 2/1998   	Array (2*n_objects) of POINT containing image points and 	the corresponding inertial vectors.  The output array is arranged as 	[inner, outer, inner, outer, ...] in the order that the disk 	descriptors are given in the dkx argument.    STATUS: 	Complete    ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_drag.html", "pg_drag.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_drag.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_drag.html#pg_drag", "pg_drag", 'routine in <a href="com/pg/pg_drag.html">pg_drag.pro</a>', "pg_drag.pro", "", "pg_drag", "	Allows the user to graphically translate and rotate an array of points 	using the mouse.    	cursor_move is used to perfform the drag.  See that routine for more 	detail.    STATUS: 	Complete    SEE ALSO: 	pg_move    ", "drawxor_graphicsIf set, grahics are drawn using the XOR function.   dtheta	Dragged rotation in radians.    axis_ptdPOINT containing a single image point 			to be used as the axis of rotation.   sample	Sampling interval for drag graphics.  The input 			points are subsampled at this interval so that the 			dragging can be done smoothly.  Default is 10.   move	If set, object_ptd will be modified on return using 			pg_move.   symbol	If set, the symbol number will be passed to cursor_move 			so something other than a period can be used to mark 			points.   silent	If set, turns off the notification that cursor                        movement is required.   color	Drawing color.  Default is ctyellow.   fndataobject_ptdArray (n_objects) of POINT containing the 			image points to be dragged.   ", "NV/PG", " 	Written by:	Spitale, 2/1998       Modified by:     Dyer Lytle, Vance Haemmerle 11/1998   	2-element array giving the drag translation as [dx,dy].    ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_drag_shadow_plane.html", "pg_drag_shadow_plane.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_drag_shadow_plane.pro", "", "", "	Allows the user to graphically rotate a plane passing through the 	center of a planet by dragging the shadow cast by the planet on the 	plane using the mouse.    ", "", "          -1", " 	Written by:	Spitale, 2/2012   ");
  

libdata[libdataItem++] = new Array("com/pg/pg_draw.html", "pg_draw.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_draw.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_draw.html#pg_draw", "pg_draw", 'routine in <a href="com/pg/pg_draw.html">pg_draw.pro</a>', "pg_draw.pro", "", "pg_draw", "	Calls pg_draw_point or pg_draw_vector depending on the input arrays. 	pg_draw_point is called is only one argument is given.  Otherwise, 	it assumed that a source and target are given and pg_draw_vector is 	called.    ", "literalcolorsshadespsymspsizesplabelsxormodecsizescthickswnumlabel_shadelabel_pointsthicklineprintcdgdcorientlengthsalignnoshortensolidfixedheadswinglengthgraphicslabel_colorshade_thresholdobject_ptdArray of POINT containing image points 			to be plotted in the current data coordinate system. 			Or inertial vectors to be used as vector sources. 			May also be an array of image points or inertial 			vectors.   target_ptdArray of POINTs giving the inertial 			positions of vector targets.  May also be an 			array of inertial vectors.  If this argument is 			present, then vectors are drawn instead of points.   ", "NV/PG", " 	Written by:	Spitale, 9/2005   	NONE    STATUS: 	Complete    ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_draw_point.html", "pg_draw_point.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_draw_point.pro", "", "", "	Draws points from the given POINT on the current graphics 	window using the current data coordinate system.    ", "", "          -1", " 	Written by:	Spitale, 1/1998 (pg_draw) 	Renamed pg_draw_point: Spitale, 9/2005   	The following command draws and labels a lavender 'limb' and a red 	'ring' (assuming that the points have already been computed):  	pg_draw_point, [limb_ptd, ring_ptd], color=[ctpurple(), ctred()], $ 	         plabels=['LIMB','RING']    STATUS: 	Complete ");
  

libdata[libdataItem++] = new Array("com/pg/pg_draw_vector.html", "pg_draw_vector.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_draw_vector.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_draw_vector.html#pg_draw_vector", "pg_draw_vector", 'routine in <a href="com/pg/pg_draw_vector.html">pg_draw_vector.pro</a>', "pg_draw_vector.pro", "", "pg_draw_vector", "         Draws vectors on an image from a source towards a          target. Very useful for locating off-image objects          (planets, say) in an image for referencing.  By default,          vectors are foreshortened to their projections onto the image          plane so that vectors with large  out-of-plane components          will be shorter.  (This can be deactivated with the          /noshorten keyword.)  Also by default, vectors that point          away from the camera will be drawn as dotted lines while          vectors which point towards the camera will be drawn solid.          (This can be controlled with the /solid keyword.)     ", "cdddgdliteralAll of the following input keywords accept an array 			where each element corresponds to an element in the 			object_ptd array.  By default, if the keyword array is 			shorter than the object_ptd array, then the last element 	  		is used to fill out the array.  /literal suppresses 			this behavior and causes unspecified elements to 			take their default values   lengths       Lengths of the vectors.  (Default: 50 pixels)   plabels        Text with which to label vectors.  (Default:                        no label)   colors        Colors to use in drawing.  (Default: current                        default color)   thick        Line thicknesses.  (Default: 1)   csizes     Character sizes for plabels.  (Default: 1)   wnumnoshorten    If set, vectors will not be foreshortened                        depending on how much they point into/out                        of the image plane.   solid        All lines are to be drawn solid (linestyle=0)                        rather than allow vectors pointing into the                        image plane to be dotted.   fixedheads    If set, arrowheads will not be scaled to                         match the foreshortening of the vector.   winglengthdraw_wnumshadeslabel_shadelabel_colorshade_thresholdsourcetarget", "NV/PG", "      Written: John W. Weiss, 5/05      Consolidated some functionality into plot_arrow; Spitale 9/2005           Say moon_points is a POINT object containing the center        data for the four Galilean satellites and jupiter_points has        Jupiter's center data.  Then         IDL> pg_draw_vector, moon_points, jupiter_points, colors=[100, $              150, 200, 250], thick=1.25, length=70, plabels= Jupiter , $              csizes=1.5         will draw vectors from each towards the planet.  Conversely,         IDL> pg_draw_vector, jupiter_points, moon_points, colors=[100, $              150, 200, 250], thick=1.25, length=70, plabels=[ Io ,  Europa , $               Ganymede ,  Callisto ], csizes=1.5         will draw vectors from Jupiter's center towards each moon,        labelling each by the moon's name. ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_edges.html", "pg_edges.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_edges.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_edges.html#pg_edges", "pg_edges", 'routine in <a href="com/pg/pg_edges.html">pg_edges.pro</a>', "pg_edges.pro", "", "pg_edges", "	Scans an image for candidate edge points.    	At each pixel in the image, an activity is computed (see activity.pro). 	Points with activity greater than the threshold value are accepted.    STATUS: 	Complete    SEE ALSO: 	pg_cvscan_coeff, pg_cvchisq, pg_ptscan, pg_ptscan_coeff, pg_ptchisq, 	pg_fit, pg_threshold    ", "thresholdMinimum activity to accept as an edge point.   edge	Distance from the edge of the image within which 			curve points will not be scanned.  Default is 0.   npointsMaximum number of points to return.   gatelowpassIf given, the image is smoothed with a kernel of 			this size.    dd	Data descriptor   ", "NV/PG", " 	Written by:	Spitale, 4/2002   	POINT giving the resulting edge points.    ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_exclude_points.html", "pg_exclude_points.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_exclude_points.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("com/pg/pg_farfit.html", "pg_farfit.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_farfit.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_farfit.html#pg_farfit", "pg_farfit", 'routine in <a href="com/pg/pg_farfit.html">pg_farfit.pro</a>', "pg_farfit.pro", "", "pg_farfit", "	Searches for the offset (dx,dy) that gives the best agreement between 	two uncorrelated sets of image points.    	pg_farfit is a wrapper for the routine correlate_points.  See the 	documentation for that routine for details on the fitting procedure    STATUS: 	Complete.    SEE ALSO: 	pg_edges correlate_points    ", "nsamplesNumber of samples in each direction in the grid search. 			See image_correlate.   show	If specified, the search is displayed in the current 			graphics window.  This value can be specified as a 			2-element array giving the size of the displayed image.   bin	Initial bin size for point densities.  Default is 50 			pixels.   max_densityMaximum model point density.  Default = 5.   region	Size of region to scan, centered at offset [0,0].  If not 			specified, the entire image is scanned.   sigma	2-element array giving the width of the correlation 			peak in each direction.   cc	Cross correlation of final result.   mcc	Corss correlation at the model points.   bias	If given, solutions are biased toward the initial 			guess using a weighting function of the form:  				exp(-r^2/2*bias),  			where r is the distance between from the initial 			guess.   nosearchIf set, no search is performed.  An offset of [0,0] 			is returned.    dd	Data descriptor.   base_ptdPOINT giving a set of points to fit to. 			This input may be produced by pg_edges, for example.   model_ptdArray of POINT giving model points (computed 			limb points for example).   ", "NV/PG", " 	Written by:	Spitale, 4/2002   	2-element array giving the fit offset as [dx,dy].    ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_fit.html", "pg_fit.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_fit.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("com/pg/pg_footprint.html", "pg_footprint.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_footprint.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_footprint.html#pg_footprint", "pg_footprint", 'routine in <a href="com/pg/pg_footprint.html">pg_footprint.pro</a>', "pg_footprint.pro", "", "pg_footprint", "	Computes the footprint of a camera on a given body.    ", "cdArray (n_timesteps) of camera descriptors.   bxArray (n_objects, n_timesteps) of descriptors of objects 		which must be a subclass of BODY.   ddData descriptor containing a generic descriptor to use 		if gd not given.   gdGeneric descriptor.  If given, the descriptor inputs 		are taken from this structure if not explicitly given.   clip If set, points are computed only within this many camera 		 fields of view.   sample Sampling rate; default is 1 pixel.   ", "NV/PG", " 	Written by:	Spitale, 5/2014   	Array (n_objects) of POINT containing image points and 	the corresponding inertial vectors.    STATUS: 	Complete    ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_get_arrays.html", "pg_get_arrays.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_get_arrays.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_get_arrays.html#pg_get_arrays", "pg_get_arrays", 'routine in <a href="com/pg/pg_get_arrays.html">pg_get_arrays.pro</a>', "pg_get_arrays.pro", "", "pg_get_arrays", "	Obtains a array descriptor for the given data descriptor.    	If /override, then a array descriptor is created and initialized 	using the specified values.  Otherwise, the descriptor is obtained 	through the translators.  Note that if /override is not used, 	values (except name) can still be overridden by specifying 	them as keyword parameters.  If name is specified, then 	only descriptors corresponding to those names will be returned.     ", "odbxard	Input array descriptors; used by some translators.   _extraoverrideCreate a data descriptor and initilaize with the 			given values.  Translators will not be called.   verbatimIf set, the descriptors requested using name 			are returned in the order requested.  Otherwise, the 			order is determined by the translators.   countNumber of descriptors returned    arg1Data descriptor or transient translator argument.  In the 		latter case, a string containing keywords and values to be 		passed directly to the translators as if they appeared as 		arguments in the translators table.  Keywords passed using 		this mechanism take precedence over keywords appearing in 		the translators table.  If no data descriptor is given, 		one may be constructed using DATA keywords (see below).  The 		newly created data descriptor is freed unless this argument 		is an undefined named variable, in which case the new 		descriptor is returned in this variable.   arg2Transient translator argument, if present.   @arr__keywords_tree.include", "NV/PG", " 	Written by:	Spitale, 10/2012   	Array of array descriptors, 0 if an error occurs.    ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_get_cameras.html", "pg_get_cameras.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_get_cameras.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_get_cameras.html#pg_get_cameras", "pg_get_cameras", 'routine in <a href="com/pg/pg_get_cameras.html">pg_get_cameras.pro</a>', "pg_get_cameras.pro", "", "pg_get_cameras", "	Obtains a camera descriptor for the given data descriptor.    	If /override, then a camera descriptor is created and initialized 	using the specified values.  Otherwise, the descriptor is obtained 	through the translators.  Note that if /override is not used, 	values (except cam_name) can still be overridden by specifying 	them as keyword parameters.  If cam_name is specified, then 	only descriptors corresponding to those names will be returned.     ", "cd	Input camera descriptors; used by some translators.   odpd_extraoverrideCreate a data descriptor and initilaize with the 			given values.  Translators will not be called.   verbatimIf set, the descriptors requested using cam_name 			are returned in the order requested.  Otherwise, the 			order is determined by the translators.   default_orientDefault orientation matrix to use if camera 			orientation is not available.  If not specified, 			the identity matrix is used.   	CAMERA Keywords 	--------------- 	All CAMERA override keywords are accepted.  See cam__keywords.include. 	If 'name' is specified, then only descriptors with those names are 	returned.  	DATA Keywords 	------------- 	All DATA override keywords are accepted.  See dat__keywords.include.   no_defaultcountNumber of descriptors returned    arg1Data descriptor or transient translator argument.  In the 		latter case, a string containing keywords and values to be 		passed directly to the translators as if they appeared as 		arguments in the translators table.  Keywords passed using 		this mechanism take precedence over keywords appearing in 		the translators table.  If no data descriptor is given, 		one may be constructed using DATA keywords (see below).  The 		newly created data descriptor is freed unless this argument 		is an undefined named variable, in which case the new 		descriptor is returned in this variable.   arg2Transient translator argument, if present.   @cam__keywords_tree.include", "NV/PG", " 	Written by:	Spitale, 1998 	Modified:	Spitale, 8/2001   	Array of camera descriptors, 0 if an error occurs.    ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_get_celestial_sphere.html", "pg_get_celestial_sphere.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_get_celestial_sphere.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("com/pg/pg_get_maps.html", "pg_get_maps.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_get_maps.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_get_maps.html#pg_get_maps", "pg_get_maps", 'routine in <a href="com/pg/pg_get_maps.html">pg_get_maps.pro</a>', "pg_get_maps.pro", "", "pg_get_maps", "	Obtains a map descriptor for the given data descriptor.    	If /override, then a map descriptor is created and initialized 	using the specified values.  Otherwise, the descriptor is obtained 	through the translators.  Note that if /override is not used, 	values (except name) can still be overridden by specifying 	them as keyword parameters.  If name is specified, then 	only descriptors corresponding to those names will be returned.     ", "md	Input map descriptors; used by some translators.   gbxdkxbx_extraoverrideCreate a data descriptor and initilaize with the 			given values.  Translators will not be called.   verbatimIf set, the descriptors requested using name 			are returned in the order requested.  Otherwise, the 			order is determined by the translators.   countNumber of descriptors returned    arg1Data descriptor or transient translator argument.  In the 		latter case, a string containing keywords and values to be 		passed directly to the translators as if they appeared as 		arguments in the translators table.  Keywords passed using 		this mechanism take precedence over keywords appearing in 		the translators table.  If no data descriptor is given, 		one may be constructed using DATA keywords (see below).  The 		newly created data descriptor is freed unless this argument 		is an undefined named variable, in which case the new 		descriptor is returned in this variable.   arg2Transient translator argument, if present.   @map__keywords_tree.include", "NV/PG", " 	Written by:	Spitale, 1998 	Modified:	Spitale, 8/2001   	Array of map descriptors, 0 if an error occurs.    ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_get_planets.html", "pg_get_planets.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_get_planets.pro", "", "", "	Obtains planet descriptors for the given data descriptor.    	If /override, then a planet descriptor is created and initialized 	using the specified values.  Otherwise, the descriptor is obtained 	through the translators.  Note that if /override is not used, 	values (except name) can still be overridden by specifying 	them as keyword parameters.  If name is specified, then 	only descriptors corresponding to those names will be returned.     ", "", "          -1", " 	Written by:	Spitale, 1998 	Modified:	Spitale, 8/2001   ");
  

libdata[libdataItem++] = new Array("com/pg/pg_get_rings.html", "pg_get_rings.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_get_rings.pro", "", "", "	Obtains ring descriptors for the given data descriptor.    	If /override, then a ring descriptor is created and initialized 	using the specified values.  Otherwise, the descriptor is obtained 	through the translators.  Note that if /override is not used, 	values (except name) can still be overridden by specifying 	them as keyword parameters.  If name is specified, then 	only descriptors corresponding to those names will be returned.    ", "", "          -1", " 	Written by:	Spitale, 1998 	Modified:	Spitale, 8/2001   ");
  

libdata[libdataItem++] = new Array("com/pg/pg_get_stars.html", "pg_get_stars.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_get_stars.pro", "", "", "	Obtain star descriptors for the given data descriptor.    	If /override, then a star descriptor is created and initialized 	using the specified values.  Otherwise, the descriptor is obtained 	through the translators.  Note that if /override is not used, 	values (except name) can still be overridden by specifying 	them as keyword parameters.  If name is specified, then 	only descriptors corresponding to those names will be returned.    ", "", "          -1", " 	Written by:	Spitale, 1998 	Modified:	Spitale, 8/2001   ");
  

libdata[libdataItem++] = new Array("com/pg/pg_get_stations.html", "pg_get_stations.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_get_stations.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_get_stations.html#pg_get_stations", "pg_get_stations", 'routine in <a href="com/pg/pg_get_stations.html">pg_get_stations.pro</a>', "pg_get_stations.pro", "", "pg_get_stations", "	Obtains a station descriptor for the given data descriptor.    	If /override, then a station descriptor is created and initialized 	using the specified values.  Otherwise, the descriptor is obtained 	through the translators.  Note that if /override is not used, 	values (except name) can still be overridden by specifying 	them as keyword parameters.  If name is specified, then 	only descriptors corresponding to those names will be returned.     ", "odbxstd	Input station descriptors; used by some translators.   _extraoverrideCreate a data descriptor and initilaize with the 			given values.  Translators will not be called.   verbatimIf set, the descriptors requested using name 			are returned in the order requested.  Otherwise, the 			order is determined by the translators.   countNumber of descriptors returned    arg1Data descriptor or transient translator argument.  In the 		latter case, a string containing keywords and values to be 		passed directly to the translators as if they appeared as 		arguments in the translators table.  Keywords passed using 		this mechanism take precedence over keywords appearing in 		the translators table.  If no data descriptor is given, 		one may be constructed using DATA keywords (see below).  The 		newly created data descriptor is freed unless this argument 		is an undefined named variable, in which case the new 		descriptor is returned in this variable.   arg2Transient translator argument, if present.   @stn__keywords_tree.include", "NV/PG", " 	Written by:	Spitale, 2/2009   	Array of station descriptors, 0 if an error occurs.    ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_grid.html", "pg_grid.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_grid.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_grid.html#pg_grid", "pg_grid", 'routine in <a href="com/pg/pg_grid.html">pg_grid.pro</a>', "pg_grid.pro", "", "pg_grid", "	Computes image points on a surface coordinate grid.    ", "cdArray (n_timesteps) of camera descriptors.   gbxArray (n_objects, n_timesteps) of descriptors of objects 		that must be a subclass of GLOBE.   dkxArray (n_objects, n_timesteps) of descriptors of objects 		that must be a subclass of DISK.   bxArray (n_objects, n_timesteps) of descriptors of objects 		that must be a subclass of BODY.   ddData descriptor containing a generic descriptor to use 		if gd not given.   gdGeneric descriptor.  If given, the descriptor inputs 		are taken from this structure if not explicitly given.   latArray giving grid-line latitudes in radians.   lonArray giving grid-line longitudes in radians.   nlatNumber of equally-spaced latitude lines to generate if keyword 		lat not given.  Default is 12.   nlonNumber of equally-spaced longitude lines to generate if keyword 		lon not given.  Default is 12.   flatThis reference latitude line will be one of the latitude lines generated 		if nlat is specified.  Default is zero.   flonThis reference longitude line will be one of the longitude lines generated 		if nlon is specified.  Default is zero.   npointsNumber of points to compute in each latitude or longitude line, 		 per 2*pi radians; default is 360.   clip If set points are computed only within this many camera 		 fields of view.   cull If set, POINT objects excluded by the clip keyword 		 are not returned.  Normally, empty POINT objects 		 are returned as placeholders.   slatLatitudes to compute on each longitude circle.   slonLongitudes to compute on each latitude circle.    countNumber of descriptors returned.    ", "NV/PG", " 	Written by:	Spitale, 2/1998   	Array of POINT containing image points and the corresponding inertial 	vectors.    STATUS: 	Complete    ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_hide.html", "pg_hide.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_hide.pro", "", "", "	Hides the given points with respect to each given object and observer 	using the hide methods of the given bodies.    	The flags arrays in point_ptd are modified.    	For each object in point_ptd, hidden points are computed and 	PTD_MASK_INVISIBLE in the POINT is set.  No points are 	removed from the array.    ", "", "          -1", " 	Written by:	Spitale, 3/2017, generalized pg_hide_globe and pg_hide_disk   	The following command hides all points which are behind a planet as 	seen by the camera:  	pg_hide, point_ptd, cd=cd, bx=pd  	In this call, pd is a planet descriptor, and cd is a camera descriptor.    STATUS: 	Complete    SEE ALSO: 	pg_hide_limb ");
  

libdata[libdataItem++] = new Array("com/pg/pg_image_sector.html", "pg_image_sector.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_image_sector.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_image_sector.html#pg_image_sector", "pg_image_sector", 'routine in <a href="com/pg/pg_image_sector.html">pg_image_sector.pro</a>', "pg_image_sector.pro", "", "pg_image_sector", "	Allows the user to select a rectangular image region, with an 	arbitrary tilt, by clicking and dragging.  A rectangle is selected 	using the left mouse button and a line of zero width is selected 	using the right moise button.   ", "sample    Pixel grid sampling to use instead of 1.   win_num    Window number of IDL graphics window in which to select                    box, default is current window.   width    Width of box instead of letting the user select.   restore    Do not leave the box in the image.   p0    First corner of box.  If set, then the routine immediately                    begins to drag from that point until a button is released.   p1    Endpoint.  If given, p0 must also be given and is taken                    as the starting point for a line along which to scan.                    In this case, the user does not select the box manually.                    Scan width is one pixel unless 'width' is specified,                    and is centered on the line from p0 to p1.   xor_graphics    If set, the sector outline is drawn and erased using xor                    graphics instead of a pixmap.   color    Color to use for rectangle, default is !color.   silent    If set, messages are suppressed.    corners    If set, then p0 and p1 are taken as the corners of                    the box, and the user is not prompted to select one.   ", "NV/PG", "      POINT containing points on the sector outline.  The point       spacing is determined by the sample keyword.   ORIGINAL AUTHOR : J. Spitale ; 6/2005   ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_limb.html", "pg_limb.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_limb.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_limb.html#pg_limb", "pg_limb", 'routine in <a href="com/pg/pg_limb.html">pg_limb.pro</a>', "pg_limb.pro", "", "pg_limb", "	Computes image points on the limb of each given globe object.    	By definition, the surface normal at a point on the limb of a body is 	perpendicular to a vector from the observer to that same point, so the 	dot product of the two vectors is zero.  This program uses an iterative 	scheme to find points onthe surface at which this dot product is less 	than epsilon.    ", "cd Array (n_timesteps) of camera descriptors.   od Array (n_timesteps) of descriptors of objects 		 which must be a subclass of BODY.  These objects are used 		 as the observer from which limb is computed.  If no observer 		 descriptor is given, the camera descriptor is used.   gbx Array (n_objects, n_timesteps) of descriptors of objects 		 which must be a subclass of GLOBE.   ddData descriptor containing a generic descriptor to use 		if gd not given.   gdGeneric descriptor.  If given, the descriptor inputs 		are taken from this structure if not explicitly given.   clip If set points are computed only within this many camera 		 fields of view.   cull If set, POINT objects excluded by the clip keyword 		 are not returned.  Normally, empty POINT objects 		 are returned as placeholders.   npointsNumber of points to compute.  Default is 1000.   epsilonMaximum angular error in the result.  Default is 1e-3.   reveal Normally, points computed for objects whose opaque flag 		 is set are made invisible.  /reveal suppresses this behavior.   countNumber of descriptors returned.    ", "NV/PG", " 	Written by:	Spitale, 1/1998   	The following command computes points on the planet which lie on the 	terminator:  	term_ptd = pg_limb,(cd=cd, gbx=pd, od=sd)  	In this call, pd is a planet descriptor, cd is a camera descriptor, 	and sd is a star descriptor (i.e., the sun).    STATUS: 	Complete 	Array (n_objects) of POINT containing image 	points and the corresponding inertial vectors.    ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_limb_sector.html", "pg_limb_sector.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_limb_sector.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_limb_sector.html#pg_limb_sector", "pg_limb_sector", 'routine in <a href="com/pg/pg_limb_sector.html">pg_limb_sector.pro</a>', "pg_limb_sector.pro", "", "pg_limb_sector", "	Allows the user to select an image sector along lines of constant  	azimuth and altitude above a planet by clicking and dragging.   ", "cd    Camera descriptor.   gbx    Globe descriptor for the planet whose limb is to be                    scanned.   gd    Generic descriptor containnig the above descriptors.   lonsample    Sets the grid sampling in pixels.  Default is one.   win_num    Window number of IDL graphics window in which to select                    box, default is current window.   restore    Do not leave the box in the image.   p0    First corner of box.  If set, then the routine immediately                    begins to drag from that point until a button is released.   xor_graphics    If set, the sector outline is drawn and erased using xor                    graphics instead of a pixmap.   color    Color to use for rectangle, default is !color.   silent    If set, messages are suppressed.    nodsk    If set, skyplane disk image points will not be included                    in the output POINT.   dkd     Disk desriptor in the skyplane, centered on the planet                    with 0 axis along the skyplane projection of the north                    pole.  For use with pg_profile_ring.   altitudesArray giving altitude at each sample.   azimuthsArray giving azimuth at each sample.   limb_pts_bodyBody coordinates of each limb points on planet surface.    cw    If set, azimuths are assumed to increase in the clockwise                    direction.   ", "NV/PG", "      POINT containing points on the sector outline.  The point       spacing is determined by the sample keyword.  The POINT object       also contains the disk coordinate for each point, relative to the       returned disk descriptor, and the user fields 'nrad' and 'nlon'       giving the number of points in altitude and azimuth.   KNOWN BUGS: 	The sector flips when it hits zero azimuth rather than retaining a 	consistent sense.    MODIFICATION HISTORY : 	Spitale; 8/2006		original version   ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_limb_sector_altaz.html", "pg_limb_sector_altaz.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_limb_sector_altaz.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_limb_sector_altaz.html#pg_limb_sector_altaz", "pg_limb_sector_altaz", 'routine in <a href="com/pg/pg_limb_sector_altaz.html">pg_limb_sector_altaz.pro</a>', "pg_limb_sector_altaz.pro", "", "pg_limb_sector_altaz", "	Constructs a limb sector outline for use with pg_profile_ring given 	altitude and azimuth bounds.   ", "cd    Camera descriptor.   gbx    Globe descriptor giving the planet about whose limb                    the scan will be extracted.   gd    Generic descriptor containing the above descriptors.   dkd    Disk descriptor in the skyplane, centered on the planet                    with 0 axis along the skyplane projection of the north                    pole.  For use with pg_profile_ring.   sample    Sets the grid sampling in pixels.  Default is one.   nodsk    If set, skyplane disk image points will not be included                    in the output POINT.   altitudesArray giving altitude at each sample.   azimuthsArray giving azimuth at each sample.   limb_pts_bodyBody coordinates of each limb points on planet surface.     cw    If set, azimuths are assumed to increase in the clockwise                    direction.   naz    Total number of samples in the azimuthal direction.                    Determined by the 'sample' keyword by default.   nalt    Total number of samples in the altitude direction.                    Determined by the 'sample' keyword by default.   graphic    If set, the sector is computed in the planetographic                    sense, i.e., lines of constant azimuth extend along                    the local surface normal direction instead of the radial                    direction.    alt2-elements array giving the lower and upper altitude bounds 		for the sector.   _az2-elements array giving the lower and upper azimuth bounds 		for the sector in radians, reliative to the skyplane 		projection of the planet's north pole.   ", "NV/PG", "      POINT containing points on the sector outline.  The point       spacing is determined by the sample keyword.  The POINT objects       also contains the disk coordinate for each point, relative to the       returned disk descriptor, and the user fields 'nrad' and 'nlon'       giving the number of points in altitude and azimuth.   KNOWN BUGS: 	The sector flips when it hits zero azimuth rather than retaining a 	consistent sense.    ORIGINAL AUTHOR : 	Spitale; 8/2006   ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_limb_sector_linear.html", "pg_limb_sector_linear.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_limb_sector_linear.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_limb_sector_linear.html#pg_limb_sector_linear", "pg_limb_sector_linear", 'routine in <a href="com/pg/pg_limb_sector_linear.html">pg_limb_sector_linear.pro</a>', "pg_limb_sector_linear.pro", "", "pg_limb_sector_linear", "	Constructs a limb sector outline for use with pg_profile_image, given 	altitude and length bounds.  The sector is rectangular, being tangent 	to the limb at a given azimuth.   ", "cd    Camera descriptor.   gbx    Globe descriptor giving the planet about whose limb                    the scan will be extracted.   gd    Generic descriptor containig the above descriptors.   sample    Sets the grid sampling in pixels.  Default is one.   altitudesArray giving altitude at each sample.    rimsArray giving azimuth at each sample.   nrim    Total number of samples in the scan direction.                    Determined by the 'sample' keyword by default.   nalt    Total number of samples in the altitude direction.                    Determined by the 'sample' keyword by default.   graphic    If set, the sector is computed in the planetographic                    sense, i.e., lines of constant azimuth extend along                    the local surface normal direction instead of the radial                    direction.    alt2-elements array giving the lower and upper altitude bounds 		for the sector.   _rim2-element array giving the image-coordinate cylidrical coordinates 		of the the ends of the sector.   az0Azimuth of the sector tangent point.   ", "NV/PG", "      POINT object containing points on the sector outline.  The point       spacing is determined by the sample keyword.  The POINT object       also contains the user fields 'nl' and 'nw' giving the number of points       in altitude and r.   KNOWN BUGS: 	The sector flips when it hits zero azimuth rather than retaining a 	consistent sense.    ORIGINAL AUTHOR : 	Spitale; 1/2009   ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_limb_sector_oblique.html", "pg_limb_sector_oblique.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_limb_sector_oblique.pro", "", "", "	Allows the user to select an image sector along lines of constant  	azimuth and altitude above a planet by clicking and dragging.   ", "", "          -1", "");
  

libdata[libdataItem++] = new Array("com/pg/pg_linearize_image.html", "pg_linearize_image.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_linearize_image.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_linearize_image.html#pg_linearize_image", "pg_linearize_image", 'routine in <a href="com/pg/pg_linearize_image.html">pg_linearize_image.pro</a>', "pg_linearize_image.pro", "", "pg_linearize_image", "	Reprojects an image onto a linear scale.    	The input image is divided into pieces and tranformed one piece at 	a time.  There are two modes of operation: If nmp and scp are 	given, then the image is transformed using them as control points. 	Otherwise, the image is transformed using whatever camera transformation 	is specified in the camera descriptor.    STATUS: 	Control-point scheme not yet implemented.    SEE ALSO: 	pg_resfit, pg_resloc    ", "cdCamera descriptor describing the image to be reprojected.   gdGeneric descriptor containing the above descriptor.   fcpFocal coordinates of known reseau locations.   scpImage coordinates in input image of detected reseau marks 		corresponding to those given by nmp.   scale2-element array giving the camera scale (radians/pixel) 		in each direction for the reprojected image.  If not given, the 		scale of the input image is used.   oaxis2-element array giving the image coordinates of the optic axis 		in the reprojected image.  If not given, the center of 		the reprojected image is used.   size2-element array giving the size of the reprojected image.  If 		not given, the size of the input image is used.   pc_xsizeY-Size of each image piece.  Default is 200 pixels.   pc_ysizeimageThe output image, which is also placed in the data descriptor.    interpType of interpolation to use.  Options are: 		'nearest', 'mean', 'bilinear', 'cubic', 'sinc'.   ddData descriptor containing image to be reprojected.   new_cd", "NV/PG", " 	Written by:	Spitale, 5/2002   	Data descriptor containing the reprojected image.    ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_load_maps.html", "pg_load_maps.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_load_maps.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("com/pg/pg_map.html", "pg_map.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_map.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_map.html#pg_map", "pg_map", 'routine in <a href="com/pg/pg_map.html">pg_map.pro</a>', "pg_map.pro", "", "pg_map", "	Generates map projections.    ", "mdMap descriptor describing the projection.   cdCamera descriptor describing the image to be projected.   bxSubclass of BODY giving the body to be projected.  Can be 		GLOBE or RING.  Only bodies whose names match that in the 		map descriptor are mapped.   gbxGlobe descriptor describing the body to be projected. 		This argument is kept for compatibility with earlier 		code.  It is recommended that you use the 'bx' argument 		instead.   dkxDisk descriptor describing the body to be projected. 		This argument is kept for compatibility with earlier 		code.  It is recommended that you use the 'bx' argument 		instead.   ltdStar descriptor for a light source.  If given, points behind the 		terminator are excluded.   gdGeneric descriptor.  If given, the above descriptor inputs 		are taken from the corresponding fields of this structure 		instead of from those keywords.   hide_fn 		String giving the name of a function whose purpose 		is to exclude hidden points from the map.  Options are: 		   pm_hide_ring 		   pm_hide_globe 		   pm_rm_globe_shadow 		   pm_rm_globe   hide_bx 		Array of BODY objects for the hide functions; one per 		function.   mapFor convenience, the generated map is returned here as 		well as in the returned data descriptor.    aux_names 		Array (naux) giving udata names for additional data 		descriptor planes to reproject.  The dimensions of these 		planes must be the same as the image.  	pc_xsize, pc_ysize: 		The map is generated in pieces of size pc_xsize 		x pc_ysize.   Default is 100 x 100 pixels.   pc_xsizepc_ysizebounds 		Projection bounds specified as [lat0, lat1, lon0, lon1].   interpType of interpolation, see image_interp_cam.   arg_interpInterpolation argument, see image_interp_cam.   offsetOffset in [lat,lon] to apply to map coordinates before 		projecting.   edgeMinimum proximity to image edge.  Default is 0.   shear_fnshear_datasmoothIf set, the input image is smoothed before reprojection.   roiSubscripts in the output map specifying the map region 		to project, instead of the whole thing.   test_factorIf set, a test map, reduced in size by this factor, 			is projected to determine the roi.  For maps with 			large blank areas, this may speed up the projection 			greatly.    ddData descriptor containing image to be projected.   ", "NV/PG", " 	Written by:	Spitale, 1998 	Modified:	Daiana DiNino; 7, 2011 : test_factor   	Data descriptor containing the output map.  The instrument field is set 	to 'MAP'.  User data arrays are created for the reprojected aux_names 	arrays.    STATUS: 	Complete    SEE ALSO: 	pg_mosaic    ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_mask.html", "pg_mask.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_mask.pro", "", "", "	Uses the given geometry to compute an image mask for all objects 	in a scene.    ", "", "          -1", " 	Written by:	Spitale, 4/2004   ");
  

libdata[libdataItem++] = new Array("com/pg/pg_measure.html", "pg_measure.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_measure.pro", "", "", "	Allows the user to measure quantities between two points in an 	image using the mouse in the current graphics window.    ", "", "          -1", " 	Written by:	Spitale, 3/2002   ");
  

libdata[libdataItem++] = new Array("com/pg/pg_mosaic.html", "pg_mosaic.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_mosaic.pro", "", "", "	Combines two or more maps into one.    ", "", "          -1", " 	Written by:	Spitale 1/2002   ");
  

libdata[libdataItem++] = new Array("com/pg/pg_move.html", "pg_move.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_move.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("com/pg/pg_nearest_points.html", "pg_nearest_points.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_nearest_points.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("com/pg/pg_northangle.html", "pg_northangle.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_northangle.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("com/pg/pg_photom.html", "pg_photom.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_photom.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_photom.html#pg_photom", "pg_photom", 'routine in <a href="com/pg/pg_photom.html">pg_photom.pro</a>', "pg_photom.pro", "", "pg_photom", "	Photometric image correction for disk or globe objects.    ", "outline_ptdPOINT with image points outlining the 			region of the image to correct.  To correct the entire 			planet, this input could be generated using pg_limb(). 			If this keyword is not given, the entire image is used.   cdCamera descriptor   gbxGlobe descriptor   dkxDisk descriptor   ltdSun descriptor   gdGeneric descriptor.  If present, cd, dkx, and gbx are taken 		from here if contained.   refl_fnString naming reflectance function to use.  Default is 			'pht_minneart'.   phase_fnString naming phase function to use.  Default is none.   refl_parmphase_parmemm_outImage emission angles.   inc_outImage incidence angles.   phase_outImage phase angles.    overwriteIf set, the output descriptor is the input descriptor 			with the relevant fields modified.   ddData descriptor containing image to correct.    ", "NV/PG", " 	Written by:	Spitale, 6/2004   	Data descriptor containing the corrected image.  The photometric angles 	emm, inc, and phase are placed in the user data arrays with the tags 	'EMM', 'INC', and 'PHASE' respectively.    STATUS: 	Complete    ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_photom_disk.html", "pg_photom_disk.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_photom_disk.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_photom_disk.html#pg_photom_disk", "pg_photom_disk", 'routine in <a href="com/pg/pg_photom_disk.html">pg_photom_disk.pro</a>', "pg_photom_disk.pro", "", "pg_photom_disk", "	Photometric image correction for disk objects.    ", "outline_ptdPOINT with image points outlining the 			region of the image to correct.  To correct the entire 			disk, this input could be generated using pg_ring(). 			If this keyword is not given, the entire image is used. 			If two arrays are given, they are taken as the inner 			and outer boundaries.   cdCamera descriptor   dkxDisk descriptor   ltdLight descriptor   gdGeneric descriptor.  If present, cd and dkx are taken from 		here if contained.   refl_fnString naming reflectance function to use.  Default is 			'pht_minneart'.   phase_fnString naming phase function to use.  Default is none.   refl_parmphase_parmemm_outImage emission angles.   inc_outImage incidence angles.   phase_outImage phase angles.    overwriteIf set, the output descriptor is the input descriptor 			with the relevant fields modified.   ddData descriptor containing image to correct.    ", "NV/PG", " 	Written by:	Spitale, 1/2002 (pg_photom) 	 Spitale, 6/2004:	changed to pg_photom_disk   	New data descriptor containing the corrected image.  The photometric 	angles emm, inc, and phase are placed in the user data arrays with 	the tags'EMM', 'INC', and 'PHASE' respectively.  Unless /overwrite is 	set, the nw descriptor is a clone of the input descriptor, with the 	relevant fields modified.    STATUS: 	Complete    ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_photom_globe.html", "pg_photom_globe.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_photom_globe.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_photom_globe.html#pg_photom_globe", "pg_photom_globe", 'routine in <a href="com/pg/pg_photom_globe.html">pg_photom_globe.pro</a>', "pg_photom_globe.pro", "", "pg_photom_globe", "	Photometric image correction for globe objects.    ", "outline_ptdPOINT with image points outlining the 			region of the image to correct.  To correct the entire 			planet, this input could be generated using pg_limb(). 			If this keyword is not given, the entire image is used.   cdCamera descriptor   gbxGlobe descriptor   ltdLight descriptor   gdGeneric descriptor.  If present, cd and gbx are taken from 		here if contained.   refl_fnString naming reflectance function to use.  Default is 			'pht_refl_minneart'.   phase_fnString naming phase function to use.  Default is none.   refl_parmphase_parmemm_outImage emission angles.   inc_outImage incidence angles.   phase_outImage phase angles.    overwriteIf set, the output descriptor is the input descriptor 			with the relevant fields modified.   ddData descriptor containing image to correct.    ", "NV/PG", " 	Written by:	Spitale, 1/2002 (pg_photom) 	 Spitale, 6/2004:	changed to pg_photom_globe   	New data descriptor containing the corrected image.  The photometric 	angles emm, inc, and phase are placed in the user data arrays with 	the tags'EMM', 'INC', and 'PHASE' respectively.  Unless /overwrite is 	set, the nw descriptor is a clone of the input descriptor, with the 	relevant fields modified.    STATUS: 	Complete    ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_profile_image.html", "pg_profile_image.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_profile_image.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_profile_image.html#pg_profile_image", "pg_profile_image", 'routine in <a href="com/pg/pg_profile_image.html">pg_profile_image.pro</a>', "pg_profile_image.pro", "", "pg_profile_image", "	Generates a dn profile along a line in an image.   ", "cdCamera descriptor.  Needed for sinc interpolation. (to get PSF)   gd  Optional generic descriptor containing cd.   distance Array giving the distance, in pixels, along the profile.   interp  Type of interpolation to use.  Options are:                'nearest', 'mean', 'bilinear', 'cubic', 'sinc'.   arg_interp  Arguments to pass to the interpolation function.    sigma  Array giving the standard deviation at each point in the 		profile.   profile  The profile.   image_pts Image point for each point along the profile.    bgUniform value to subtract from profile.   ddData descriptor.   outline_ptd  POINT giving the outline of the region to plot,                as produced by the pg_image_sector.   ", "NV/PG", "       Written by:     Spitale, 6/2005   	Two data descriptors: the first contains the profile; the second contains 	the profile sigma.    ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_profile_ring.html", "pg_profile_ring.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_profile_ring.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_profile_ring.html#pg_profile_ring", "pg_profile_ring", 'routine in <a href="com/pg/pg_profile_ring.html">pg_profile_ring.pro</a>', "pg_profile_ring.pro", "", "pg_profile_ring", "	Generates radial or longitudinal ring profiles from the given image 	using an image outline.   	The image points of the sector outline are first calculated.  If        /outline is selected then this is output.  If not, then the        /azimuthal keyword determines if this is a radius or longitude        profile.  The radius and longitude spacing for profile is then is        determined. If n_lon or n_rad is given, then these are used.  If not,        then the outline is used to determine the spacing in radius and        longitude so that the maximum spacing is a pixel.  If oversamp is        given then the number of samples is multiplied by this factor.        Then the image is sampled with this radius x longitude grid and        the dn interpolated with the routine image_interp at each point.        The dn's are then averaged along the requested profile direction.        If /bin keyword is selected then the image is not interpolated but        rather each pixel is binned in a histogram with the calculated        spacing.    ", "cdCamera descriptor.   dkx  Disk descriptor.   gd  Generic descriptor, if used, cd and dkx taken from it unless                overriden by cd and dkx arguments.   azimuthal  If set, the plot is longitudinal instead of radial.   sigma  Array giving the standard deviation at each point in the 		profile.   width  Array giving the width of the scan, in pixels along the                averaging direction, at each point in the profile.   nn  Number of image samples averaged into each profile point.   bin   If set, pixels in sector are binned according to                radius or longitude rather than dn averaged at equal                radius or longitude spacing   dsk_ptsArray of disk coordinates corresponding to each value in the 		returned dn profile.   im_ptsArray of image coordinates corresponding to each value in the 		returned dn profile.   interp   Type of interpolation to use: 'nearest', 'bilinear', 'cubic',                or 'sinc'.  'sinc' is the default.   arg_interp  Arguments to pass to the interpolation function.   profile  The profile.   bgUniform value to subtract from profile.   ddData descriptor.   outline_ptd   POINT giving the outline of the sector to plot,                       as produced by the pg_ring_sector.   ", "NV/PG", "       Written by:     Vance Haemmerle & Spitale, 6/1998 	Modified to use outline_ptd instead of (rad,lon): Spitale 5/2005        lon = [175.,177.]      rad = [65000000.,138000000.]      outline_ptd = pg_ring_sector(cd=cd, dkx=rd, rad=rad, lon=lon)      pg_draw, outline_ptd       profile = pg_profile_ring(dd, cd=cd, dkx=rd, $                                           outline_ptd, dsk_pts=dsk_pts)      window, /free, xs=500, ys=300      plot, dsk_pts[*,0], profile 	Two data descriptors: the first contains the profile; the second contains 	the profile sigma.    ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_ptassoc.html", "pg_ptassoc.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_ptassoc.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_ptassoc.html#pg_ptassoc", "pg_ptassoc", 'routine in <a href="com/pg/pg_ptassoc.html">pg_ptassoc.pro</a>', "pg_ptassoc.pro", "", "pg_ptassoc", "	Associates points between two arrays by searching for the most 	frequent offset between the two.    	Points are associated by searching for the most frequent offset 	between scan points and model points.    STATUS: 	Complete    SEE ALSO: 	pg_cvscan, pg_cvscan_coeff, pg_ptscan, pg_ptscan_coeff, 	pg_cvchisq, pg_ptchisq, pg_threshold    ", "radiusdxymaxcountscan_ptdPOINT(s) containing first array, typically 			an array of candidate points detected in an image.   model_ptdPOINT(s) containing the second array, typically 			an array of computed model points.   assoc_model_ptd", "NV/PG", " 	Written by:	Spitale, 3/2004   	POINT containing an associated scan point for each output 	model point in assoc_model_ptd.    ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_ptchisq.html", "pg_ptchisq.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_ptchisq.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("com/pg/pg_ptcntrd.html", "pg_ptcntrd.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_ptcntrd.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_ptcntrd.html#pg_ptcntrd", "pg_ptcntrd", 'routine in <a href="com/pg/pg_ptcntrd.html">pg_ptcntrd.pro</a>', "pg_ptcntrd.pro", "", "pg_ptcntrd", "	Attempts to find points of highest correlation with a given model 	centered near given features in an image, then returns the centroid.    	xx    	Currently does not work for multiple time steps.    	For each visible object, a section of the image of size width +        the size of the model is extracted and sent to routine ptloc to        find the pixel offset with the highest correlation with the given        model. Then call astrolib routine cntrd to return centroid.    ", "model         Point spread model to be used in correlation.  If                        not given a default gaussian is used.   width         Width to search around expected point location.  If                        not given, a default width of 20 pixels is used.   edge          Distance from edge from which to ignore points.  If                        not given, an edge distance of 0 is used.   ccmin         If given, points are discarded if the correlation                        is below this value.   gdmax         If given, points are discarded if the gradiant of                        the correlation function is higher than this value.   dd	Data descriptor   object_ptd	Array (n_pts) of POINT giving the points. 			Only the image coordinates of the points need to be 			specified.   ", "NV/PG", " 	Written by:	Haemmerle, 5/1998   	To find stellar positions with a correlation higher than 0.6...         star_ptd=pg_center(bx=sd, gd=gd) & pg_hide, star_ptd, gd=gd, /rm        ptscan_ptd=pg_ptscan(dd, star_ptd, edge=30, width=40, ccmin=0.6)   SEE ALSO: 	ptscan, pg_ptscan   STATUS: 	Complete. 	An array of type POINT giving the detected position for        each object.  The correlation coeff values for each detection is        saved in the data portion of POINT with tag 'scan_cc'.        The x and y offset from the given position is also saved.    ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_ptfarscan.html", "pg_ptfarscan.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_ptfarscan.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_ptfarscan.html#pg_ptfarscan", "pg_ptfarscan", 'routine in <a href="com/pg/pg_ptfarscan.html">pg_ptfarscan.pro</a>', "pg_ptfarscan.pro", "", "pg_ptfarscan", "	Attempts to find all occurrences of a model in an image.    ", "namemodel         Point spread model to be used in correlation.  If                        not given a default gaussian is used.   edge          Distance from edge from which to ignore points.  If                        not given, an edge distance of 0 is used.   ccmin         Minimum correlation to consider in search.  Default 			is 0.8.   gdmax         If given, points where the gradient of the                        correlation function is higher than this value 			are not considered in the search.   smooth	If given, the input image is smoothed using 			this width before any further processing.   wmod	x, ysize of default gaussian model.   wpsf	Half width of default gaussian psf model.   sky	If set, it is assumed that the image contains only 			point sources and sky.  Any object more than nsig 			standard deviations above the image mean are 			selected as candidates.   nsig	For use with the /sky option, standard deviation 			threshold for detecting point sources.   median	If given, the input image is filtered using 			a median filter of this width before any further 			processing.   mask	If set, an attempt is made to mask out extended 			objects before performing the scan   extend	If nonzero, star masks are extended by this 			many pixels in all directions.   nmax	Max. number of point sources to return.  If more 			are found, nsig is raised until thiws is satisified.   chifitdd	Data descriptor   ", "NV/PG", " 	Written by:	Spitale 2/2004   	An array of type POINT giving the detected position for        each object.  The correlation coeff value for each detection is        saved in the data portion of POINT with tag 'scan_cc'.    SEE ALSO: 	pg_ptscan   STATUS: 	Complete.    ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_ptscan.html", "pg_ptscan.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_ptscan.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_ptscan.html#pg_ptscan", "pg_ptscan", 'routine in <a href="com/pg/pg_ptscan.html">pg_ptscan.pro</a>', "pg_ptscan.pro", "", "pg_ptscan", "	Attempts to find points of highest correlation with a given model 	centered near given features in an image.    	Currently does not work for multiple time steps, only considers 	one point per given POINT.    	For each visible object, a section of the image of size width +        the size of the model is extracted and sent to routine ptloc to        find the pixel offset with the highest correlation with the given        model.    ", "model         Point spread model to be used in correlation.  If                        not given a default gaussian is used.   radius	Width outside of which to exclude detections whose 			offset varies too far from the most frequent offset. 			Detections with offsets outside this radius receive 			correlation coefficients of zero.   width         Width to search around expected point location.  If                        not given, a default width of 20 pixels is used.   edge          Distance from edge from which to ignore points.  If                        not given, an edge distance of 0 is used.   ccmin         If given, points are discarded if the correlation                        is below this value.   gdmax         If given, points are discarded if the gradiant of                        the correlation function is higher than this value.   smooth	If given, the input image is smoothed using 			this width before any further processing.   showwmod	x, ysize of default gaussian model.   wpsf	Half-width of default gaussian psf model.   median	If given, the input image is filtered using 			a median filter of this width before any further 			processing.   chisqmaxMax chisq between the model and the image.   cc_outroundspikedd	Data descriptor   object_ptd	Array (n_pts) of POINT giving the points. 			Only the image coordinates of the points need to be 			specified.   ", "NV/PG", " 	Written by:	Haemmerle, 5/1998 	Modified:	Spitale 9/2002 -- added twice model width to search 			width.   	To find stellar positions with a correlation higher than 0.6...         star_ptd=pg_center(bx=sd, gd=gd) & pg_hide, star_ptd, gd=gd, /rm        ptscan_ptd=pg_ptscan(dd, star_ptd, edge=30, width=40, ccmin=0.6)   SEE ALSO: 	pg_ptfarscan   STATUS: 	Complete. 	An array of type POINT giving the detected position for        each object.  The correlation coeff value for each detection is        saved in the data portion of POINT with tag 'scan_cc'.        The x and y offset from the given position is also saved.    ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_ptscan_coeff.html", "pg_ptscan_coeff.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_ptscan_coeff.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("com/pg/pg_put_arrays.html", "pg_put_arrays.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_put_arrays.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_put_arrays.html#pg_put_arrays", "pg_put_arrays", 'routine in <a href="com/pg/pg_put_arrays.html">pg_put_arrays.pro</a>', "pg_put_arrays.pro", "", "pg_put_arrays", "	Outputs array descriptors through the translators.    	Translator-dependent.  The data descriptor may be affected.    	CameStarra descriptors are passed to the translators.  Any star 	keywords are used to override the corresponding quantities in the 	output descriptors.    STATUS: 	Complete    SEE ALSO: 	pg_put_planets, pg_put_rings, pg_put_cameras, pg_put_maps    ", "ardStar descriptors to output.  	arr_*:		All star override keywords are accepted.   odsddData descriptor.   trsString containing keywords and values to be passed directly 		to the translators as if they appeared as arguments in the 		translators table.  These arguments are passed to every 		translator called, so the user should be aware of possible 		conflicts.  Keywords passed using this mechanism take 		precedence over keywords appearing in the translators table.   @arr__keywords_tree.include", "NV/PG", " 	Written by:	Spitale, 3/2017   	NONE    ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_put_cameras.html", "pg_put_cameras.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_put_cameras.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_put_cameras.html#pg_put_cameras", "pg_put_cameras", 'routine in <a href="com/pg/pg_put_cameras.html">pg_put_cameras.pro</a>', "pg_put_cameras.pro", "", "pg_put_cameras", "	Outputs camera descriptors through the translators.    	Translator-dependent.  The data descriptor may be affected.    	Camera descriptors are passed to the translators.  Any camera 	keywords are used to override the corresponding quantities in the 	output descriptors.    STATUS: 	Complete    SEE ALSO: 	pg_put_planets, pg_put_rings, pg_put_stars, pg_put_maps    ", "cdCamera descriptors to output.  	cam_*:		All camera override keywords are accepted.   ddData descriptor.   trsString containing keywords and values to be passed directly 		to the translators as if they appeared as arguments in the 		translators table.  These arguments are passed to every 		translator called, so the user should be aware of possible 		conflicts.  Keywords passed using this mechanism take 		precedence over keywords appearing in the translators table.   @cam__keywords_tree.include", "NV/PG", " 	Written by:	Spitale, 1998   	NONE    ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_put_maps.html", "pg_put_maps.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_put_maps.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_put_maps.html#pg_put_maps", "pg_put_maps", 'routine in <a href="com/pg/pg_put_maps.html">pg_put_maps.pro</a>', "pg_put_maps.pro", "", "pg_put_maps", "	Outputs map descriptors through the translators.    	Translator-dependent.  The data descriptor may be affected.    	Map descriptors are passed to the translators.  Any map 	keywords are used to override the corresponding quantities in the 	output descriptors.    STATUS: 	Complete    SEE ALSO: 	pg_put_planets, pg_put_rings, pg_put_stars, pg_put_cameras    ", "mdMap descriptors to output.  	map_*:		All map override keywords are accepted.   ddData descriptor.   trsString containing keywords and values to be passed directly 		to the translators as if they appeared as arguments in the 		translators table.  These arguments are passed to every 		translator called, so the user should be aware of possible 		conflicts.  Keywords passed using this mechanism take 		precedence over keywords appearing in the translators table.   @map__keywords_tree.include", "NV/PG", " 	Written by:	Spitale, 1998   	NONE    ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_put_planets.html", "pg_put_planets.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_put_planets.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_put_planets.html#pg_put_planets", "pg_put_planets", 'routine in <a href="com/pg/pg_put_planets.html">pg_put_planets.pro</a>', "pg_put_planets.pro", "", "pg_put_planets", "	Outputs planet descriptors through the translators.    	Translator-dependent.  The data descriptor may be affected.    	Planet descriptors are passed to the translators.  Any planet 	keywords are used to override the corresponding quantities in the 	output descriptors.    STATUS: 	Complete    SEE ALSO: 	pg_put_cameras, pg_put_rings, pg_put_stars, pg_put_maps    ", "pdPlanet descriptors to output.  	plt_*:		All planet override keywords are accepted.   odsraw	If set, no aberration corrections are performed.   ddData descriptor.   trsString containing keywords and values to be passed directly 		to the translators as if they appeared as arguments in the 		translators table.  These arguments are passed to every 		translator called, so the user should be aware of possible 		conflicts.  Keywords passed using this mechanism take 		precedence over keywords appearing in the translators table.   @plt__keywords_tree.include", "NV/PG", " 	Written by:	Spitale, 1998   	NONE    ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_put_rings.html", "pg_put_rings.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_put_rings.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_put_rings.html#pg_put_rings", "pg_put_rings", 'routine in <a href="com/pg/pg_put_rings.html">pg_put_rings.pro</a>', "pg_put_rings.pro", "", "pg_put_rings", "	Outputs ring descriptors through the translators.    	Translator-dependent.  The data descriptor may be affected.    	Ring descriptors are passed to the translators.  Any ring 	keywords are used to override the corresponding quantities in the 	output descriptors.    STATUS: 	Complete    SEE ALSO: 	pg_put_planets, pg_put_cameras, pg_put_stars, pg_put_maps    ", "rdRing descriptors to output.  	rng_*:		All ring override keywords are accepted.   odsddData descriptor.   trsString containing keywords and values to be passed directly 		to the translators as if they appeared as arguments in the 		translators table.  These arguments are passed to every 		translator called, so the user should be aware of possible 		conflicts.  Keywords passed using this mechanism take 		precedence over keywords appearing in the translators table.   @rng__keywords_tree.include", "NV/PG", " 	Written by:	Spitale, 1998   	NONE    ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_put_stars.html", "pg_put_stars.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_put_stars.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_put_stars.html#pg_put_stars", "pg_put_stars", 'routine in <a href="com/pg/pg_put_stars.html">pg_put_stars.pro</a>', "pg_put_stars.pro", "", "pg_put_stars", "	Outputs star descriptors through the translators.    	Translator-dependent.  The data descriptor may be affected.    	CameStarra descriptors are passed to the translators.  Any star 	keywords are used to override the corresponding quantities in the 	output descriptors.    STATUS: 	Complete    SEE ALSO: 	pg_put_planets, pg_put_rings, pg_put_cameras, pg_put_maps    ", "sdStar descriptors to output.  	str_*:		All star override keywords are accepted.   odsddData descriptor.   trsString containing keywords and values to be passed directly 		to the translators as if they appeared as arguments in the 		translators table.  These arguments are passed to every 		translator called, so the user should be aware of possible 		conflicts.  Keywords passed using this mechanism take 		precedence over keywords appearing in the translators table.   @str__keywords_tree.include", "NV/PG", " 	Written by:	Spitale, 1998   	NONE    ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_put_stations.html", "pg_put_stations.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_put_stations.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_put_stations.html#pg_put_stations", "pg_put_stations", 'routine in <a href="com/pg/pg_put_stations.html">pg_put_stations.pro</a>', "pg_put_stations.pro", "", "pg_put_stations", "	Outputs station descriptors through the translators.    	Translator-dependent.  The data descriptor may be affected.    	CameStarra descriptors are passed to the translators.  Any star 	keywords are used to override the corresponding quantities in the 	output descriptors.    STATUS: 	Complete    SEE ALSO: 	pg_put_planets, pg_put_rings, pg_put_cameras, pg_put_maps    ", "stdStar descriptors to output.  	stn_*:		All star override keywords are accepted.   odsddData descriptor.   trsString containing keywords and values to be passed directly 		to the translators as if they appeared as arguments in the 		translators table.  These arguments are passed to every 		translator called, so the user should be aware of possible 		conflicts.  Keywords passed using this mechanism take 		precedence over keywords appearing in the translators table.   @stn__keywords_tree.include", "NV/PG", " 	Written by:	Spitale, 3/2017   	NONE    ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_range.html", "pg_range.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_range.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("com/pg/pg_ray.html", "pg_ray.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_ray.pro", "", "", "	Computes image points on each specified ray.    ", "", "          -1", " 	Written by:	Spitale, 9/2012   ");
  

libdata[libdataItem++] = new Array("com/pg/pg_reflection.html", "pg_reflection.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_reflection.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_reflection.html#pg_reflection", "pg_reflection", 'routine in <a href="com/pg/pg_reflection.html">pg_reflection.pro</a>', "pg_reflection.pro", "", "pg_reflection", "	Computes image coordinates of given inertial vectors projected onto 	surface of the given disks and globes with respect to the given 	observer.  Returns only the closest reflection point for each objoect 	point.    ", "cdArray (n_timesteps) of camera descriptors.   odArray (n_timesteps) of descriptors of objects 		which must be a subclass of BODY.  These objects are used 		as the source from which points are projected.  If no observer 		descriptor is given, then the light descriptor in gd is used. 		Only one observer is allowed.   dkxArray (n_disks, n_timesteps) of descriptors of objects 		which must be a subclass of DISK.   gbxArray (n_globes, n_timesteps) of descriptors of objects 		which must be a subclass of GLOBE.   bxArray (n_disks, n_timesteps) of descriptors of objects 		which must be a subclass of BODY.   ddData descriptor containing a generic descriptor to use 		if gd not given.  	  All other keywords are passed directly to pg_reflection_globe 	  and pg_reflection_disk and are documented with those programs.   gdGeneric descriptor.  If given, the descriptor inputs 		are taken from this structure if not explicitly given.   revealclipnocullallobject_ptdArray of POINT containing inertial vectors.   ", "NV/PG", " 	Written by:	Spitale, 6/2016   	Array (n_disks,n_objects) of POINT containing image 	points and the corresponding inertial vectors.    STATUS: 	Soon to be replaced by a new program that merges pg_reflection_globe and 	pg_reflection_disk.  The API for the new routine may be slightly different.    SEE ALSO: 	pg_reflection_disk, pg_reflection_globe, pg_reflection_points    ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_reflection_disk.html", "pg_reflection_disk.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_reflection_disk.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_reflection_disk.html#pg_reflection_disk", "pg_reflection_disk", 'routine in <a href="com/pg/pg_reflection_disk.html">pg_reflection_disk.pro</a>', "pg_reflection_disk.pro", "", "pg_reflection_disk", "	Computes image coordinates of given inertial vectors reflected onto 	surface of the given disk with respect to the given observer.    ", "cdArray (n_timesteps) of camera descriptors.   odArray (n_timesteps) of descriptors of objects 		which must be a subclass of BODY.  These objects are used 		as the source from which points are projected.  If no observer 		descriptor is given, then the camera descriptor in gd is used. 		Only one observer is allowed.   dkxArray (n_disks, n_timesteps) of descriptors of objects 		which must be a subclass of DISK.   ddData descriptor containing a generic descriptor to use 		if gd not given.   gdGeneric descriptor.  If given, the descriptor inputs 		are taken from this structure if not explicitly given.   nocullall_ptdreveal Normally, disks whose opaque flag is set are ignored. 		 /reveal suppresses this behavior.   clip If set reflection points are cropped to within this many camera 		 fields of view.   cull If set, POINT objects excluded by the clip keyword 		 are not returned.  Normally, empty POINT objects 		 are returned as placeholders.   object_ptdArray of POINT containing inertial vectors.   ", "NV/PG", " 	Written by:	Spitale, 1/2002   ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_reflection_globe.html", "pg_reflection_globe.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_reflection_globe.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_reflection_globe.html#pg_reflection_globe", "pg_reflection_globe", 'routine in <a href="com/pg/pg_reflection_globe.html">pg_reflection_globe.pro</a>', "pg_reflection_globe.pro", "", "pg_reflection_globe", "	Computes image coordinates of the given inertial vectors projected onto 	surface of the given globe with respect to the given observer.    ", "cdArray (n_timesteps) of camera descriptors.   odArray (n_timesteps) of descriptors of objects 		which must be a subclass of BODY.  These objects are used 		as the source from which points are projected.  If no observer 		descriptor is given, then the light descriptor in gd is used. 		Only one observer is allowed.   gbxArray (n_globes, n_timesteps) of descriptors of objects 		which must be a subclass of GLOBE.   ddData descriptor containing a generic descriptor to use 		if gd not given.   gdGeneric descriptor.  If given, the descriptor inputs 		are taken from this structure if not explicitly given.   nocullreveal Normally, disks whose opaque flag is set are ignored. 		 /reveal suppresses this behavior.   clip If set reflection points are cropped to within this many camera 		 fields of view.   cull If set, POINT objects excluded by the clip keyword 		 are not returned.  Normally, empty POINT objects 		 are returned as placeholders.   nosolveIf set, reflection points are not computed.   object_ptdArray of POINT containing inertial vectors.   ", "NV/PG", " 	Written by:	Spitale, 6/2016   	Array (n_globes,n_objects) of POINT containing image 	points and the corresponding inertial vectors.    STATUS: 	Soon to be obsolete.  This program will be merged with pg_reflection_disk 	to make a more general program, which will replace pg_reflection.    SEE ALSO: 	pg_reflection, pg_reflection_disk, pg_reflection_points    ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_render.html", "pg_render.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_render.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_render.html#pg_render", "pg_render", 'routine in <a href="com/pg/pg_render.html">pg_render.pro</a>', "pg_render.pro", "", "pg_render", "	Performs rendering on an array of bodies.        ", "cd      Camera descriptor.   ltd        Star descriptor for the Sun.   bx      Array of object descriptors; must be a subclass of BODY.   ddmap       Array of data descriptors containing the body maps, 	              one for each body.  If not given, maps are loaded using 		      pg_load_maps.   md          Array of map descriptors for each ddmap.   dd	Data descriptor containing a generic descriptor to use 			if gd not given.   gd	Generic descriptor.  If given, the descriptor inputs 			are taken from this structure if not explicitly given.   sample      Amount by which to subsample pixels.   pc_size     To save memory, the projection is performed in pieces 	              of this size.  Default is 65536.   showpht_min     Minimum value to assign to photometric output.    no_phtmap       2-D array containing the rendered scene.    standoff    If given, secondary vectors are advanced by this distance 	              before tracing in order to avoid hitting target bodies 	              through round-off error.   limit_sourceIf set, secondary vectors originating on a given 	              body are not considered for targets that are the 	              same body.  Default is on.   nodd        If set, no data descrptor is produced.  The return value 	              is zero and the rendering is returned via the IMAGE 	              keyword.   psf         If set, the rendering is convolved with a point-spread 	              function.  If /psf, then the PSF is obtained via cd; if 	              psf is a 2D array, then is is used as the PSF.   npsf        Width of psf array to use if PSF is obtained via cd. 	              Default is 10.   penumbra    If set, lighting rays are traced to random points on 	              each secondary body rather then the center.   no_secondaryIf set, no secondary ray tracing is performed, 	              resulting in no shadows.   image_ptd   POINT or array with image points 	              specifying the grid to trace.  If not set, the entire 	              image described by cd is used.  The array can have 	              dimensions of (2,np) or (2,nx,ny).  If the latter, 	              the output map will have dimensions (nx,ny).  Note 	              that a PSF cannot be applied if nx and ny are not known.   mask_width  Width of trace mask.  Default is 512.  If set to zero, 	              no masking is performed.   no_maps     If set, maps are not loaded.   ", "NV/PG", " 	Written by:	Spitale      STATUS: 	Complete 	Data descriptor containing the rendered image.    ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_renderfit.html", "pg_renderfit.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_renderfit.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("com/pg/pg_repoint.html", "pg_repoint.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_repoint.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_repoint.html#pg_repoint", "pg_repoint", 'routine in <a href="com/pg/pg_repoint.html">pg_repoint.pro</a>', "pg_repoint.pro", "", "pg_repoint", "	Modifies the camera orientation matrix based on the given image 	coordinate translation and rotation.    	pg_repoint adds its name to the task list of each given camera 	descriptor.    STATUS: 	Complete    SEE ALSO: 	pg_fit, pg_drag    ", "cd If given, the camera descriptor is modified with a new 		 orientation matrix.   gd If given in this way, the camera descriptor contained in the 		 generic descriptor is modified with a new orientation matrix.    axis_ptdPOINT containing a single image point 		 to be used as the axis of rotation.  Default is the camera 		 optic axis.   bore_cd Array (nt) of camera descriptors from which to copy the 		  new orientation instead of using dxy, dtheta, and axis_ptd.   bore_rotIf given, the orientation from bore_cd will be rotated 		  using this rotation matrix (3,3) before being copied.   bore_dxyBoresight offset in pixels.   absoluteIf set, the dxy argument represents an absolute image 		  position rather than an offset.   _arg	Array (2,1,nt) or (2,1) specifying the translation as 			[dx,dy] in pixels.  				or  			Array of POINT objects; mainly useful with the /absolute 			option.  				or  			Array of new pointing vectors (1,3,nt).   _dtheta	Array (nt) specfying the rotation angle in radians.   ", "NV/PG", " 	Written by:	Spitale, 2/1998   ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_repos.html", "pg_repos.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_repos.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_repos.html#pg_repos", "pg_repos", 'routine in <a href="com/pg/pg_repos.html">pg_repos.pro</a>', "pg_repos.pro", "", "pg_repos", "	Modifies the body position based on the given offset and observer.    	pg_repos modifies bx and adds its name to the task list of each given 	descriptor.    STATUS: 	Complete    ", "bx   Array (nt) of body descriptors to translate.   od   Observer descriptor; specifies the body frame for the 		   translation vector.   ref_bx  Body descriptor giving reference position for directional 		   keywords.   dd   Data descriptor containing a generic descriptor to use 		   if gd not given.   gd   Generic descriptor.  If given, the descriptor inputs 		   are taken from this structure if not explicitly given.   toward   Body should be translated toward ref_bx (default).   away     Body should be translated away from ref_bx.   at       Body should be placed at the position of ref_bx.   along    Index of bx axis along which to translate.    _dv	Array (nv,3,nt) specifying the translation vector. 			The components are assumed to be given wrt to the 			inertial frame unless od is given.  In that case 			dv is interpreted as a vector in the body frame of od.  			For convenience, if dv is given in the nonstandard form 			of a 3-element array, it is reinterpreted as a column 			vector (1,3).  			If ref_bx is given, then dv is interpreted as a distance 			and the direction is constructed from one of the directional 			keywords below.   ", "NV/PG", " 	Written by:	Spitale, 3/2007   ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_resfit.html", "pg_resfit.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_resfit.pro", "", "", "	Computes polynomial coefficients for a camera distortion model by 	comparing detected reseaus with the known focal plane locations.    	First, candidate reseaus are associated with nominal reseaus by 	choosing the candidate with the highest correlation coefficient 	within a given number of pixels surrounding each known reseau.  	Next, coefficients for a polynomial of order n are derived using a 	least-squares fit.    STATUS: 	Complete    SEE ALSO: 	pg_resloc, pg_linearize_image, pg_blemish    ", "", "          -1", " 	Written by:	Spitale, 5/2002   ");
  

libdata[libdataItem++] = new Array("com/pg/pg_residuals.html", "pg_residuals.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_residuals.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("com/pg/pg_resloc.html", "pg_resloc.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_resloc.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_resloc.html#pg_resloc", "pg_resloc", 'routine in <a href="com/pg/pg_resloc.html">pg_resloc.pro</a>', "pg_resloc.pro", "", "pg_resloc", "	Scans an image for candidate reseau marks.    	A correlation map is computed across image.  Candidates reseau marks 	are identified as local maxima in the correlation map by accepting 	points where the correlation is above the specified threshold and 	where the gradient of the correlation map is below the specified 	threshold.    STATUS: 	Complete    SEE ALSO: 	pg_resfit, modloc    ", "edge Distance from edge within which points are ignored.   model 2-D array giving a model of the reseau image.  Default model 		is an inverted Gaussian.   ccmin Minimum correlation coefficient to accept.  Default is 0.8 .   gdmax Maximum gradiant of correlation coefficient to accept. 		Default is 0.25   nom_ptdIf given, reseau marks are searched for only within the 		given radius about each nominal point.   radiusRadius about no_ptd to search.  Default is ten pixels.   ddData descriptor containing the image to scan.   ", "NV/PG", " 	Written by:	Spitale, 1998   	Points structure containing the image coordinates of each candidiate 	reseau mark and the corresponding correlation coefficients.  If not 	marks are found, zero is returned.    ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_retarg.html", "pg_retarg.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_retarg.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("com/pg/pg_ring_sector.html", "pg_ring_sector.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_ring_sector.pro", "", "", "	Allows the user to select a ring sector by clicking and dragging. 	With the left button, the sector is defined along lines of constant 	radius and longitude.  With the right button, the sides of the sector 	are perpendicular to the projected radial direction.   ", "", "          -1", "");
  

libdata[libdataItem++] = new Array("com/pg/pg_ring_sector_box.html", "pg_ring_sector_box.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_ring_sector_box.pro", "", "", "	Allows the user to select a box to use with pg_profile_ring.   ", "", "          -1", "");
  

libdata[libdataItem++] = new Array("com/pg/pg_ring_sector_box_oblique.html", "pg_ring_sector_box_oblique.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_ring_sector_box_oblique.pro", "", "", "	Allows the user to select an oblique box to use with pg_profile_ring.   ", "", "          -1", "");
  

libdata[libdataItem++] = new Array("com/pg/pg_ring_sector_box_ortho.html", "pg_ring_sector_box_ortho.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_ring_sector_box_ortho.pro", "", "", "	Allows the user to select a box to use with pg_profile_ring.   ", "", "          -1", "");
  

libdata[libdataItem++] = new Array("com/pg/pg_ring_sector_oblique.html", "pg_ring_sector_oblique.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_ring_sector_oblique.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_ring_sector_oblique.html#pg_ring_sector_oblique", "pg_ring_sector_oblique", 'routine in <a href="com/pg/pg_ring_sector_oblique.html">pg_ring_sector_oblique.pro</a>', "pg_ring_sector_oblique.pro", "", "pg_ring_sector_oblique", "	Allows the user to select a ring sector by clicking and dragging. 	The top and bottom of the sector are defined along lines of constant 	radius, while the sides are perpendicular to the image-projected 	radial direction.   ", "cd    Camera descriptor.   dkx    Disk descriptor describing the ring.   gd    Generic descriptor containnig the above descriptors.   lonsample    Grid sampling, default is 1.   win_num    Window number of IDL graphics window in which to select                    box, default is current window.   restore    Do not leave the box in the image.   slope    This keyword allows the longitude to vary from the                    perpendicular direction as a function of radius as:                    lon = slope*(rad - rad0).   p0    First corner of box.  If set, then the routine immediately                    begins to drag from that point until a button is released.   xor_graphics    If set, the sector outline is drawn and erased using xor                    graphics instead of a pixmap.   color    Color to use for rectangle, default is !color.   silent    If set, messages are suppressed.   nodsk    If set, image points will not be included in the output                    POINT.   ", "NV/PG", "      POINT containing points on the sector outline.  The point       spacing is determined by the sample keyword.  The POINT object       also contains the disk coordinate for each point and the user fields       'nrad' and 'nlon' giving the number of points in radius and longitude.   KNOWN BUGS: 	The sector flips when it hits zero azimuth rather than retaining a 	consistent sense.    ORIGINAL AUTHOR : J. Spitale ; 5/2005   ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_ring_sector_perp.html", "pg_ring_sector_perp.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_ring_sector_perp.pro", "", "", "	Allows the user to select a ring sector by clicking and dragging. 	The top and bottom of the sector are defined along lines of constant 	radius, while the sides are perpendicular to the image-projected 	radial direction.   ", "", "          -1", "");
  

libdata[libdataItem++] = new Array("com/pg/pg_ring_sector_rad.html", "pg_ring_sector_rad.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_ring_sector_rad.pro", "", "", "	Allows the user to select a ring sector by clicking and dragging. 	The sector is defined along lines of constant radius and longitude.   ", "", "          -1", "");
  

libdata[libdataItem++] = new Array("com/pg/pg_ring_sector_radlon.html", "pg_ring_sector_radlon.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_ring_sector_radlon.pro", "", "", "	Constructs a ring sector outline for use with pg_profile_ring given 	radius and longitude bounds.   ", "", "          -1", "");
  

libdata[libdataItem++] = new Array("com/pg/pg_rm_points.html", "pg_rm_points.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_rm_points.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("com/pg/pg_select.html", "pg_select.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_select.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("com/pg/pg_select_bodies.html", "pg_select_bodies.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_select_bodies.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("com/pg/pg_select_points.html", "pg_select_points.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_select_points.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_select_points.html#pg_select_points", "pg_select_points", 'routine in <a href="com/pg/pg_select_points.html">pg_select_points.pro</a>', "pg_select_points.pro", "", "pg_select_points", "	Allows the user to select points in an image using the mouse.    ", "psym		Plotting symbol to use for the points.   noverbose	If set, turns off the notification that cursor 			movement is required.   color	Color to use for graphics overlays.   p0	Initial point, instead of user selection.   one	If set, the routine will exit after selecting one point.   number	If set, each point will be labeled with a number.   cancelledSet if routine is caused to return by the cancel button.    ptd_outputIf set, a POINT object is returned instead 			of a points array.   ddData descriptor containing the image.   ", "NV/PG", " 	Written by:	Spitale, 9/2001      To print the coordinates of each point as the user selects them, use:     can=0 & while(NOT can) do print, pg_select_points(dd, /one, /nov, can=can)    STATUS: 	Complete 	Array of image points (2,n).    ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_select_region.html", "pg_select_region.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_select_region.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_select_region.html#pg_select_region", "pg_select_region", 'routine in <a href="com/pg/pg_select_region.html">pg_select_region.pro</a>', "pg_select_region.pro", "", "pg_select_region", "	Allows the user to select regions in an image using the mouse.    ", "color	Color to use for graphics overlays.    select_buttonIndex of button to use as the select button instead 			of the left button (1).   cancel_buttonIndex of mouse button to be used as a cancel 			button instead of left+middle, (3).   end_buttonIndex of button to use as the end button instead 			of the right button (4).   silent	If set, turns off the notification that cursor 			movement is required.   p0	First point of line.  If set, then the routine 			immediately begins to drag from that point until a 			button is released.   autocloseIf set, the region is automaticaly closed when the 			end button is pressed.   points	If set, the selected points are returned instead 			of enclosed indices.   noclosedatabox	If set, a rectanguar region is selected.    image_ptsddData descriptor containing an image.   ", "NV/PG", " 	Written by:	Spitale, 2/1998   	Array of subscripts of all image points which lie within the selected 	region.  -1 is returned if the cancel button is pressed.    STATUS: 	Complete    SEE ALSO: 	pg_trim    ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_shadow.html", "pg_shadow.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_shadow.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_shadow.html#pg_shadow", "pg_shadow", 'routine in <a href="com/pg/pg_shadow.html">pg_shadow.pro</a>', "pg_shadow.pro", "", "pg_shadow", "	Computes image coordinates of given inertial vectors projected onto 	surface of the given disks and globes with respect to the given 	observer.  Returns only the closest shadow point for each objoect 	point.    ", "cdArray (n_timesteps) of camera descriptors.   odArray (n_timesteps) of descriptors of objects 		which must be a subclass of BODY.  These objects are used 		as the source from which points are projected.  If no observer 		descriptor is given, then the light descriptor in gd is used. 		Only one observer is allowed.   dkxArray (n_disks, n_timesteps) of descriptors of objects 		which must be a subclass of DISK.   gbxArray (n_globes, n_timesteps) of descriptors of objects 		which must be a subclass of GLOBE.   bxArray (n_disks, n_timesteps) of descriptors of objects 		which must be a subclass of BODY.   ddData descriptor containing a generic descriptor to use 		if gd not given.  	  All other keywords are passed directly to pg_shadow_globe 	  and pg_shadow_disk and are documented with those programs.   gdGeneric descriptor.  If given, the descriptor inputs 		are taken from this structure if not explicitly given.   revealclipnocullallepsilonnosolveobject_ptdArray of POINT containing inertial vectors.   ", "NV/PG", " 	Written by:	Spitale, 1/2002   	Array (n_disks,n_objects) of POINT containing image 	points and the corresponding inertial vectors.    STATUS: 	Soon to be replaced by a new program that merges pg_shadow_globe and 	pg_shadow_disk.  The API for the new routine may be slightly different.    SEE ALSO: 	pg_shadow_disk, pg_shadow_globe, pg_shadow_points    ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_shadow_disk.html", "pg_shadow_disk.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_shadow_disk.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_shadow_disk.html#pg_shadow_disk", "pg_shadow_disk", 'routine in <a href="com/pg/pg_shadow_disk.html">pg_shadow_disk.pro</a>', "pg_shadow_disk.pro", "", "pg_shadow_disk", "	Computes image coordinates of given inertial vectors projected onto 	surface of the given disk with respect to the given observer.    ", "cdArray (n_timesteps) of camera descriptors.   odArray (n_timesteps) of descriptors of objects 		which must be a subclass of BODY.  These objects are used 		as the source from which points are projected.  If no observer 		descriptor is given, then the light descriptor in gd is used. 		Only one observer is allowed.   dkxArray (n_disks, n_timesteps) of descriptors of objects 		which must be a subclass of DISK.   ddData descriptor containing a generic descriptor to use 		if gd not given.   gdGeneric descriptor.  If given, the descriptor inputs 		are taken from this structure if not explicitly given.   nocullreveal Normally, disks whose opaque flag is set are ignored. 		 /reveal suppresses this behavior.   clip If set shadow points are cropped to within this many camera 		 fields of view.   cull If set, POINT objects excluded by the clip keyword 		 are not returned.  Normally, empty POINT objects 		 are returned as placeholders.   allepsilonobject_ptdArray of POINT containing inertial vectors.   ", "NV/PG", " 	Written by:	Spitale, 1/2002   	Array (n_disks,n_objects) of POINT containing image 	points and the corresponding inertial vectors.    STATUS: 	Soon to be obsolete.  This program will be merged with pg_shadow_globe 	to make a more general program, which will replace pg_shadow.    SEE ALSO: 	pg_shadow, pg_shadow_globe, pg_shadow_points    ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_shadow_globe.html", "pg_shadow_globe.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_shadow_globe.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_shadow_globe.html#pg_shadow_globe", "pg_shadow_globe", 'routine in <a href="com/pg/pg_shadow_globe.html">pg_shadow_globe.pro</a>', "pg_shadow_globe.pro", "", "pg_shadow_globe", "	Computes image coordinates of the given inertial vectors projected onto 	surface of the given globe with respect to the given observer.    ", "cdArray (n_timesteps) of camera descriptors.   odArray (n_timesteps) of descriptors of objects 		which must be a subclass of BODY.  These objects are used 		as the source from which points are projected.  If no observer 		descriptor is given, then the light descriptor in gd is used. 		Only one observer is allowed.   gbxArray (n_globes, n_timesteps) of descriptors of objects 		which must be a subclass of GLOBE.   ddData descriptor containing a generic descriptor to use 		if gd not given.   gdGeneric descriptor.  If given, the descriptor inputs 		are taken from this structure if not explicitly given.   nocullreveal Normally, disks whose opaque flag is set are ignored. 		 /reveal suppresses this behavior.   clip If set shadow points are cropped to within this many camera 		 fields of view.   cull If set, POINT objects excluded by the clip keyword 		 are not returned.  Normally, empty POINT objects 		 are returned as placeholders.   nosolveIf set, shadow points are not computed.   object_ptdArray of POINT containing inertial vectors.   ", "NV/PG", " 	Written by:	Spitale, 1/2002   	Array (n_globes,n_objects) of POINT containing image 	points and the corresponding inertial vectors.    STATUS: 	Soon to be obsolete.  This program will be merged with pg_shadow_disk 	to make a more general program, which will replace pg_shadow.    SEE ALSO: 	pg_shadow, pg_shadow_disk, pg_shadow_points    ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_shadow_points.html", "pg_shadow_points.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_shadow_points.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_shadow_points.html#pg_shadow_points", "pg_shadow_points", 'routine in <a href="com/pg/pg_shadow_points.html">pg_shadow_points.pro</a>', "pg_shadow_points.pro", "", "pg_shadow_points", "	Determines whether each given point is shadowed by the given object.    	Shadowed points are flagged as invisible.    STATUS:     SEE ALSO: 	pg_shadow, pg_shadow_globe, pg_shadow_disk    ", "cdArray (n_timesteps) of camera descriptors.   odArray (n_timesteps) of descriptors of objects 		which must be a subclass of BODY.  These objects are used 		as the source from which points are projected.  If no observer 		descriptor is given, then the light descriptor in gd is used. 		Only one observer is allowed.   bxArray (nbx, n_timesteps) of descriptors of objects 		which must be a subclass of BODY describing the shadowing 		bodies.   gdGeneric descriptor.  If given, the cd and bx inputs 		are taken from the corresponding fields of this structure 		instead of from those keywords.   noculledge If set, only points near the edge of the shadow are returned.   nosolveclip If set shadow points are cropped to within this many camera 		 fields of view.   cull If set, POINT objects excluded by the clip keyword 		 are not returned.  Normally, empty POINT objects 		 are returned as placeholders.   object_ptdArray of POINT containing inertial vectors 			to shadow.   shadow_ptd", "NV/PG", " 	Written by:	Spitale, 9/2012   	shadow_ptd:	Array of POINT containing the shadowed 			points.    ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_shift.html", "pg_shift.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_shift.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("com/pg/pg_sort_args.html", "pg_sort_args.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_sort_args.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_sort_args.html#pg_sort_args", "pg_sort_args", 'routine in <a href="com/pg/pg_sort_args.html">pg_sort_args.pro</a>', "pg_sort_args.pro", "", "pg_sort_args", "	Sorts arguments to pg_get_* programs.    ", "ddodtimetrsfreearg1arg2@dat__keywords_tree.include", "NV/PG", " 	Written by:	Spitale, 7/2017   	dd:	Data descriptor.  If none given, one is created using the 		DATA keywords (see below).  	od:	Observer descriptor.  If no dd given, then thi descriptor 		is used to determine the number of dd to create.  	time:	Observation time.  If no dd or od given, then this array 		is used to determine the number of dd to create.  	trs:	Transient arguments; Null string if not given.  	DATA Keywords 	------------- 	All DATA override keywords are accepted.  See dat__keywords.include. 	If the instrument keyword is no given, it is set to DEFAULT.    ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_spikes.html", "pg_spikes.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_spikes.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_spikes.html#pg_spikes", "pg_spikes", 'routine in <a href="com/pg/pg_spikes.html">pg_spikes.pro</a>', "pg_spikes.pro", "", "pg_spikes", "	Locates spurious features like cosmic-ray hits.     	Clusters of hot pixels of size 'scale' are identified by looking 	for regions bounded by large gradients.  Each cluster is then 	examined for pixels whose values are larger than nsig standard 	deviations above the local mean.    STATUS: 	Complete    SEE ALSO: 	pg_despike, pg_mask    ", "nsig	Number of standard deviations above the local 			mean data value to flag for removal.  Default is 2.   grad	Minimum data value gradient to use when searching 			for clusters of hot pixels.  Default is 5.   maskumask	Byte image of the same size as the input image 			in which nonzero pixel values indicate locations 			where spikes should not be flagged.   extend	Number of pixels away from masked pixels before 			locations may be flagged as spikes.   scale	Typical size of objects to be flagged.  Default is 10.   edge	Regions closer than this to the edge of the image 			will be ignored.  Default is 10.   local	Multiplier that determines the width of the region 			over which the local mean and standard deviation are 			taken.  That width is local * scale.  Default is 5.   nohotallpix	If set, all pixels in the spike region are returned 			instead of of the centroids.   dd	Data descriptor containing the image to be despiked.   ", "NV/PG", " 	Written by:	Spitale, 4/2005   	dd = dat_read(filename) 	spike_ptd = pg_spikes(dd) 	dd1 = pg_despike(dd, spike_ptd) 	POINT containing the detected spike points.    ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_station.html", "pg_station.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_station.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_station.html#pg_station", "pg_station", 'routine in <a href="com/pg/pg_station.html">pg_station.pro</a>', "pg_station.pro", "", "pg_station", "	Computes image points for given station descriptors.    ", "cdArray (n_timesteps) of camera descriptors.   stdArray (n_objects, n_timesteps) of descriptors of objects 		that must be a subclass of STATION.   gbxArray (n_xd, n_timesteps) of descriptors of objects 		that must be a subclass of GLOBE.   dkxArray (n_xd, n_timesteps) of descriptors of objects 		that must be a subclass of DISK.   bxArray (n_xd, n_timesteps) of descriptors of objects 		that must be a subclass of BODY, instead of gbx or dkx.   ddData descriptor containing a generic descriptor to use 		if gd not given.   gdGeneric descriptor.  If given, the descriptor inputs 		are taken from this structure if not explicitly given.   clip If set points are computed only within this many camera 		 fields of view.   cull If set, POINT objects excluded by the clip keyword 		 are not returned.  Normally, empty POINT objects 		 are returned as placeholders.    ", "NV/PG", " 	Written by:	Spitale, 10/2012   	Array (n_objects) of POINT containing image points and 	the corresponding inertial vectors.    STATUS: 	Complete    ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_stereo_split.html", "pg_stereo_split.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_stereo_split.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("com/pg/pg_str_limit_mag.html", "pg_str_limit_mag.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_str_limit_mag.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("com/pg/pg_strip.html", "pg_strip.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_strip.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("com/pg/pg_sub_body.html", "pg_sub_body.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_sub_body.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("com/pg/pg_threshold.html", "pg_threshold.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_threshold.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("com/pg/pg_tiepoints.html", "pg_tiepoints.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_tiepoints.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("com/pg/pg_trim.html", "pg_trim.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_trim.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/tools/phase_correction.html", "phase_correction.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "phase_correction.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/tools/pixel_grid.html", "pixel_grid.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "pixel_grid.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/tools/plot_inertial.html", "plot_inertial.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "plot_inertial.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/plt/plt_assign.html", "plt_assign.pro", '.pro file in <a href="obj/plt/dir-overview.html">obj/plt/ directory</a>', "plt_assign.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/plt/plt_assign.html#plt_assign", "plt_assign", 'routine in <a href="obj/plt/plt_assign.html">plt_assign.pro</a>', "plt_assign.pro", "", "plt_assign", "	Replaces fields in a PLANET object.  This is a convenient way of 	setting multiple fields in one call, and only a single event is 	generated.    ", "noeventIf set, no event is generated.   xd@plt__keywords_tree.include", "NV/OBJ/PLT", " 	Written by:	Spitale		2/2017   ");
  
  

libdata[libdataItem++] = new Array("obj/plt/plt_create_descriptors.html", "plt_create_descriptors.pro", '.pro file in <a href="obj/plt/dir-overview.html">obj/plt/ directory</a>', "plt_create_descriptors.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/plt/plt_create_descriptors.html#plt_create_descriptors", "plt_create_descriptors", 'routine in <a href="obj/plt/plt_create_descriptors.html">plt_create_descriptors.pro</a>', "plt_create_descriptors.pro", "", "plt_create_descriptors", "	Init method for the PLANET class.    ", "crdCore descriptor(s) to pass to cor_create_descriptors.   bdBody descriptor(s) to pass to bod_create_descriptors.   sldSolid descriptor(s) to pass to sld_create_descriptors.   gbdGlobe descriptor(s) to pass to glb_create_descriptors.   pdPlanet descriptor(s) to initialize, instead of creating new ones.   n     Number of planet descriptors.   @plt__keywords_tree.include", "NV/LIB/PLT", " 	Written by:	Spitale, 1/1998  	Adapted by:	Spitale, 5/2016          An array (n) of planet descriptors.   STATUS:        Completed.    ");
  
  

libdata[libdataItem++] = new Array("obj/plt/plt_evolve.html", "plt_evolve.pro", '.pro file in <a href="obj/plt/dir-overview.html">obj/plt/ directory</a>', "plt_evolve.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/plt/plt_query.html", "plt_query.pro", '.pro file in <a href="obj/plt/dir-overview.html">obj/plt/ directory</a>', "plt_query.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/plt/plt_query.html#plt_query", "plt_query", 'routine in <a href="obj/plt/plt_query.html">plt_query.pro</a>', "plt_query.pro", "", "plt_query", "	Returns the fields associated with a PLANET object.  This is a 	convenient way of getting multiple fields in one call, and only a 	single event is generated.    ", "conditionStructure specifing a mask and a condition with which to 			match flag values.  The structure must contain the fields 			MASK and STATE.  MASK is a bitmask to test against 			the flags field of the POINT object, and STATE 			is either PS_TRUE and PS_FALSE.  Note that in this case, 			the values will be returned as a list, with no separation 			into nv and nt dimensions.   cat	If set, arrays from mulitple input objets are 			concatenated.  	<condition>:	All of the predefined conditions (e.g. /visible) are 			accepted; see pnt_condition_keywords.include.   noeventIf set, no event is generated.   xd@plt__keywords_tree.include", "NV/OBJ/PLT", " 	Written by:	Spitale, 2/2017   ");
  
  

libdata[libdataItem++] = new Array("obj/plt/plt_replicate.html", "plt_replicate.pro", '.pro file in <a href="obj/plt/dir-overview.html">obj/plt/ directory</a>', "plt_replicate.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/pnt/pnt_apply_condition.html", "pnt_apply_condition.pro", '.pro file in <a href="obj/pnt/dir-overview.html">obj/pnt/ directory</a>', "pnt_apply_condition.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/pnt/pnt_assign.html", "pnt_assign.pro", '.pro file in <a href="obj/pnt/dir-overview.html">obj/pnt/ directory</a>', "pnt_assign.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/pnt/pnt_assign.html#pnt_assign", "pnt_assign", 'routine in <a href="obj/pnt/pnt_assign.html">pnt_assign.pro</a>', "pnt_assign.pro", "", "pnt_assign", "	Replaces fields in a POINT object.  This is a convenient way of 	setting multiple fields in one call, and only a single event is 	generated.    ", "noeventIf set, no event is generated.   xd@pnt__keywords_tree.include", "NV/OBJ/PNT", " 	Written by:	Spitale		12/2015   ");
  
  

libdata[libdataItem++] = new Array("obj/pnt/pnt_assoc_xd.html", "pnt_assoc_xd.pro", '.pro file in <a href="obj/pnt/dir-overview.html">obj/pnt/ directory</a>', "pnt_assoc_xd.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/pnt/pnt_compress.html", "pnt_compress.pro", '.pro file in <a href="obj/pnt/dir-overview.html">obj/pnt/ directory</a>', "pnt_compress.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/pnt/pnt_condition.html", "pnt_condition.pro", '.pro file in <a href="obj/pnt/dir-overview.html">obj/pnt/ directory</a>', "pnt_condition.pro", "", "", "	Returns predefined condition structures for various common situations.    ", "", "          -1", "  	Spitale, 11/2015   ");
  

libdata[libdataItem++] = new Array("obj/pnt/pnt_create_descriptors.html", "pnt_create_descriptors.pro", '.pro file in <a href="obj/pnt/dir-overview.html">obj/pnt/ directory</a>', "pnt_create_descriptors.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/pnt/pnt_create_descriptors.html#pnt_create_descriptors", "pnt_create_descriptors", 'routine in <a href="obj/pnt/pnt_create_descriptors.html">pnt_create_descriptors.pro</a>', "pnt_create_descriptors.pro", "", "pnt_create_descriptors", "	Creates and initializes a POINT object.    ", "crdptdn@pnt__keywords_tree.include", "NV/OBJ/PNT", " 	Written by:	Spitale, 11/2015   	Newly created and initialized POINT object.    STATUS: 	Complete    ");
  
  

libdata[libdataItem++] = new Array("obj/pnt/pnt_cull.html", "pnt_cull.pro", '.pro file in <a href="obj/pnt/dir-overview.html">obj/pnt/ directory</a>', "pnt_cull.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/pnt/pnt_cull.html#pnt_cull", "pnt_cull", 'routine in <a href="obj/pnt/pnt_cull.html">pnt_cull.pro</a>', "pnt_cull.pro", "", "pnt_cull", "	Cleans out an array of POINT objects by removing POINT objects that are 	empty, or whose points all fail the specified conditions.    ", "nofree	If set, invalid POINT object are not freed.   condition_ptdArray of POINT objects.   @pnt_condition_keywords.include", "NV/OBJ/PNT", "  Spitale, 11/2015; 	Adapted from pgs_cull   	Array POINT objects, or 0 if all were empty.     ");
  
  

libdata[libdataItem++] = new Array("obj/pnt/pnt_data.html", "pnt_data.pro", '.pro file in <a href="obj/pnt/dir-overview.html">obj/pnt/ directory</a>', "pnt_data.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/pnt/pnt_data.html#pnt_data", "pnt_data", 'routine in <a href="obj/pnt/pnt_data.html">pnt_data.pro</a>', "pnt_data.pro", "", "pnt_data", "	Returns the point-by-point data associated with a POINT object.    ", "tagsIf given, data arrays are returned only for these tags, 		and are arranged in this order.   sample	Sampling interval in the nv direction.  Default is 1.  	<condition>:	All of the predefined conditions (e.g. /visible) are 			accepted; see pnt_condition_keywords.include.   cat	If set, arrays from mulitple input objets are 			concatenated.   conditionStructure specifing a mask and a condition with which to 			match flag values.  The structure must contain the fields 			MASK and STATE.  MASK is a bitmask to test against 			the flags field of the POINT object, and STATE 			is either PS_TRUE and PS_FALSE.  Note that in this case, 			the values will be returned as a list, with no separation 			into nv and nt dimensions.   noeventIf set, no event is generated.   ptd0@pnt_condition_keywords.include", "NV/OBJ/PNT", " 	Written by:	Spitale, 11/2015   	The point-by-point data associated with the POINT object.    STATUS: 	Complete    SEE ALSO: 	pnt_set_data     ");
  
  

libdata[libdataItem++] = new Array("obj/pnt/pnt_desc.html", "pnt_desc.pro", '.pro file in <a href="obj/pnt/dir-overview.html">obj/pnt/ directory</a>', "pnt_desc.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/pnt/pnt_explode.html", "pnt_explode.pro", '.pro file in <a href="obj/pnt/dir-overview.html">obj/pnt/ directory</a>', "pnt_explode.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/pnt/pnt_flags.html", "pnt_flags.pro", '.pro file in <a href="obj/pnt/dir-overview.html">obj/pnt/ directory</a>', "pnt_flags.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/pnt/pnt_flags.html#pnt_flags", "pnt_flags", 'routine in <a href="obj/pnt/pnt_flags.html">pnt_flags.pro</a>', "pnt_flags.pro", "", "pnt_flags", "	Returns the flags associated with a POINT object.    ", "sample	Sampling interval in the nv direction.  Default is 1.  	<condition>:	All of the predefined conditions (e.g. /visible) are 			accepted; see pnt_condition_keywords.include.   cat	If set, arrays from mulitple input objets are 			concatenated.   conditionStructure specifing a mask and a condition with which to 			match flag values.  The structure must contain the fields 			MASK and STATE.  MASK is a bitmask to test against 			the flags field of the POINT object, and STATE 			is either PS_TRUE and PS_FALSE.  Note that in this case, 			the values will be returned as a list, with no separation 			into nv and nt dimensions.   noeventIf set, no event is generated.   ptd0@pnt_condition_keywords.include", "NV/OBJ/PNT", " 	Written by:	Spitale, 11/2015   	The flags associated with the POINT object.    STATUS: 	Complete    SEE ALSO: 	pnt_set_flags     ");
  
  

libdata[libdataItem++] = new Array("obj/pnt/pnt_input.html", "pnt_input.pro", '.pro file in <a href="obj/pnt/dir-overview.html">obj/pnt/ directory</a>', "pnt_input.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/pnt/pnt_nt.html", "pnt_nt.pro", '.pro file in <a href="obj/pnt/dir-overview.html">obj/pnt/ directory</a>', "pnt_nt.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/pnt/pnt_nt.html#pnt_nt", "pnt_nt", 'routine in <a href="obj/pnt/pnt_nt.html">pnt_nt.pro</a>', "pnt_nt.pro", "", "pnt_nt", "	Returns the nt dimension of a POINT object.    ", "conditionnoeventIf set, no event is generated.   ptdPOINT object.   @pnt_condition_keywords.include", "nt/SYS/PS", " 	Written by:	Spitale, 11/2015   	The nt dimensions of the POINT object.    STATUS: 	Complete     ");
  
  

libdata[libdataItem++] = new Array("obj/pnt/pnt_nv.html", "pnt_nv.pro", '.pro file in <a href="obj/pnt/dir-overview.html">obj/pnt/ directory</a>', "pnt_nv.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/pnt/pnt_nv.html#pnt_nv", "pnt_nv", 'routine in <a href="obj/pnt/pnt_nv.html">pnt_nv.pro</a>', "pnt_nv.pro", "", "pnt_nv", "	Returns the nv dimension of a POINT object.    ", "conditionnoeventIf set, no event is generated.   ptdPOINT object.   @pnt_condition_keywords.include", "NV/OBJ/PNT", " 	Written by:	Spitale, 11/2015   	The nv dimensions of the POINT object.    STATUS: 	Complete     ");
  
  

libdata[libdataItem++] = new Array("obj/pnt/pnt_offset.html", "pnt_offset.pro", '.pro file in <a href="obj/pnt/dir-overview.html">obj/pnt/ directory</a>', "pnt_offset.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/pnt/pnt_points.html", "pnt_points.pro", '.pro file in <a href="obj/pnt/dir-overview.html">obj/pnt/ directory</a>', "pnt_points.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/pnt/pnt_points.html#pnt_points", "pnt_points", 'routine in <a href="obj/pnt/pnt_points.html">pnt_points.pro</a>', "pnt_points.pro", "", "pnt_points", "	Returns the points associated with a POINT object.    ", "segmentsSubscripts in the output array denoting segments in the 			(assumed) continuous curve due to the point selection 			conditions.    sample	Sampling interval in the nv direction.  Default is 1.  	<condition>:	All of the predefined conditions (e.g. /visible) are 			accepted; see pnt_condition_keywords.include.   cat	If set, arrays from multiple input objects are 			concatenated.   conditionStructure specifing a mask and a condition with which to 			match flag values.  The structure must contain the fields 			MASK and STATE.  MASK is a bitmask to test against 			the flags field of the POINT object, and STATE 			is either PS_TRUE and PS_FALSE.  Note that in this case, 			the values will be returned as a list, with no separation 			into nv and nt dimensions.   noeventIf set, no event is generated.   ptd0@pnt_condition_keywords.include", "NV/OBJ/PNT", " 	Written by:	Spitale, 11/2015   	The points associated with the POINT object, or zero.    STATUS: 	Complete    SEE ALSO: 	pnt_set_points     ");
  
  

libdata[libdataItem++] = new Array("obj/pnt/pnt_query.html", "pnt_query.pro", '.pro file in <a href="obj/pnt/dir-overview.html">obj/pnt/ directory</a>', "pnt_query.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/pnt/pnt_query.html#pnt_query", "pnt_query", 'routine in <a href="obj/pnt/pnt_query.html">pnt_query.pro</a>', "pnt_query.pro", "", "pnt_query", "	Returns the fields associated with a POINT object.  This is a 	convenient way of getting multiple fields in one call, and only a 	single event is generated.    ", "conditionStructure specifing a mask and a condition with which to 			match flag values.  The structure must contain the fields 			MASK and STATE.  MASK is a bitmask to test against 			the flags field of the POINT object, and STATE 			is either PS_TRUE and PS_FALSE.  Note that in this case, 			the values will be returned as a list, with no separation 			into nv and nt dimensions.   cat	If set, arrays from mulitple input objets are 			concatenated.  	<condition>:	All of the predefined conditions (e.g. /visible) are 			accepted; see pnt_condition_keywords.include.   noeventIf set, no event is generated.   xd@pnt__keywords_tree.include", "NV/OBJ/PNT", " 	Written by:	Spitale, 12/2015   ");
  
  

libdata[libdataItem++] = new Array("obj/pnt/pnt_read.html", "pnt_read.pro", '.pro file in <a href="obj/pnt/dir-overview.html">obj/pnt/ directory</a>', "pnt_read.pro", "", "", " 	Reads a POINT file.    ", "", "          -1", "  Spitale, 11/2015; 	Adapted from pgs_read_ps   ");
  

libdata[libdataItem++] = new Array("obj/pnt/pnt_scale.html", "pnt_scale.pro", '.pro file in <a href="obj/pnt/dir-overview.html">obj/pnt/ directory</a>', "pnt_scale.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/pnt/pnt_set_assoc_xd.html", "pnt_set_assoc_xd.pro", '.pro file in <a href="obj/pnt/dir-overview.html">obj/pnt/ directory</a>', "pnt_set_assoc_xd.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/pnt/pnt_set_data.html", "pnt_set_data.pro", '.pro file in <a href="obj/pnt/dir-overview.html">obj/pnt/ directory</a>', "pnt_set_data.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/pnt/pnt_set_desc.html", "pnt_set_desc.pro", '.pro file in <a href="obj/pnt/dir-overview.html">obj/pnt/ directory</a>', "pnt_set_desc.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/pnt/pnt_set_flags.html", "pnt_set_flags.pro", '.pro file in <a href="obj/pnt/dir-overview.html">obj/pnt/ directory</a>', "pnt_set_flags.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/pnt/pnt_set_input.html", "pnt_set_input.pro", '.pro file in <a href="obj/pnt/dir-overview.html">obj/pnt/ directory</a>', "pnt_set_input.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/pnt/pnt_set_points.html", "pnt_set_points.pro", '.pro file in <a href="obj/pnt/dir-overview.html">obj/pnt/ directory</a>', "pnt_set_points.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/pnt/pnt_set_tags.html", "pnt_set_tags.pro", '.pro file in <a href="obj/pnt/dir-overview.html">obj/pnt/ directory</a>', "pnt_set_tags.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/pnt/pnt_set_vectors.html", "pnt_set_vectors.pro", '.pro file in <a href="obj/pnt/dir-overview.html">obj/pnt/ directory</a>', "pnt_set_vectors.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/pnt/pnt_tags.html", "pnt_tags.pro", '.pro file in <a href="obj/pnt/dir-overview.html">obj/pnt/ directory</a>', "pnt_tags.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/pnt/pnt_template.html", "pnt_template.pro", '.pro file in <a href="obj/pnt/dir-overview.html">obj/pnt/ directory</a>', "pnt_template.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/pnt/pnt_test.html", "pnt_test.pro", '.pro file in <a href="obj/pnt/dir-overview.html">obj/pnt/ directory</a>', "pnt_test.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/pnt/pnt_threshold.html", "pnt_threshold.pro", '.pro file in <a href="obj/pnt/dir-overview.html">obj/pnt/ directory</a>', "pnt_threshold.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/pnt/pnt_uncompress.html", "pnt_uncompress.pro", '.pro file in <a href="obj/pnt/dir-overview.html">obj/pnt/ directory</a>', "pnt_uncompress.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/pnt/pnt_valid.html", "pnt_valid.pro", '.pro file in <a href="obj/pnt/dir-overview.html">obj/pnt/ directory</a>', "pnt_valid.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/pnt/pnt_vectors.html", "pnt_vectors.pro", '.pro file in <a href="obj/pnt/dir-overview.html">obj/pnt/ directory</a>', "pnt_vectors.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/pnt/pnt_vectors.html#pnt_vectors", "pnt_vectors", 'routine in <a href="obj/pnt/pnt_vectors.html">pnt_vectors.pro</a>', "pnt_vectors.pro", "", "pnt_vectors", "	Returns the vectors associated with a POINT object.    ", "sample	Sampling interval in the nv direction.  Default is 1.  	<condition>:	All of the predefined conditions (e.g. /visible) are 			accepted; see pnt_condition_keywords.include.   cat	If set, arrays from mulitple input objets are 			concatenated.   conditionStructure specifing a mask and a condition with which to 			match flag values.  The structure must contain the fields 			MASK and STATE.  MASK is a bitmask to test against 			the flags field of the POINT objects, and STATE 			is either PS_TRUE and PS_FALSE.  Note that in this case, 			the values will be returned as a list, with no separation 			into nv and nt dimensions.   noeventIf set, no event is generated.   ptd0@pnt_condition_keywords.include", "NV/OBJ/PNT", " 	Written by:	Spitale, 11/2015   	The vectors associated with the POINT object.    STATUS: 	Complete    SEE ALSO: 	pnt_set_vectors     ");
  
  

libdata[libdataItem++] = new Array("obj/pnt/pnt_write.html", "pnt_write.pro", '.pro file in <a href="obj/pnt/dir-overview.html">obj/pnt/ directory</a>', "pnt_write.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/tools/project_map.html", "project_map.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "project_map.pro", "", "", "       Reprojects images.    ", "", "          -1", "       Written by:     Spitale, 6/1998   ");
  

libdata[libdataItem++] = new Array("obj/tools/radec_angle.html", "radec_angle.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "radec_angle.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/tools/radec_image_bounds.html", "radec_image_bounds.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "radec_image_bounds.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/radec_image_bounds.html#radec_image_bounds", "radec_image_bounds", 'routine in <a href="obj/tools/radec_image_bounds.html">radec_image_bounds.pro</a>', "radec_image_bounds.pro", "", "radec_image_bounds", "	Determines radec coordinate ranges visible in an image described 	by a given camera descriptor.    ", "slopborder_pts_imraminramaxdecmindecmaxcornersstatuscdCamera descripor.   ", "NV/LIB/TOOLS", "       Written by:     Spitale   	ramin:	Minimum RA in image.  	ramax:	Maximum RA in image.  	decmin:	Minimum DEC in image.  	decmax:	Maximum DEC in image.  	border_pts_im:	Array (2,np) of points along the edge of the image.  	status:	-1 if no globe in the image, 0 otherwise.    ");
  
  

libdata[libdataItem++] = new Array("obj/tools/composite/radec_to_image.html", "radec_to_image.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "radec_to_image.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/tools/radec_to_orient.html", "radec_to_orient.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "radec_to_orient.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/tools/radec_twist_to_cd.html", "radec_twist_to_cd.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "radec_twist_to_cd.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/tools/ray_points.html", "ray_points.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "ray_points.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/tools/ray_sub_point_graphic.html", "ray_sub_point_graphic.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "ray_sub_point_graphic.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/tools/raytrace.html", "raytrace.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "raytrace.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/raytrace.html#raytrace", "raytrace", 'routine in <a href="obj/tools/raytrace.html">raytrace.pro</a>', "raytrace.pro", "", "raytrace", "	Traces rays from a camera to a set of objects.        ", "cd       Camera descriptor.   bx       Array of object descriptors; must be a subclass of BODY.   sbx          Body descriptor for secondary ray tracing.  If set, 	               image_pts and cd are not used; instead, secondary rays 	               are traced from the given hit_matrix points to sbx.   hit_matrix  Array (nray,3,nhit) of body-frame points for nearest 	              ray intersections.   showpenumbra     If set, lighting rays are traced to random points on 	               each secondary body rather then the center.     hit_indices Array (nray) of body indices corresponding to the first 	              intersection for each ray.   range_matrixArray (nhit,nray) giving distance to the near-side 	              ray intersection for each body in the hit_matrix.   hit_list    Array (nhit) giving indices of all bx that have ray 	              intersections.   far_matrix  Array (nray,3,nhit) of body-frame points for all 	              far-side intersections with bodies in the hit_list.   near_matrix  Array (nray,3,nhit) of body-frame points for all 	               near-side intersections with bodies in the hit_list.    backstandoff     If given, secondary vectors are advanced by this distance 	               before tracing in order to avoid hitting target bodies 	               through round-off error.  Default is 1 unit.   limit_sourceimage_pts Array (2,np) of image points relative to cd.  These 	            points will be turned into rays to be traced from the 	            position of the camera.   ", "NV/PG", " 	Written by:	Spitale      STATUS: 	Complete ");
  
  

libdata[libdataItem++] = new Array("obj/tools/render.html", "render.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "render.pro", "", "", "	Performs rendering on an array of bodies.        ", "", "          -1", " 	Written by:	Spitale      STATUS: 	Complete ");
  

libdata[libdataItem++] = new Array("obj/tools/reproject_image.html", "reproject_image.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "reproject_image.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/reproject_image.html#reproject_image", "reproject_image", 'routine in <a href="obj/tools/reproject_image.html">reproject_image.pro</a>', "reproject_image.pro", "", "reproject_image", "       xx    ", "cd    Camera descriptor.   new_cdsizeinterparg_interpimage    Image of body.   pc_xsize    x size of map workspace   pc_ysize    y size of map workspace    ", "NV/LIB/TOOLS", "       Written by:     Spitale, 6/1998          The reprojected image.   ");
  
  

libdata[libdataItem++] = new Array("grim/rim.html", "rim.pro", '.pro file in <a href="grim/dir-overview.html">grim/ directory</a>', "rim.pro", "", "", "	Prints the headers, or specific header values, for the specified files.    ", "", "          -1", " 	Written by:	Spitale, 8/2013   ");
  

libdata[libdataItem++] = new Array("obj/tools/ringplane_radial_bounds.html", "ringplane_radial_bounds.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "ringplane_radial_bounds.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/rng/rng_assign.html", "rng_assign.pro", '.pro file in <a href="obj/rng/dir-overview.html">obj/rng/ directory</a>', "rng_assign.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/rng/rng_assign.html#rng_assign", "rng_assign", 'routine in <a href="obj/rng/rng_assign.html">rng_assign.pro</a>', "rng_assign.pro", "", "rng_assign", "	Replaces fields in a RING object.  This is a convenient way of 	setting multiple fields in one call, and only a single event is 	generated.    ", "noeventIf set, no event is generated.   xd@rng__keywords_tree.include", "NV/OBJ/RNG", " 	Written by:	Spitale		2/2017   ");
  
  

libdata[libdataItem++] = new Array("obj/rng/rng_create_descriptors.html", "rng_create_descriptors.pro", '.pro file in <a href="obj/rng/dir-overview.html">obj/rng/ directory</a>', "rng_create_descriptors.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/rng/rng_create_descriptors.html#rng_create_descriptors", "rng_create_descriptors", 'routine in <a href="obj/rng/rng_create_descriptors.html">rng_create_descriptors.pro</a>', "rng_create_descriptors.pro", "", "rng_create_descriptors", "	Init method for the RING class.    ", "crdCore descriptor(s) to pass to cor_create_descriptors.   bdBody descriptor(s) to pass to bod_create_descriptors.   sldSolid descriptor(s) to pass to sld_create_descriptors.   dkdDisk descriptor(s) to pass to dsk_create_descriptors.   rdRing descriptor(s) to initialize, instead of creating new 		ones.   n     Number of ring descriptors.   @rng__keywords_tree.include", "NV/LIB/RNG", "       Written by:     Spitale  	Adapted by:	Spitale, 5/2016          An array (n) of ring descriptors.   STATUS:        Completed.    ");
  
  

libdata[libdataItem++] = new Array("obj/rng/rng_desc.html", "rng_desc.pro", '.pro file in <a href="obj/rng/dir-overview.html">obj/rng/ directory</a>', "rng_desc.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/rng/rng_evolve.html", "rng_evolve.pro", '.pro file in <a href="obj/rng/dir-overview.html">obj/rng/ directory</a>', "rng_evolve.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/rng/rng_query.html", "rng_query.pro", '.pro file in <a href="obj/rng/dir-overview.html">obj/rng/ directory</a>', "rng_query.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/rng/rng_query.html#rng_query", "rng_query", 'routine in <a href="obj/rng/rng_query.html">rng_query.pro</a>', "rng_query.pro", "", "rng_query", "	Returns the fields associated with a RING object.  This is a 	convenient way of getting multiple fields in one call, and only a 	single event is generated.    ", "conditionStructure specifing a mask and a condition with which to 			match flag values.  The structure must contain the fields 			MASK and STATE.  MASK is a bitmask to test against 			the flags field of the POINT object, and STATE 			is either PS_TRUE and PS_FALSE.  Note that in this case, 			the values will be returned as a list, with no separation 			into nv and nt dimensions.   cat	If set, arrays from mulitple input objets are 			concatenated.  	<condition>:	All of the predefined conditions (e.g. /visible) are 			accepted; see pnt_condition_keywords.include.   noeventIf set, no event is generated.   xd@rng__keywords_tree.include", "NV/OBJ/RNG", " 	Written by:	Spitale, 2/2017   ");
  
  

libdata[libdataItem++] = new Array("obj/rng/rng_replicate.html", "rng_replicate.pro", '.pro file in <a href="obj/rng/dir-overview.html">obj/rng/ directory</a>', "rng_replicate.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/rng/rng_set_desc.html", "rng_set_desc.pro", '.pro file in <a href="obj/rng/dir-overview.html">obj/rng/ directory</a>', "rng_set_desc.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/tools/composite/set_image_origin.html", "set_image_origin.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "set_image_origin.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/tools/composite/set_image_size.html", "set_image_size.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "set_image_size.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/tools/set_primary.html", "set_primary.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "set_primary.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/sld/sld_albedo.html", "sld_albedo.pro", '.pro file in <a href="obj/sld/dir-overview.html">obj/sld/ directory</a>', "sld_albedo.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/sld/sld_assign.html", "sld_assign.pro", '.pro file in <a href="obj/sld/dir-overview.html">obj/sld/ directory</a>', "sld_assign.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/sld/sld_assign.html#sld_assign", "sld_assign", 'routine in <a href="obj/sld/sld_assign.html">sld_assign.pro</a>', "sld_assign.pro", "", "sld_assign", "	Replaces fields in a SOLID object.  This is a convenient way of 	setting multiple fields in one call, and only a single event is 	generated.    ", "noeventIf set, no event is generated.   xd@sld__keywords_tree.include", "NV/OBJ/SLD", " 	Written by:	Spitale		2/2017   ");
  
  

libdata[libdataItem++] = new Array("obj/sld/sld_create_descriptors.html", "sld_create_descriptors.pro", '.pro file in <a href="obj/sld/dir-overview.html">obj/sld/ directory</a>', "sld_create_descriptors.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/sld/sld_create_descriptors.html#sld_create_descriptors", "sld_create_descriptors", 'routine in <a href="obj/sld/sld_create_descriptors.html">sld_create_descriptors.pro</a>', "sld_create_descriptors.pro", "", "sld_create_descriptors", "	Init method for the SOLID class.    ", "crdbdsldnNumber of descriptors to create.   @sld__keywords_tree.include", "NV/LIB/SLD", " 	Written by:	Spitale, 7/2015  	Adapted by:	Spitale, 5/2016   	Newly created or or freshly initialized solid descriptors, depending 	on the presence of the bd keyword.    STATUS: 	Complete    ");
  
  

libdata[libdataItem++] = new Array("obj/sld/sld_evolve.html", "sld_evolve.pro", '.pro file in <a href="obj/sld/dir-overview.html">obj/sld/ directory</a>', "sld_evolve.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/sld/sld_gm.html", "sld_gm.pro", '.pro file in <a href="obj/sld/dir-overview.html">obj/sld/ directory</a>', "sld_gm.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/sld/sld_mass.html", "sld_mass.pro", '.pro file in <a href="obj/sld/dir-overview.html">obj/sld/ directory</a>', "sld_mass.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/sld/sld_npht.html", "sld_npht.pro", '.pro file in <a href="obj/sld/dir-overview.html">obj/sld/ directory</a>', "sld_npht.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/sld/sld_opacity.html", "sld_opacity.pro", '.pro file in <a href="obj/sld/dir-overview.html">obj/sld/ directory</a>', "sld_opacity.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/sld/sld_phase.html", "sld_phase.pro", '.pro file in <a href="obj/sld/dir-overview.html">obj/sld/ directory</a>', "sld_phase.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/sld/sld_phase_fn.html", "sld_phase_fn.pro", '.pro file in <a href="obj/sld/dir-overview.html">obj/sld/ directory</a>', "sld_phase_fn.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/sld/sld_phase_parm.html", "sld_phase_parm.pro", '.pro file in <a href="obj/sld/dir-overview.html">obj/sld/ directory</a>', "sld_phase_parm.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/sld/sld_query.html", "sld_query.pro", '.pro file in <a href="obj/sld/dir-overview.html">obj/sld/ directory</a>', "sld_query.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/sld/sld_query.html#sld_query", "sld_query", 'routine in <a href="obj/sld/sld_query.html">sld_query.pro</a>', "sld_query.pro", "", "sld_query", "	Returns the fields associated with a CAMERA object.  This is a 	convenient way of getting multiple fields in one call, and only a 	single event is generated.    ", "conditionStructure specifing a mask and a condition with which to 			match flag values.  The structure must contain the fields 			MASK and STATE.  MASK is a bitmask to test against 			the flags field of the POINT object, and STATE 			is either PS_TRUE and PS_FALSE.  Note that in this case, 			the values will be returned as a list, with no separation 			into nv and nt dimensions.   cat	If set, arrays from mulitple input objets are 			concatenated.  	<condition>:	All of the predefined conditions (e.g. /visible) are 			accepted; see pnt_condition_keywords.include.   noeventIf set, no event is generated.   xd@sld__keywords_tree.include", "NV/OBJ/CAM", " 	Written by:	Spitale, 2/2017   ");
  
  

libdata[libdataItem++] = new Array("obj/sld/sld_refl.html", "sld_refl.pro", '.pro file in <a href="obj/sld/dir-overview.html">obj/sld/ directory</a>', "sld_refl.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/sld/sld_refl_fn.html", "sld_refl_fn.pro", '.pro file in <a href="obj/sld/dir-overview.html">obj/sld/ directory</a>', "sld_refl_fn.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/sld/sld_refl_parm.html", "sld_refl_parm.pro", '.pro file in <a href="obj/sld/dir-overview.html">obj/sld/ directory</a>', "sld_refl_parm.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/sld/sld_set_albedo.html", "sld_set_albedo.pro", '.pro file in <a href="obj/sld/dir-overview.html">obj/sld/ directory</a>', "sld_set_albedo.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/sld/sld_set_gm.html", "sld_set_gm.pro", '.pro file in <a href="obj/sld/dir-overview.html">obj/sld/ directory</a>', "sld_set_gm.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/sld/sld_set_mass.html", "sld_set_mass.pro", '.pro file in <a href="obj/sld/dir-overview.html">obj/sld/ directory</a>', "sld_set_mass.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/sld/sld_set_opacity.html", "sld_set_opacity.pro", '.pro file in <a href="obj/sld/dir-overview.html">obj/sld/ directory</a>', "sld_set_opacity.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/sld/sld_set_phase_fn.html", "sld_set_phase_fn.pro", '.pro file in <a href="obj/sld/dir-overview.html">obj/sld/ directory</a>', "sld_set_phase_fn.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/sld/sld_set_phase_parm.html", "sld_set_phase_parm.pro", '.pro file in <a href="obj/sld/dir-overview.html">obj/sld/ directory</a>', "sld_set_phase_parm.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/sld/sld_set_refl_fn.html", "sld_set_refl_fn.pro", '.pro file in <a href="obj/sld/dir-overview.html">obj/sld/ directory</a>', "sld_set_refl_fn.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/sld/sld_set_refl_parm.html", "sld_set_refl_parm.pro", '.pro file in <a href="obj/sld/dir-overview.html">obj/sld/ directory</a>', "sld_set_refl_parm.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/tools/stellab.html", "stellab.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "stellab.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/tools/stellab_pos.html", "stellab_pos.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "stellab_pos.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/stellab_pos.html#stellab_pos", "stellab_pos", 'routine in <a href="obj/tools/stellab_pos.html">stellab_pos.pro</a>', "stellab_pos.pro", "", "stellab_pos", "	Corrects positions for stellar aberration.    ", "cSpeed of light.   axisArray (nv,3) of rotation axes corresponding to each 		correction.   thetaArray (nv) of rotation angles corresponding to each 		correction.    fastposArray (nv,3) of target inertial position vectors to be 		corrected.   velArray (nv,3) of observer inertial velocity vectors. 		Note observer is assumed to be at the origin.   ", "NV/LIB/TOOLS", "       Written by:     Spitale   	Array (nv,3) of corrected position vectors.    ");
  
  

libdata[libdataItem++] = new Array("obj/tools/stellab_radec.html", "stellab_radec.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "stellab_radec.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/tools/stereo_split.html", "stereo_split.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "stereo_split.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/stn/stn_assign.html", "stn_assign.pro", '.pro file in <a href="obj/stn/dir-overview.html">obj/stn/ directory</a>', "stn_assign.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/stn/stn_assign.html#stn_assign", "stn_assign", 'routine in <a href="obj/stn/stn_assign.html">stn_assign.pro</a>', "stn_assign.pro", "", "stn_assign", "	Replaces fields in a STATION object.  This is a convenient way of 	setting multiple fields in one call, and only a single event is 	generated.    ", "noeventIf set, no event is generated.   xd@stn__keywords_tree.include", "NV/OBJ/CAM", " 	Written by:	Spitale		2/2017   ");
  
  

libdata[libdataItem++] = new Array("obj/stn/stn_create_descriptors.html", "stn_create_descriptors.pro", '.pro file in <a href="obj/stn/dir-overview.html">obj/stn/ directory</a>', "stn_create_descriptors.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/stn/stn_create_descriptors.html#stn_create_descriptors", "stn_create_descriptors", 'routine in <a href="obj/stn/stn_create_descriptors.html">stn_create_descriptors.pro</a>', "stn_create_descriptors.pro", "", "stn_create_descriptors", "	Init method for the STATION class.    ", "crdCore descriptor(s) to pass to cor_create_descriptors.   bdBody descriptor(s) to pass to bod_create_descriptors.   stdStation descriptor(s) to initialize, instead of creating new 		ones.   n     Number of station descriptors.   @stn__keywords_tree.include", "NV/LIB/STN", "       Written by:     Spitale  	Adapted by:	Spitale, 5/2016          An array (n) of station descriptors.   STATUS:        Completed.    ");
  
  

libdata[libdataItem++] = new Array("obj/stn/stn_evolve.html", "stn_evolve.pro", '.pro file in <a href="obj/stn/dir-overview.html">obj/stn/ directory</a>', "stn_evolve.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/stn/stn_query.html", "stn_query.pro", '.pro file in <a href="obj/stn/dir-overview.html">obj/stn/ directory</a>', "stn_query.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/stn/stn_query.html#stn_query", "stn_query", 'routine in <a href="obj/stn/stn_query.html">stn_query.pro</a>', "stn_query.pro", "", "stn_query", "	Returns the fields associated with a STATION object.  This is a 	convenient way of getting multiple fields in one call, and only a 	single event is generated.    ", "conditionStructure specifing a mask and a condition with which to 			match flag values.  The structure must contain the fields 			MASK and STATE.  MASK is a bitmask to test against 			the flags field of the POINT object, and STATE 			is either PS_TRUE and PS_FALSE.  Note that in this case, 			the values will be returned as a list, with no separation 			into nv and nt dimensions.   cat	If set, arrays from mulitple input objets are 			concatenated.  	<condition>:	All of the predefined conditions (e.g. /visible) are 			accepted; see pnt_condition_keywords.include.   noeventIf set, no event is generated.   xd@stn__keywords_tree.include", "NV/OBJ/CAM", " 	Written by:	Spitale, 2/2017   ");
  
  

libdata[libdataItem++] = new Array("obj/stn/stn_replicate.html", "stn_replicate.pro", '.pro file in <a href="obj/stn/dir-overview.html">obj/stn/ directory</a>', "stn_replicate.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/stn/stn_set_surface_pt.html", "stn_set_surface_pt.pro", '.pro file in <a href="obj/stn/dir-overview.html">obj/stn/ directory</a>', "stn_set_surface_pt.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/stn/stn_surface_pt.html", "stn_surface_pt.pro", '.pro file in <a href="obj/stn/dir-overview.html">obj/stn/ directory</a>', "stn_surface_pt.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/str/str_assign.html", "str_assign.pro", '.pro file in <a href="obj/str/dir-overview.html">obj/str/ directory</a>', "str_assign.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/str/str_assign.html#str_assign", "str_assign", 'routine in <a href="obj/str/str_assign.html">str_assign.pro</a>', "str_assign.pro", "", "str_assign", "	Replaces fields in a STAR object.  This is a convenient way of 	setting multiple fields in one call, and only a single event is 	generated.    ", "noeventIf set, no event is generated.   xd@str__keywords_tree.include", "NV/OBJ/STR", " 	Written by:	Spitale		2/2017   ");
  
  

libdata[libdataItem++] = new Array("obj/str/str_create_descriptors.html", "str_create_descriptors.pro", '.pro file in <a href="obj/str/dir-overview.html">obj/str/ directory</a>', "str_create_descriptors.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/str/str_create_descriptors.html#str_create_descriptors", "str_create_descriptors", 'routine in <a href="obj/str/str_create_descriptors.html">str_create_descriptors.pro</a>', "str_create_descriptors.pro", "", "str_create_descriptors", "	Init method for the STAR class.    ", "crdCore descriptor(s) to pass to cor_create_descriptors.   bdBody descriptor(s) to pass to bod_create_descriptors.   sldSolid descriptor(s) to pass to sld_create_descriptors.   gbdGlobe descriptor(s) to pass to glb_create_descriptors.   sdStar descriptor(s) to initialize, instead of creating new ones.   n     Number of star descriptors.   @str__keywords_tree.include", "NV/LIB/STR", "       Written by:     Haemmerle, 5/1998  	Adapted by:	Spitale, 5/2016          An array (n) of star descriptors.   STATUS:        Completed.    ");
  
  

libdata[libdataItem++] = new Array("obj/str/str_evolve.html", "str_evolve.pro", '.pro file in <a href="obj/str/dir-overview.html">obj/str/ directory</a>', "str_evolve.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/str/str_get_flux.html", "str_get_flux.pro", '.pro file in <a href="obj/str/dir-overview.html">obj/str/ directory</a>', "str_get_flux.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/str/str_get_mag.html", "str_get_mag.pro", '.pro file in <a href="obj/str/dir-overview.html">obj/str/ directory</a>', "str_get_mag.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/str/str_limit_mag.html", "str_limit_mag.pro", '.pro file in <a href="obj/str/dir-overview.html">obj/str/ directory</a>', "str_limit_mag.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/str/str_lum.html", "str_lum.pro", '.pro file in <a href="obj/str/dir-overview.html">obj/str/ directory</a>', "str_lum.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/str/str_query.html", "str_query.pro", '.pro file in <a href="obj/str/dir-overview.html">obj/str/ directory</a>', "str_query.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/str/str_query.html#str_query", "str_query", 'routine in <a href="obj/str/str_query.html">str_query.pro</a>', "str_query.pro", "", "str_query", "	Returns the fields associated with a STAR object.  This is a 	convenient way of getting multiple fields in one call, and only a 	single event is generated.    ", "conditionStructure specifing a mask and a condition with which to 			match flag values.  The structure must contain the fields 			MASK and STATE.  MASK is a bitmask to test against 			the flags field of the POINT object, and STATE 			is either PS_TRUE and PS_FALSE.  Note that in this case, 			the values will be returned as a list, with no separation 			into nv and nt dimensions.   cat	If set, arrays from mulitple input objets are 			concatenated.  	<condition>:	All of the predefined conditions (e.g. /visible) are 			accepted; see pnt_condition_keywords.include.   noeventIf set, no event is generated.   xd@str__keywords_tree.include", "NV/OBJ/STR", " 	Written by:	Spitale, 2/2017   ");
  
  

libdata[libdataItem++] = new Array("obj/str/str_replicate.html", "str_replicate.pro", '.pro file in <a href="obj/str/dir-overview.html">obj/str/ directory</a>', "str_replicate.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/str/str_set_lum.html", "str_set_lum.pro", '.pro file in <a href="obj/str/dir-overview.html">obj/str/ directory</a>', "str_set_lum.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/str/str_set_sp.html", "str_set_sp.pro", '.pro file in <a href="obj/str/dir-overview.html">obj/str/ directory</a>', "str_set_sp.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/str/str_sp.html", "str_sp.pro", '.pro file in <a href="obj/str/dir-overview.html">obj/str/ directory</a>', "str_sp.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/tools/sub_latlon.html", "sub_latlon.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "sub_latlon.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/tools/composite/surface_hide_points.html", "surface_hide_points.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "surface_hide_points.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/tools/composite/surface_image_bounds.html", "surface_image_bounds.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "surface_image_bounds.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/composite/surface_image_bounds.html#surface_image_bounds", "surface_image_bounds", 'routine in <a href="obj/tools/composite/surface_image_bounds.html">surface_image_bounds.pro</a>', "surface_image_bounds.pro", "", "surface_image_bounds", "	Computes latitude / longitude ranges visible in an image.    ", "slopAmount, in pixels, by which to expand the image size 		considered in the calcultaion.   border_pts_imImage points on the border of the image defined by cd.   latminMinimum latitude covered in image   latmaxMaximum latitude covered in image   lonminMinimum longitude covered in image   lonmaxMaximum longitude covered in image    statuscd     Camera descriptor   bx     Object descriptor (subclass of BODY)    ", "NV/LIB/TOOLS/COMPOSITE", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/composite/surface_intersect.html", "surface_intersect.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "surface_intersect.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/tools/surface_normal.html", "surface_normal.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "surface_normal.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/tools/composite/surface_normal.html", "surface_normal.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "surface_normal.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/tools/composite/surface_to_body.html", "surface_to_body.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "surface_to_body.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/tools/surface_to_degrees.html", "surface_to_degrees.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "surface_to_degrees.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/tools/composite/surface_to_image.html", "surface_to_image.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "surface_to_image.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/tools/composite/surface_to_map.html", "surface_to_map.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "surface_to_map.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/tools/composite/ta_to_az.html", "ta_to_az.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "ta_to_az.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/tools/target_altaz.html", "target_altaz.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "target_altaz.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("obj/dat/tr_keyword_value.html", "tr_keyword_value.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "tr_keyword_value.pro", "", "", "	Looks up a keyword in the data descriptor-stored keyword/value pairs.    ", "", "          -1", " 	Written by:	Spitale  	Adapted by:	Spitale, 5/2016   ");
  

