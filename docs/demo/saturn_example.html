<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.6.1 on Tue Jul 18 15:09:51 2017 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>saturn_example.pro (OMINAS API Documentation)</title>

    

    <script type="text/javascript" src="idldoc-resources/js/jquery.js"></script>
    <script type="text/javascript" src="idldoc-resources/js/copybutton.js"></script>

    
    <style type="text/css" media="all">
            /* setup page */
      body { font-family: Helvetica, sans-serif; font-size: 12pt; margin: 0; padding: 0; }
      div.content { padding: 1em; }
      p { line-height: 1.4; }
      td p { padding-bottom: 0.5em; }
      img { border: 0; }
      
      /* link styles */
      a { text-decoration: none; }
      a:link, a:visited { color: #0000FF; }
      a:hover, a:focus { background: yellow; border-bottom: 1emx dotted #303099; }
      
      /* dir-overview styles */
      dt.filename { margin-top: 0.5em; }
      dl.file_listing { margin-left: 1em; }
      
      /* titles */
      h1, h2, h3, h4 { font-weight:normal; color: #871E31; margin-top: 1.5em; }
      h4 { margin-bottom: 0.25em; }
      .center { margin-left: auto; margin-right: auto; }
      .small { font-family: Verdana, Helvetica, sans-serif; font-size: 90%; }
      .smaller { font-family: Verdana, Helvetica, sans-serif; font-size: 80%; }
      .smallest { font-family: Verdana, Helvetica, sans-serif; font-size: 70%; }
      h1.basename { margin-top: 0; margin-bottom: 0; }
      h1.basename span.file-attributes { font-size: 70%; margin-left: 3em; color: #384806; }
      h2.directory { font-size: 90%; margin-bottom: 0; }
      h2.routine-name { margin-top: 0; margin-bottom: 0; }
      p.categories { color: #384806; margin-top: 0; }
      span.file_attribute { float: right; color: #384806; margin: 0 0 1em 3em; }
      div#file_comments { margin-top: 1em; }
      
      div.routine-details { border: 1px dotted #C0C0C0; margin-top: 1em; padding: 1em; }
      span.routine-attributes { font-size: 70%; margin-left: 3em; color: #384806; }
      div.details dt { color: #871E31; margin-left: 2em; }
      div.details dt span { color: #384806; margin-left: 2em; }
      div.details dd { margin: 0.5em 2em 1em 4em; }
      a.top {
        font-family: Verdana, Helvetica, sans-serif;
        font-size: 8pt;
        font-weight: bold;
        color: #5070ff;
        text-transform: uppercase;
        float: right;
        margin-left: 1em;
      }
      
      /* comments */
      .pre { white-space: pre; }
      
      /* code styles */
      code { font-family: Monaco, "Courier New", Courier, monospace; font-size: 95%; }
      code.listing { white-space: pre; display: block; margin: 0.75em 0 0.75em 0; padding: 0 3em 0 1em; line-height: 1.4em; }
      code.source { white-space: pre; display: block; }
      code.source span.comments { color: #408080; }
      .syntax { margin-top: 1em; margin-left: 1.5em; text-indent: -1.5em; }
      .var { font-style: italic; }
      .argument { } /* white-space: nowrap; does not work in Safari (and sometimes not even in Firefox) */
      
      dl.routine-summary dt { margin-bottom: 0.25em; }
      dl.routine-summary dd { margin-bottom: 0.5em; margin-left: 2em; }
      
      ul.inherited-method-summary { padding-left: 0em; margin-left: 0em; }
      
      /* general styles */
      ul li { list-style-type: none; }
      table { empty-cells: show; }
      thead { color: #871E31; }
      dd { margin-bottom: 0.35em; }
      input, textarea { background: #F3F6ED; border: #E1D6C6 1px solid; padding: 2px 1em 2px 0.5em; }
      input.text { background: #FFFFC0; }
      
      div.note { margin: 1em 2em 1em 2em; background: #EFEFEF; border: 1px #A0A0A0 dotted; padding: 0 1em 0 1em; }
      p.indent { margin-left: 2em; }
      
      /* An attribute table is a vertical list of name-value pairs. */
      table.box {
        background: #EFEFEF;
        border: 1px #A0A0A0 dotted;
        padding-top: 0.75em;
        padding-bottom: 0.75em;
      }
      table.attribute { padding-left: 0.75em; padding-right: 0.75em; }
      table td { vertical-align: top; }
      table.attribute p { margin: 0; }
      table td.name { font-style: normal; padding-right: 1.5em; }
      ul.fieldslist { padding-top: 0; color: #909090; }
      ul.fieldslist li { margin-bottom: 0.25em; }
      span.fieldname { color: #000000; }
      
      dl.attribute dt { color: #990000; }
      
      /* header/navbar styles */
      div.header { padding: 2em 2em 0 2em; background: #9E9D7B; border-bottom: 2px #262626 solid; }
      div.header h1 { color: white; margin:0; font-weight: normal; }
      div.header h2 { color: white; margin-top: 0; margin-bottom: 1em; font-weight: normal; font-style: italic; font-size: 100%; }
      table.navbar { background: #CCC097; margin: 0; padding: 0; border-bottom: 1px #262626 dotted; width: 100%; }
      table.navbar td { padding: 4px 0.5em 3px 0.5em; white-space: nowrap; vertical-align: top; }
      table.navbar td.flexible { width: 100%; text-align: right; padding-right: 1em; white-space: nowrap; }
      table.navbar td.selected { background: #262626; }
      table.navbar td.selected, table.navbar td.selected a { color: white; }
      table.navbar a:hover, table.navbar a:focus { background: inherit; border-bottom: 1px solid #303099; }
      p.localnavbar { text-align: right; margin: 0.2em 1em 0.2em 0.2em; padding: 0; }
      
      /* CSS graphics styles */
      div.box {
        margin-left: 0.25em;
        display: inline-block;
        width: 0.9em;
        height: 0.9em;
        vertical-align: -1px;
      }
      .red { background-color: #A00; }
      .orange { background-color: #F40; }
      .green { background-color: #480; }
      
      /* index styles */
      span.index_type { margin-left: 1em; }
      dl.index_listing dd { margin-bottom: 0.5em; margin-left: 2em; }
      dl.index_listing dd p { margin-top: 0.2em; margin-bottom: 0em; }
      
      /* search styles */
      fieldset { border: #ddd 1px solid; padding: 1em; margin-top: 3em; }
      legend { color: #871E31; font-size: 120%; }
      label { white-space: nowrap; }
      p.description { margin: 2em 2em 1em 2em; }
      form table td.name { vertical-align: middle; }
      
      /* footer styles */
      div.footer { padding: 0.5em 1em 0.5em 1em; background: #EFEFEF; border-top: 1px #A0A0A0 dotted; }
      div.footer table { width: 100%; }
      div.footer td.right { text-align: right; }

    </style>
    <style type="text/css" media="print">
            p.localnavbar { display: none; }
      
      div.header { background: white; }
      div.header h1 { color: black; }
      div.header h2 { color: black; }

    </style>
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="saturn_example.pro (OMINAS API Documentation)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">

    <div class="header">
      <h1>OMINAS API Documentation</h1>
      <h2>Generated by IDLdoc</h2>
    </div>
    
    
    <table class="navbar smaller" summary="Navigation header" cellspacing="0">
      <tr>
        <td >
          <a href="overview.html">Overview</a>
        </td>
    
        <td >
          Directory
        </td>
    
        <td class="selected">File</td>
    
        
    
        <td >Etc</td>
    
        <td >
          <a href="categories.html">Categories</a>
        </td>
    
        <td >
          <a href="search.html">Search</a>
        </td>
    
        
        <td >
          <a href="idldoc-index.html">Index</a>
        </td>
        
    
        
        <td >
          <a href="idldoc-warnings.html">Warnings</a>
        </td>
        
    
        <td >
          <a href="idldoc-help.html">Help</a>
        </td>
    
        <td class="flexible">
          Developer documentation
        </td>
      </tr>
    </table>
    
    
    
    <p class="localnavbar smallest"><a href="" target="_top">single page</a> | <a href="index.html" target="_top">use frames</a> &nbsp;&nbsp;&nbsp; summary &nbsp;&nbsp;&nbsp; class &nbsp;&nbsp;&nbsp; fields &nbsp;&nbsp;&nbsp; <a href="#routine-details">routine details</a> &nbsp;&nbsp;&nbsp; <a href="#attributes">file attributes</a></p>
    
    
    
    
    
    
    
    
    

    <div class="content">
      <h2 class="directory">./</h2>
      <h1 class="basename">saturn_example.pro<span class="file-attributes"></span></h1>
      

      <span class="file_attribute small">batch file</span>
      
      
      <br/>

      
      <div id="file_comments">
        <div class="small "><h2> Saturn Example</h2>

<p>  	 This example file uses Saturn and its rings to show various
  	 capabilities of the software.  This includes fitting the
  	 limb and rings simultaneously, hiding the limb and/or rings wrt
  	 other objects in the field of view, plotting radial and longitudinal
  	 sectors on the ring and mapping the saturn cloud tops.
</p>

<p>  	 This example file can be executed from the UNIX command line using:
<div><div><code class="listing"><span class="code-output">	  ominas ominas saturn_example</span>
</code></div></div>  	 or from within an OMINAS IDL session using:
<div><div><code class="listing"><span class="code-output">	  @saturn_example</span>
</code></div></div>  	 After the example stops, later code samples in this file may be executed by
  	 pasting them onto the IDL command line.
</p>

<h2> Image read and display</h2>

<p>	<img src="saturn_load.jpeg"/>
</p>

<p>	This first section uses dat_read to read in the image.  The image file
   c3440346.gem is a Voyager VICAR format file where the image has had
   the camera distortions removed with the VICAR program GEOMA.  dat_read
   reads the image portion (im) and the image label (label) and its output
   is a data descriptor (dd).  ctmod is called to reserve several colors
   in the case of an 8-bit display.  tvim is called to display the image
   (im) at 1/2 size in a new window with the y coordinate as top-down.
</p>

<p>	For Example:
<div><div><code class="listing"><span class="code-output">  dd = dat_read(getenv('OMINAS_DIR')+'/demo/data/c3440346.gem', im, label)</span>
<span class="code-output">  tvim, im, zoom=0.5, /order, /new</span>

</code></div></div></p>

<h2> Obtaining the descriptors</h2>

<p>   This section obtains the camera descriptor (cd), the planet descriptor
   (pd) and the ring descriptor (rd) for use by the software.  In this
   example, the various elements of these descriptors are overridden with
   values that causes the software not to try to read these values from
   a detached header or through a translator that would access the data
   from the default source.
</p>

<p>   Change override to zero to read the data through the translators instead:
<div><div><code class="listing"><span class="code-output"> override=1</span>
</code></div></div>   Camera descriptor:
<div><div><code class="listing"><span class="code-output"> if(override) then $</span>
<span class="code-output">   cd = pg_get_cameras(dd, /over, $</span>
<span class="code-output">   name='VGR1_ISS_NA', $</span>
<span class="code-output">   orient= $</span>
<span class="code-output">   [ [-0.177287575, -0.966450211, -0.185857758 ], $</span>
<span class="code-output">   [ 0.507898045, -0.251604865,  0.823853487 ], $</span>
<span class="code-output">   [ 0.842976092, -0.051662194, -0.535464589 ] ], $</span>
<span class="code-output">   avel=tr([0.0, 0.0, 0.0]), $</span>
<span class="code-output">   pos=tr([0.0, 0.0, 0.0]), $</span>
<span class="code-output">   vel=tr([0.0, 0.0, 0.0]), $</span>
<span class="code-output">   time=972603249.d, $</span>
<span class="code-output">   scale=[7.858656e-06,7.858656e-06], $</span>
<span class="code-output">   oaxis=[499.0,499.0], $</span>
<span class="code-output">   size=[1000,1000], $</span>
<span class="code-output">   fn_focal_to_image='cam_focal_to_image_linear', $</span>
<span class="code-output">   fn_image_to_focal='cam_image_to_focal_linear', $</span>
<span class="code-output">   fi_data=ptr_new())</span>
</code></div></div>   Planet descriptor:
<div><div><code class="listing"><span class="code-output">   if(override) then $</span>
<span class="code-output">     pd = pg_get_planets(dd, od=cd, /over, $</span>
<span class="code-output">     name='SATURN', $</span>
<span class="code-output">     orient= $</span>
<span class="code-output">     [ [-0.254669368,  0.963251789,  0.085378596], $</span>
<span class="code-output">     [-0.962535206, -0.260997177,  0.073528563], $</span>
<span class="code-output">     [ 0.093110093, -0.063454432,  0.993631746] ], $</span>
<span class="code-output">     avel=tr([0.0854, 0.0732, 0.9937])*1.74e-4, $</span>
<span class="code-output">     pos=tr([-23433172000.0, -6105736000.0, -1223129375.0]), $</span>
<span class="code-output">     vel=[ tr([9500.0, 0.0, 0.0]), $</span>
<span class="code-output">     tr([0.0, 0.1, 0.0]) ], $</span>
<span class="code-output">     time=972603249.d, $</span>
<span class="code-output">     radii=[60268000.,60268000.,54364000.], $</span>
<span class="code-output">     lora=0.0)</span>
</code></div></div>   Rings descriptor:
<div><div><code class="listing"><span class="code-output">     if(override) then $</span>
<span class="code-output">       rd = pg_get_rings(dd, pd=pd, od=cd, /over, $</span>
<span class="code-output">       name='MAIN_RING_SYSTEM', $</span>
<span class="code-output">       primary=pd, $</span>
<span class="code-output">       orient= $</span>
<span class="code-output">       [ [-0.254669368,  0.963251789,  0.085378596], $</span>
<span class="code-output">       [-0.962535206, -0.260997177,  0.073528563], $</span>
<span class="code-output">       [ 0.093110093, -0.063454432,  0.993631746] ], $</span>
<span class="code-output">       avel=tr([0.0854, 0.0732, 0.9937])*1.74e-4, $</span>
<span class="code-output">       pos=tr([-23433172000.0, -6105736000.0, -1223129375.0]), $</span>
<span class="code-output">       vel=[tr([9500.0, 0.0, 0.0]), $</span>
<span class="code-output">       tr([0.0, 0.1, 0.0]) ] , $</span>
<span class="code-output">       time=972603249.d, $</span>
<span class="code-output">       sma=tr([75000000.0,136800000.0]), $</span>
<span class="code-output">       ecc=tr([0.0, 0.0]))</span>
</code></div></div>   Sun (star) descriptor:
<div><div><code class="listing"><span class="code-output">       if(override) then $</span>
<span class="code-output">         sund = pg_get_stars(dd, od=cd, /over, $</span>
<span class="code-output">         name='SUN', $</span>
<span class="code-output">         pos=tr([1.421392d12,4.3105676d10,-4.3613585d10]))</span>
</code></div></div>   If override was not set, the above could be done with just:
<div><div><code class="listing"><span class="code-output">       if(NOT override) then cd = pg_get_cameras(dd)</span>
<span class="code-output">       if(NOT override) then pd = pg_get_planets(dd, od=cd)</span>
<span class="code-output">       if(NOT override) then rd = pg_get_rings(dd, pd=pd, od=cd, '/system')</span>
<span class="code-output">       if(NOT override) then sund = pg_get_stars(dd, od=cd, name='SUN')</span>

</code></div></div></p>

<p>  This example, commented out, shows how two objects can be included in
  one planet descriptor.
</p>

<h2> Filling the generic descriptor</h2>

<p>  	This line fills a "generic" descriptor.  This is a convenience
  	feature where in several descriptors are grouped into a structure that
  	can be passed to functions in one piece.
</p>

<p>  	cd - camera descriptor part
  	gbx - globe descriptor part
  	dkx - disk descriptor part:
<div><div><code class="listing"><span class="code-output"> 	  gd = {cd:cd, gbx:pd, dkx:rd, sund:sund}</span>
</code></div></div></p>

<h2> Calculating the limb, ring and planet center</h2>

<h3> Determining the plot characteristics</h3>

<p>  This section uses pg_limb to calculate the limb point structure (limb_ptd)
  containing the limb points, the ring point structure (ring_ptd) and also
  the planet center (center_ptd) using the routine pg_center.  It uses the
  generic descriptor (gd) to pass the camera, planet and ring descriptors
  to these routines.  It also uses pg_hide to remove (/rm) points from the
  ring from the limb points and then again to remove the ring points
  covered by the planet.  It then groups each of these into
  object_ptd for plotting.  The colors, psyms, psizes and plables variables
  are defined for the plot.  The center is drawn in the default color
  (!p.color), the limb is in yellow (ctyellow) and the inner and outer ring
  are in red (ctred).  Here you can see that each ring is treated as two
  objects (inner and outer) when defining plot characteristics.  With an
  8-bit display, these color routines return the values that were previously
  reserved in the color table with ctmod; with a 24-bit display, these
  routines return the true color values for these colors.  nlimb stores the
  number of points in the limb_ptd structure, nring, the number of points in
  the ring point structure.  In plabels, the limb and ring's name is not
  plotted since it would be plotted at the center of the object:
<div><div><code class="listing"><span class="code-output"> limb_ptd = pg_limb(gd=gd) & pg_hide, limb_ptd, gd=gd, bx=rd</span>
<span class="code-output"> ring_ptd = pg_disk(gd=gd) & pg_hide, ring_ptd, gd=gd, bx=pd</span>
<span class="code-output"> shadow_ptd = pg_shadow_globe(gd=gd, ring_ptd)</span>
<span class="code-output"> center_ptd = pg_center(gd=gd, bx=pd)</span>
<span class="code-output"> object_ptd = [center_ptd,limb_ptd,ring_ptd,shadow_ptd]</span>
<span class="code-output"> colors = [!p.color,ctyellow(),ctred(),ctred(),ctblue()] & psyms=[1,3,3,3,3] & psizes=[0.5]</span>
<span class="code-output"> plabels = [cor_name(pd), '', '']</span>
<span class="code-output"> nlimb = n_elements(limb_ptd)</span>
<span class="code-output"> nring = n_elements(ring_ptd)</span>
</code></div></div></p>

<h2> Drawing the limb, ring and planet center</h2>

<p>	<img src="saturn_limb.jpeg"/>
</p>

<p> This section draws the objects in the object structure (center, limb
 and ring) with the colors and plot symbols and labels defined earlier.
 Notice how the limb and ring curves cut off at the points of intersection
 between the objects:
<div><div><code class="listing"><span class="code-output"> pg_draw, object_ptd, colors=colors, psyms=psyms, psizes=psizes, plabel=plabels</span>
</code></div></div></p>

<h2> Draw planet and ring latitude/longitude grid</h2>

<p>	<img src="saturn_grid.jpeg"/>
</p>

<p>   This sections calculates a latitude/longitude grid for the planet and a
  	radius/longitude grid for the rings.  By default it draws 12 latitude
  	and 12 longitude grid lines.  The longitude grid lines circle the body
  	and so on a map they will appear as 24 grid lines.  The ring radius grid
  	uses four grid lines by default between the inner and outer ring radius.
  	It uses pg_hide to set as not visible the points on the grid behind the
  	planet and ring for both objects.  It then uses pg_draw to draw the
  	planet grid points in blue (ctblue) and the ring grid points in purple
  	(ctpurple).
</p>

<p>  	Here is where the example then stops:
<div><div><code class="listing"><span class="code-output"> 	  grid_ptd = pg_grid(gd=gd, bx=pd)</span>
<span class="code-output">    pg_hide, grid_ptd, gd=gd, bx=pd, /assoc</span>
<span class="code-output">    pg_hide, grid_ptd, gd=gd, bx=rd</span>
<span class="code-output">    pg_draw, grid_ptd, color=ctblue()</span>

<span class="code-output">    dgrid_ptd = pg_grid(gd=gd, bx=rd) & pg_hide, dgrid_ptd, gd=gd, bx=pd</span>
<span class="code-output">    pg_draw, dgrid_ptd, color=ctpurple()</span>
</code></div></div></p>

<h2> First-cut automatic repointing</h2>

<p>  In this section, pg_farfit is used to automatically calculate a pointing
  correction, by fitting a curve to the planet's limb.
</p>

<p>  First, we draw a clean image:
<div><div><code class="listing"><span class="code-output">  tvim, im</span>
</code></div></div>  Then, we calculate the edges in the image with pg_edges, and draw them:
<div><div><code class="listing"><span class="code-output">  edge_ptd = pg_edges(dd, edge=50)</span>
<span class="code-output">  pg_draw, edge_ptd</span>

</code></div></div>  <img src="saturn_edge_1.jpeg"/>
</p>

<p>  Now, pg_farfit is used to find a x/y offset, by fitting the points in edge_ptd
  (the edges found in the image) to the points that make up the limb, rings and
  shadow (limb_ptd, ring_ptd, shadow_ptd):
<div><div><code class="listing"><span class="code-output">  dxy = pg_farfit(dd, edge_ptd, [limb_ptd[0], ring_ptd[1], shadow_ptd[0]])</span>
</code></div></div>  Now, we use pg_repoint to apply the dxy offsets, and calculate new limb, ring
  shadow points:
<div><div><code class="listing"><span class="code-output">  pg_repoint, dxy, 0d, axis=center_ptd[0], gd=gd</span>
<span class="code-output">  limb_ptd = pg_limb(gd=gd) & pg_hide, limb_ptd, gd=gd, bx=rd, /rm</span>
<span class="code-output">  ring_ptd = pg_disk(gd=gd) & pg_hide, ring_ptd, gd=gd, bx=pd, /rm</span>
<span class="code-output">  shadow_ptd = pg_shadow_globe(gd=gd, ring_ptd)</span>
<span class="code-output">  center_ptd = pg_center(gd=gd, bx=pd)</span>
<span class="code-output">  object_ptd = [center_ptd,limb_ptd,ring_ptd,shadow_ptd]</span>

</code></div></div>  Now, we draw the newly-derived limb, ring and shadow points on a clean image:
<div><div><code class="listing"><span class="code-output">  tvim, im</span>
<span class="code-output">  pg_draw, object_ptd, colors=colors, psyms=psyms, psizes=psizes, plabel=plabels</span>

</code></div></div>  <img src="saturn_edge_2.jpeg"/>
</p>

<p></p>

<h2> Manually repointing the geometry</h2>

<p>  This pasteable section first clears the screen of the plotted points
  by redisplaying the image with tvim.  It then calls pg_drag to allow
  the user to use the cursor to drag the pointing, and with it the limb,
  ring and planet center.  To move the pointing with pg_drag, use the left
  mouse button and translate the pointing in x,y.  Use the middle mouse
  button to rotate the pointing about an axis (in this case, the axis of
  rotation is set as the planet center (center_ptd[0]).  When the
  desired pointing is set, the right mouse button accepts it.  pg_drag
  returns the delta x,y amount dragged (dxy) as well as the rotation
  angle (dtheta).  pg_repoint uses the dxy and dtheta to update the
  camera descriptor (cd, passed by gd).  The limb and center is then
  recalculated, the image redisplayed to clear the objects drawn, and
  then pg_draw is called to replot:
<div><div><code class="listing"><span class="code-output"> tvim, im</span>
<span class="code-output"> dxy = pg_drag(object_ptd, dtheta=dtheta, axis=center_ptd[0])</span>
<span class="code-output"> pg_repoint, dxy, dtheta, axis=center_ptd[0], gd=gd</span>

<span class="code-output"> limb_ptd = pg_limb(gd=gd) & pg_hide, limb_ptd, gd=gd, bx=rd, /rm</span>
<span class="code-output"> ring_ptd = pg_disk(gd=gd) & pg_hide, ring_ptd, gd=gd, bx=pd, /rm</span>
<span class="code-output"> shadow_ptd = pg_shadow_globe(gd=gd, ring_ptd)</span>
<span class="code-output"> center_ptd = pg_center(gd=gd, bx=pd)</span>
<span class="code-output"> object_ptd = [center_ptd,limb_ptd,ring_ptd,shadow_ptd]</span>

<span class="code-output"> tvim, im</span>
<span class="code-output"> pg_draw, object_ptd, colors=colors, psyms=psyms, psizes=psizes, plabel=plabels</span>
</code></div></div></p>

<h2> Scanning the edge to find the limb and using it to calculate the pointing</h2>

<p>  This section calls pg_cvscan to scan the image around the predicted
  limb position and the ring edge position (within width of 80 pixels) and
  find the points of highest correlation with a given edge model for each
  object (edge_model_nav_limb = limb model used in the VICAR program NAV
  and edge_model_nav_ring = ring model from NAV) and zeropoint offset in
  the given model (lzero).  These points are then plotted:
<div><div><code class="listing"><span class="code-output"> cvscan_ptd = pg_cvscan(dd, gd=gd, [limb_ptd,ring_ptd], edge=30, width=80, $</span>
<span class="code-output"> model=[make_array(nlimb,val=ptr_new(edge_model_nav_limb(zero=lzero))), $</span>
<span class="code-output">   make_array(nring,val=ptr_new(edge_model_nav_ring(zero=rzero)))], $</span>
<span class="code-output">   mzero=[make_array(nlimb,val=lzero),$</span>
<span class="code-output">   make_array(nring,val=rzero)] )</span>
<span class="code-output"> tvim, im</span>
<span class="code-output"> pg_draw, cvscan_ptd</span>

</code></div></div>  <img src="saturn_scan_1.jpeg"/>
</p>

<p></p>

<h2> Thresholding using correlation coefficient</h2>

<p>  This section (optional) calls pg_threshold to remove points with lower
  correlation coefficients.  The /relative flag means that the minimum
  and maximum thresholds are taken as a fraction to the maximum value
  in the array.  Notice here again that the ring is treated as two
  objects:
<div><div><code class="listing"><span class="code-output"> pg_threshold, cvscan_ptd, min=[0.8, 1.0, 0.8], max=[1.2, 1.0, 1.2], /rel</span>
<span class="code-output"> tvim, im</span>
<span class="code-output"> pg_draw, cvscan_ptd</span>

</code></div></div>  <img src="saturn_scan_2.jpeg"/>
</p>

<h2> Removing regions of bad points</h2>

<p>  This section (optional) calls pg_select to remove points within a
  polygonal region as defined by the cursor.  Click the left mouse
  button to mark a point and move the mouse to the next point and
  click.  Use the middle mouse button to erase a point and the right
  mouse button to end the region.  pg_trim removes the points in the
  just defined region.  The scan points are then replotted.
  Repeat these statements for each region a user wants to remove:
<div><div><code class="listing"><span class="code-output"> region = pg_select(dd)</span>
<span class="code-output"> pg_trim, dd, cvscan_ptd, region</span>
<span class="code-output"> tvim, im</span>
<span class="code-output"> pg_draw, cvscan_ptd</span>
</code></div></div></p>

<h2> Fitting the pointing to the scanned points</h2>

<p>  This section calls pg_cvscan_coeff to determine the linear least-squares
  coefficients for a fit to the image coordinate translation and rotation
  which matches the computed curve to the scanned curve. It then calls
  pg_fit to do the fit with the calculated coefficients to calculate the
  correction in translation (dxy) and rotation (dtheta).  It calls
  pg_cvchisq to get the chi square of the fit.  Then calls pg_repoint to
  update the pointing. Recalculates the limb and center and replots.
  The determination of the curves and their subsequent fit can be
  iterated on:
<div><div><code class="listing"><span class="code-output"> cvscan_cf = pg_cvscan_coeff(cvscan_ptd, axis=center_ptd[0])</span>
<span class="code-output"> dxy = pg_fit([cvscan_cf], dtheta=dtheta)</span>
<span class="code-output"> chisq = pg_chisq(dxy, dtheta, cvscan_ptd, axis=center_ptd[0])</span>
<span class="code-output"> print, dxy, dtheta*180./!pi, chisq</span>
<span class="code-output"> pg_repoint, dxy, dtheta, axis=center_ptd[0], gd=gd</span>

<span class="code-output"> limb_ptd = pg_limb(gd=gd) & pg_hide, limb_ptd, gd=gd, bx=rd, /rm</span>
<span class="code-output"> ring_ptd = pg_disk(gd=gd) & pg_hide, ring_ptd, gd=gd, bx=pd, /rm</span>
<span class="code-output"> center_ptd = pg_center(gd=gd, bx=pd)</span>
<span class="code-output"> object_ptd = [center_ptd,limb_ptd,ring_ptd]</span>

<span class="code-output"> tvim, im</span>
<span class="code-output"> pg_draw, object_ptd, colors=colors, psyms=psyms, psizes=psizes, plabel=plabels</span>

</code></div></div></p>

<h2> Draw planet and ring latitude/longitude grid</h2>

<p>  This sections calculates a latitude/longitude grid for each planet and a
  radius/longitude grid for the rings.  By default it draws 12 latitude
  and 12 longitude grid lines.  The longitude grid lines circle the body
  and so on a map they will appear as 24 grid lines.  The ring radius grid
  uses four grid lines by default between the inner and outer ring radius.
  It uses pg_hide to set as not visible the points on the grid behind the
  planet and ring for both objects.  It then uses pg_draw to draw the
  grid points in blue (ctblue):
<div><div><code class="listing"><span class="code-output"> tvim, im</span>
<span class="code-output"> grid_ptd = pg_grid(gd=gd, lat=lat, lon=lon)</span>
<span class="code-output"> pg_hide, grid_ptd, cd=cd, gbx=pd, /assoc</span>
<span class="code-output"> pg_hide, grid_ptd, cd=cd, gbx=pd, od=sund, /assoc</span>
<span class="code-output"> pg_hide, grid_ptd, gd=gd, bx=rd</span>
<span class="code-output"> pg_draw, grid_ptd, color=ctblue()</span>

<span class="code-output"> plat_ptd = pg_grid(gd=gd, slon=!dpi/2d, lat=lat, nlon=0)</span>
<span class="code-output"> pg_hide, plat_ptd[0], cd=cd, gbx=pd[0], /assoc</span>
<span class="code-output"> pg_draw, plat_ptd[0], psym=3, plabel=strtrim(round(lat*180d/!dpi),2), /label_p</span>

<span class="code-output"> plon_ptd = pg_grid(gd=gd, slat=0d, lon=lon, nlat=0)</span>
<span class="code-output"> pg_hide, plon_ptd[0], cd=cd, gbx=pd[0], /limb</span>
<span class="code-output"> pg_draw, plon_ptd[0], psym=3, plabel=strtrim(round(lon*180d/!dpi),2), /label_p</span>

<span class="code-output"> dgrid_ptd = pg_grid(gd=gd, bx=rd) & pg_hide, dgrid_ptd, gd=gd, bx=pd</span>
<span class="code-output"> pg_draw, dgrid_ptd, color=ctpurple()</span>

</code></div></div>  <img src="saturn_latlon.jpeg"/>
</p>

<p></p>

<h2> Defining a ring sector for a plot</h2>

<p>  To plot a ring radius vs. intensity or longitude vs. intensity, the
  user must first define the limits of the ring sector.  Here it is
  done in one of two ways, the first is to define the longitude (lon)
  and radius (rad) limits in an array.  The second method is to use
  the cursor to sweep out a ring sector, pg_ring_sector is called to
  do this.  To use the mouse, click in one corner of your desired sector
  and drag the cursor to the opposite corner.  In this example,
  counterclockwise is the direction of increasing longitude.  The chosen
  sector is then calculated using pg_profile_ring with the /outline
  keyword.  This outline is then drawn with pg_draw:
<div><div><code class="listing"><span class="code-output"> tvim,im</span>
<span class="code-output"> outline_ptd = pg_ring_sector(gd=gd, rad=rad, lon=lon, slope=slope)</span>
<span class="code-output"> pg_draw, outline_ptd, col=ctgreen()</span>

</code></div></div>  <img src="saturn_sector_1.jpeg"/>
</p>

<p></p>

<h2> Plotting ring sector plots</h2>

<p>     Below is the code for four different types of plots using pg_profile_ring.
     Radial (default) and longitudinal (/azimuthal), interpolated (default)
     and binned (/bin).  There is an oversamp keyword which defines the amount
     to oversample (vs. 1 pixel).  In the case of a longitudinal bin scan,
     pixelization can cause some bins to contain very low numbers or none at
     all.  In this example oversamp=0.3 to cause the plot to have larger bins
     to help alleviate this problem.  The calculated profile is then plotted
     in a new window.
</p>

<p>     Radial scan:
<div><div><code class="listing"><span class="code-output">   dd_prof=pg_profile_ring(dd, gd=gd, outline_ptd, dsk_pts=dsk_pts, profile=profile)</span>
<span class="code-output">   window, /free, xs=500, ys=300</span>
<span class="code-output">   plot, dsk_pts[*,0], profile</span>

</code></div></div>     <img src="saturn_sector_2.jpeg"/>
</p>

<p>     Longitudinal scan:
<div><div><code class="listing"><span class="code-output"> dd_prof = pg_profile_ring(dd, gd=gd, outline_ptd, /azimuthal, dsk_pts=dsk_pts, profile=profile)</span>
<span class="code-output"> window, /free, xs=500, ys=300</span>
<span class="code-output"> plot, dsk_pts[*,1], profile, /yno</span>

</code></div></div>     <img src="saturn_sector_3.jpeg"/>
</p>

<p></p>

</div>
      </div>
      

      

      

      

      

      

      

      

      

      

      <div id="attributes">
        <h2>File attributes</h2>

        <table class="attribute small" summary="File attributes">
          <tr>
            <td class="name">Modification date:</td>
            <td>Tue Jul 18 11:30:24 2017</td>
          </tr>

          <tr>
            <td class="name">Lines:</td>
            <td>149</td>
          </tr>

          
          <tr>
            <td class="name">Docformat:</td>
            <td>rst rst</td>
          </tr>
          
        </table>
      </div>

      
    </div>

    <div class="footer">
    
      <table class="smaller" summary="footer">
        <tr>
          <td class="left">Produced by IDLdoc 3.6.1 on Tue Jul 18 15:09:52 2017</td>
          <td class="right"><a target="_top" href="http://github.com/mgalloy/idldoc">IDLdoc project information</a></td>
        </tr>
      </table>
    
    </div>
  </body>
</html>