/* Index used for searching */
/*
   Fields used:
     url, name, type, filename, authors, routine name, comments, parameters,
     categories, and attributes
*/
title = "OMINAS API Documentation";
subtitle = "Generated by IDLdoc";
libdata = new Array();
libdataItem = 0;



libdata[libdataItem++] = new Array("./boresight_example.html", "boresight_example.pro", '.pro file in <a href="./dir-overview.html">./ directory</a>', "boresight_example.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("./grim_example.html", "grim_example.pro", '.pro file in <a href="./dir-overview.html">./ directory</a>', "grim_example.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("./install_guide.html", "install_guide.pro", '.pro file in <a href="./dir-overview.html">./ directory</a>', "install_guide.pro", "", "", "	User Installation Guide  	This guide will cover the installation of OMINAS and common issues with 	configuration, as well as present some common errors and possible 	solutions. Please see the section entitled Troubleshooting for more 	information regarding installation issues with OMINAS.  	Requirements  	Currently OMINAS requires IDL 8.2.3 or above, and a bash shell, on Linux or 	Mac OS.  	To process images from a particular mission, that mission's kernels will 	need to be available. The OMINAS installer can automatically download sets of 	kernels for several missions (Cassini, Galileo, Voyager, Dawn).  	OMINAS makes use of the NAIF Icy Toolkit to process SPICE kernels. The Icy 	toolkit may optionally be obtained manually from 	NAIF. However, the 	installer utility provided with OMINAS can download and compile Icy 	automatically. Installation of Icy is somewhat platform-dependent, so 	troubleshooting information can be found in Troubleshooting.  	Procedure  	1. Please ensure that OMINAS has been properly downloaded from the 	Github repository by entering 	the following command at the terminal: <span class= code-output > git clone https://github.com/ppenteado/ominas</span> 	A local copy of the OMINAS source will be cloned automatically.  	2. Configuration of OMINAS should be performed using the configuration 	script, configure.sh, which is located in the top-level ominas directory. 	This script can be run from the command line with: <span class= code-output > source configure.sh</span> 	3. A prompt will appear asking which packages should be installed. The 	user should type the numbers of the desired packages separated by spaces. 	We recomend, at a minimum, setting up packages 1, 2 and 3 (OMINAS Core, Demo and Icy). 	To automatically download and setup all the packages, use the all option.  	4. When setting up an individual kernel or data package (selections 4-13), 	one can either provide a path for an existing directory containing the required files, 	or tell the installer to download them.  	5. Test the install of OMINAS has been completed correctly by running the 	the following example scripts: <span class= code-output > ominas saturn_example.pro</span> <span class= code-output > ominas jupiter_example.pro</span> 	6. A successful Icy installation can be tested with the following IDL 	command from within an OMINAS IDL session: <span class= code-output > help, 'icy', /dlm</span> 	Some text on the installed version of Icy should be displayed. Additionally, 	use the following command: <span class= code-output > print, cspice_tkvrsn('TOOLKIT')</span> 	The version of Icy should be printed. If both of these functions return 	successfully, then Icy has been installed correctly.   Example installation walkthrough   From a fresh account (that never had OMINAS, Icy or any IDL libraries setup  before), for the 3 main packages (Core, Demo and Icy): <span class= code-output > ;[ominas_test_8@cmp ~]$ git clone https://github.com/ppenteado/ominas.git</span> <span class= code-output > ;Cloning into 'ominas'...</span> <span class= code-output > ;Username for 'https://github.com': ppenteado</span> <span class= code-output > ;Password for 'https://ppenteado@github.com':</span> <span class= code-output > ;remote: Counting objects: 13377, done.</span> <span class= code-output > ;remote: Compressing objects: 100% (85/85), done.</span> <span class= code-output > ;remote: Total 13377 (delta 51), reused 71 (delta 34), pack-reused 13258</span> <span class= code-output > ;Receiving objects: 100% (13377/13377), 200.48 MiB | 8.10 MiB/s, done.</span> <span class= code-output > ;Resolving deltas: 100% (7628/7628), done.</span> <span class= code-output > ;Checking connectivity... done.</span> <span class= code-output > ;Checking out files: 100% (3479/3479), done.</span>  At this point, a copy of OMINAS will be in a newly-created directory called  ominas, under the current directory. Note that if a non-empty ominas directory  was already present, git would notice it and refuse to download OMINAS into that  directory.    Now, getting into the ominas directory and running the installer: <span class= code-output >;[ominas_test_8@cmp ~]$ cd ominas/</span> <span class= code-output >;[ominas_test_8@cmp ominas]$ source configure.sh</span> <span class= code-output >;Detecting .bash_profile...</span> <span class= code-output >;.bash_profile detected!</span> <span class= code-output >;Detecting .bashrc...</span> <span class= code-output >;.bashrc detected!</span> <span class= code-output >;Using IDL at /usr/local/bin/idl</span> <span class= code-output >;IDL Version 8.5.1 (linux x86_64 m64). (c) 2015, Exelis Visual Information Solutions, Inc., a subsidiary of Harris Corporation.</span> <span class= code-output >;Installation number: XXXXXX.</span> <span class= code-output >;Licensed for use by: XXXXXX</span> <span class= code-output >;</span> <span class= code-output >;Creating ~/.ominas directory</span> <span class= code-output >;Creating ~/ominas_data directory</span> <span class= code-output >;The setup will guide you through the installation of OMINAS</span> <span class= code-output >;OMINAS files located in /home/ominas_test_8/ominas</span> <span class= code-output >;</span> <span class= code-output >;IDL Version 8.5.1 (linux x86_64 m64). (c) 2015, Exelis Visual Information Solutions, Inc., a subsidiary of Harris Corporation.</span> <span class= code-output >;Installation number: XXXXX.</span> <span class= code-output >;Licensed for use by: XXXXX</span> <span class= code-output >;</span> <span class= code-output >;% Compiled module: OMINAS_ICY_TEST.</span> <span class= code-output >;Icy: Icy not found</span> <span class= code-output >;Current OMINAS configuration settings</span> <span class= code-output >;Required:</span> <span class= code-output >;1) OMINAS Core  . . . . . . . . . . . . .  NOT CONFIGURED</span> <span class= code-output >;Contains the OMINAS code. If you select only one</span> <span class= code-output >;of the other packages, this will be included.</span> <span class= code-output >;Optional packages:</span> <span class= code-output >;2) Demo package . . . . . . . . . . . . .  NOT CONFIGURED</span> <span class= code-output >;Contains the demo scripts and the data required</span> <span class= code-output >;to run then.</span> <span class= code-output >;These files are always present (in ominas/demo),</span> <span class= code-output >;this option is to set up the environment so that</span> <span class= code-output >;the demos can be run.</span> <span class= code-output >;3) SPICE Icy  . . . . . . . . . . . . . .  NOT CONFIGURED</span> <span class= code-output >;Library maintained by JPL's NAIF (Navigation and Ancillary</span> <span class= code-output >;Information Facility, https://naif.jpl.nasa.gov/naif/toolkit.html,</span> <span class= code-output >;required to use spacecraft / planetary kernel files.</span> <span class= code-output >;</span> <span class= code-output >;Mission Packages:</span> <span class= code-output >;Kernels used for each mission's position and</span> <span class= code-output >;pointing data. If you do not already have them,</span> <span class= code-output >;an option to download them from PDS will be provided.</span> <span class= code-output >;If you already have them, you will need to provide</span> <span class= code-output >;the path to your kernel files.</span> <span class= code-output >;Note: the NAIF Generic Kernels (one of the optional</span> <span class= code-output >;data packages) are not required for the missions, they</span> <span class= code-output >;already contain a copy the subset of the generic kernel</span> <span class= code-output >;files they need.</span> <span class= code-output >;4) Cassini . . . . . . . . . . . . . . . . NOT CONFIGURED</span> <span class= code-output >;Subsetted, about 16 GB as of Dec/2016</span> <span class= code-output >;5) Galileo (GLL) . . . . . . . . . . . . . NOT CONFIGURED</span> <span class= code-output >;About 833 MB as of Dec/2016</span> <span class= code-output >;6) Voyager . . . . . . . . . . . . . . . . NOT CONFIGURED</span> <span class= code-output >;About 163 MB as of Dec/2016</span> <span class= code-output >;7) Dawn  . . . . . . . . . . . . . . . . . NOT CONFIGURED</span> <span class= code-output >;Subsetted, about 8 GB as of Jan/2017</span> <span class= code-output >;Data:</span> <span class= code-output >;8) NAIF Generic Kernels . . . . . . . . .  NOT CONFIGURED</span> <span class= code-output >;About 22 GB as of Dec/2016</span> <span class= code-output >;9) SEDR image data . . . . . . . . . . . . NOT CONFIGURED</span> <span class= code-output >;10) TYCHO2 star catalog . . . . . . . . . . NOT CONFIGURED</span> <span class= code-output >;About 161 MB download, 665 MB unpacked</span> <span class= code-output >;11) SAO star catalog . . . . . . . . . . . NOT CONFIGURED</span> <span class= code-output >;About 19 MB download, 70 MB unpacked</span> <span class= code-output >;12) GSC star catalog . . . . . . . . . . . NOT CONFIGURED</span> <span class= code-output >;13) UCAC4 star catalog . . . . . . . . . . NOT CONFIGURED</span> <span class= code-output >;About 8.5 GB download</span> <span class= code-output >;For more information, see</span> <span class= code-output >;https://ppenteado.github.io/ominas_doc/demo/install_guide.html</span> <span class= code-output >;Modify Current OMINAS configuration (Exit/Auto/Uninstall 1 2 ...)?  1 2 3</span> <span class= code-output >;Settiing OMINAS Core...</span> <span class= code-output >;OMINAS requires the NAIF Icy toolkit to process SPICE kernels.</span> <span class= code-output >;Would you like to install Icy from the internet now? [y]</span> <span class= code-output >;http://naif.jpl.nasa.gov/pub/naif/toolkit//IDL/PC_Linux_GCC_IDL8.x_64bit/packages/icy.tar.Z ~/ominas_data/icy.tar.Z</span> <span class= code-output >;http://naif.jpl.nasa.gov/pub/naif/toolkit//IDL/PC_Linux_GCC_IDL8.x_64bit/packages/icy.tar.Z --localdir=/home/ominas_test_8/ominas_data/</span> <span class= code-output >;</span> <span class= code-output >;IDL Version 8.5.1 (linux x86_64 m64). (c) 2015, Exelis Visual Information Solutions, Inc., a subsidiary of Harris Corporation.</span> <span class= code-output >;Installation number: XXXXXX.</span> <span class= code-output >;Licensed for use by: XXXXXX</span> <span class= code-output >;</span> <span class= code-output >;% Compiled module: PP_WGETCL.</span> <span class= code-output >;% Compiled module: PP_COMMAND_LINE_ARGS_PARSE.</span> <span class= code-output >;% Loaded DLM: URL.</span> <span class= code-output >;% Compiled module: PP_WGET__DEFINE.</span> <span class= code-output >;util/downloader/ca-bundle.crt</span> <span class= code-output >;% Compiled module: PARSE_URL.</span> <span class= code-output >;downloading http://naif.jpl.nasa.gov/pub/naif/toolkit//IDL/PC_Linux_GCC_IDL8.x_64bit/packages/icy.tar.Z</span> <span class= code-output >;% Compiled module: PP_READABLESIZE.</span> <span class= code-output >;Content Length:  276.00000 B</span> <span class= code-output >;% Compiled module: PP_PARSE_DATE.</span> <span class= code-output >;% Compiled module: JULDAY.</span> <span class= code-output >;Content Length:  43.669736 MB</span> <span class= code-output >;% Compiled module: CALDAT.</span> <span class= code-output >;Extracting Icy source files...</span> <span class= code-output >;Compiling Icy...</span> <span class= code-output >;Icy compiled. Log is at ~/.ominas/icy_make.log</span> <span class= code-output >;writing /home/ominas_test_8/.ominas/ominas_setup.sh</span> <span class= code-output >;‘/home/ominas_test_8/.ominas/ominas_setup.sh’ -&gt; ‘/home/ominas_test_8/.ominas/ominas_setup_old.sh’</span> <span class= code-output >;</span> <span class= code-output >;</span> <span class= code-output >;</span> <span class= code-output >;</span> <span class= code-output >;</span> <span class= code-output >;</span> <span class= code-output >;done with writing /home/ominas_test_8/.ominas/ominas_setup.sh</span> <span class= code-output >;IDL Version 8.5.1 (linux x86_64 m64). (c) 2015, Exelis Visual Information Solutions, Inc., a subsidiary of Harris Corporation.</span> <span class= code-output >;Installation number: XXXXXX.</span> <span class= code-output >;Licensed for use by: XXXXXX</span> <span class= code-output >;</span> <span class= code-output >;% Compiled module: OMINAS_PATHS_ADD.</span> <span class= code-output >;Checking to see if IDL paths need to be changed...</span> <span class= code-output >;% Compiled module: IDLASTRO_DOWNLOAD.</span> <span class= code-output >;% Compiled module: ROUTINE_EXISTS.</span> <span class= code-output >;There are missing IDLAstro routines.</span> <span class= code-output >;Auto installing</span> <span class= code-output >;git clone https://github.com/wlandsman/IDLAstro.git /home/ominas_test_8/ominas_data/idlastro</span> <span class= code-output >;Cloning into '/home/ominas_test_8/ominas_data/idlastro'...</span> <span class= code-output >;remote: Counting objects: 1400, done.</span> <span class= code-output >;remote: Compressing objects: 100% (7/7), done.</span> <span class= code-output >;remote: Total 1400 (delta 1), reused 3 (delta 1), pack-reused 1392</span> <span class= code-output >;Receiving objects: 100% (1400/1400), 11.63 MiB | 4.85 MiB/s, done.</span> <span class= code-output >;Resolving deltas: 100% (556/556), done.</span> <span class= code-output >;Checking connectivity... done.</span> <span class= code-output >;IDLAstro path set in preferences:  &lt;IDL_DEFAULT&gt;:+/home/ominas_test_8/ominas_data/idlastro/pro</span> <span class= code-output >;OMINAS paths set in IDL preferences</span> <span class= code-output >;Icy path set in IDL preferences</span> <span class= code-output >;OMINAS aliase set in /home/ominas_test_8/.bashrc.</span> <span class= code-output >;OMINAS aliase set in /home/ominas_test_8/.bash_profile.</span> <span class= code-output >;IDL Version 8.5.1 (linux x86_64 m64). (c) 2015, Exelis Visual Information Solutions, Inc., a subsidiary of Harris Corporation.</span> <span class= code-output >;Installation number: 5502667.</span> <span class= code-output >;Licensed for use by: NASA - Jet Propulsion Laboratory</span> <span class= code-output >;</span> <span class= code-output >;% Compiled module: OMINAS_ICY_TEST.</span> <span class= code-output >;% Loaded DLM: ICY.</span> <span class= code-output >;Icy: /home/ominas_test_8/ominas_data/icy/lib/icy.so</span> <span class= code-output >;Current OMINAS configuration settings</span> <span class= code-output >;Required:</span> <span class= code-output >;1) OMINAS Core  . . . . . . . . . . . . .  CONFIGURED</span> <span class= code-output >;Contains the OMINAS code. If you select only one</span> <span class= code-output >;of the other packages, this will be included.</span> <span class= code-output >;Optional packages:</span> <span class= code-output >;2) Demo package . . . . . . . . . . . . .  CONFIGURED</span> <span class= code-output >;Contains the demo scripts and the data required</span> <span class= code-output >;to run then.</span> <span class= code-output >;These files are always present (in ominas/demo),</span> <span class= code-output >;this option is to set up the environment so that</span> <span class= code-output >;the demos can be run.</span> <span class= code-output >;3) SPICE Icy  . . . . . . . . . . . . . .  CONFIGURED</span> <span class= code-output >;Library maintained by JPL's NAIF (Navigation and Ancillary</span> <span class= code-output >;Information Facility, https://naif.jpl.nasa.gov/naif/toolkit.html,</span> <span class= code-output >;required to use spacecraft / planetary kernel files.</span> <span class= code-output >;</span> <span class= code-output >;Mission Packages:</span> <span class= code-output >;Kernels used for each mission's position and</span> <span class= code-output >;pointing data. If you do not already have them,</span> <span class= code-output >;an option to download them from PDS will be provided.</span> <span class= code-output >;If you already have them, you will need to provide</span> <span class= code-output >;the path to your kernel files.</span> <span class= code-output >;Note: the NAIF Generic Kernels (one of the optional</span> <span class= code-output >;data packages) are not required for the missions, they</span> <span class= code-output >;already contain a copy the subset of the generic kernel</span> <span class= code-output >;files they need.</span> <span class= code-output >;4) Cassini . . . . . . . . . . . . . . . . NOT CONFIGURED</span> <span class= code-output >;Subsetted, about 16 GB as of Dec/2016</span> <span class= code-output >;5) Galileo (GLL) . . . . . . . . . . . . . NOT CONFIGURED</span> <span class= code-output >;About 833 MB as of Dec/2016</span> <span class= code-output >;6) Voyager . . . . . . . . . . . . . . . . NOT CONFIGURED</span> <span class= code-output >;About 163 MB as of Dec/2016</span> <span class= code-output >;7) Dawn  . . . . . . . . . . . . . . . . . NOT CONFIGURED</span> <span class= code-output >;Subsetted, about 8 GB as of Jan/2017</span> <span class= code-output >;Data:</span> <span class= code-output >;8) NAIF Generic Kernels . . . . . . . . .  NOT CONFIGURED</span> <span class= code-output >;About 22 GB as of Dec/2016</span> <span class= code-output >;9) SEDR image data . . . . . . . . . . . . NOT CONFIGURED</span> <span class= code-output >;10) TYCHO2 star catalog . . . . . . . . . . NOT CONFIGURED</span> <span class= code-output >;About 161 MB download, 665 MB unpacked</span> <span class= code-output >;11) SAO star catalog . . . . . . . . . . . NOT CONFIGURED</span> <span class= code-output >;About 19 MB download, 70 MB unpacked</span> <span class= code-output >;12) GSC star catalog . . . . . . . . . . . NOT CONFIGURED</span> <span class= code-output >;13) UCAC4 star catalog . . . . . . . . . . NOT CONFIGURED</span> <span class= code-output >;About 8.5 GB download</span> <span class= code-output >;For more information, see</span> <span class= code-output >;https://ppenteado.github.io/ominas_doc/demo/install_guide.html</span> <span class= code-output >;Modify Current OMINAS configuration (Exit/Auto/Uninstall 1 2 ...)?  e</span> <span class= code-output >;Setup has completed. It is recommended to restart your terminal session before using OMINAS.</span> <span class= code-output >;You may want to try some of the tutorials at https://ppenteado.github.io/ominas_doc/demo/</span>   At this point, one can run a few tests of the enviroment: <span class= code-output > ;[ominas_test_8@cmp ominas]$ which ominas</span> <span class= code-output > ;alias ominas='/home/ominas_test_8/.ominas/ominas'</span> <span class= code-output > ;~/.ominas/ominas</span> <span class= code-output > ;[ominas_test_8@cmp ominas]$ which ominasde</span> <span class= code-output > ;alias ominasde='/home/ominas_test_8/.ominas/ominasde'</span> <span class= code-output > ;~/.ominas/ominasde</span>  Which shows both ominas and ominasde are defined. Use ominas to start and IDL  session in which to use OMINAS, and ominasde to start an IDL DE session in  which to use OMINAS.   Now, to check on the ominas_setup file, which sets the environment for the OMINAS  core and all currently set packages (in this example, only Core, Demo and Icy are set): <span class= code-output > ;[ominas_test_8@cmp ominas]$ cat ~/.ominas/ominas_setup.sh</span> <span class= code-output > ;#!/usr/bin/env bash</span> <span class= code-output > ;alias ominas=~/.ominas/ominas</span> <span class= code-output > ;alias ominasde=~/.ominas/ominasde</span> <span class= code-output > ;export OMINAS_DIR=/home/ominas_test_8/ominas</span> <span class= code-output > ;export DFLAG=true</span> <span class= code-output > ;source /home/ominas_test_8/ominas/config/ominas_env_def.sh</span> <span class= code-output > ;unset NV_Generic_kernels_DATA</span> <span class= code-output > ;unset NV_SEDR_DATA</span> <span class= code-output > ;unset NV_TYCHO2_DATA</span> <span class= code-output > ;unset NV_SAO_DATA</span> <span class= code-output > ;unset NV_GSC_DATA</span> <span class= code-output > ;unset NV_UCAC4_DATA</span>  Now, to check that the right environment is see from an OMINAS session: <span class= code-output > ;[ominas_test_8@cmp ominas]$ ominas -e 'spawn, env | grep NV '</span> <span class= code-output > ;IDL Version 8.5.1 (linux x86_64 m64). (c) 2015, Exelis Visual Information Solutions, Inc., a subsidiary of Harris Corporation.</span> <span class= code-output > ;Installation number: XXXXX.</span> <span class= code-output > ;Licensed for use by: XXXXX</span> <span class= code-output > ;</span> <span class= code-output > ;NV_TRANSLATORS=/home/ominas_test_8/ominas/config/tab/translators.tab:/home/ominas_test_8/ominas/demo/data/translators.tab</span> <span class= code-output > ;NV_CONFIG=/home/ominas_test_8/ominas/config</span> <span class= code-output > ;NV_IO=/home/ominas_test_8/ominas/config/tab/io.tab</span> <span class= code-output > ;NV_SPICE=/home/ominas_test_8/ominas/config/spice</span> <span class= code-output > ;NV_ORBIT_DATA=/home/ominas_test_8/ominas/config/orb/</span> <span class= code-output > ;NV_ARRAY_DATA=/home/ominas_test_8/ominas/config/arr/dat/</span> <span class= code-output > ;NV_TRANSFORMS=/home/ominas_test_8/ominas/config/tab/transforms.tab:/home/ominas_test_8/ominas/demo/data/transforms.tab</span> <span class= code-output > ;NV_STATION_DATA=/home/ominas_test_8/ominas/config/stn/</span> <span class= code-output > ;NV_RING_DATA=/home/ominas_test_8/ominas/config/rings/</span> <span class= code-output > ;NV_FTP_DETECT=/home/ominas_test_8/ominas/config/tab/filetype_detectors.tab</span> <span class= code-output > ;NV_SPICE_KER=::/home/ominas_test_8/ominas/demo/data</span> <span class= code-output > ;NV_INS_DETECT=/home/ominas_test_8/ominas/config/tab/instrument_detectors.tab:/home/ominas_test_8/ominas/demo/data/instrument_detectors.tab</span>  Now, to check that the OMINAS paths show up inside an OMINAS IDL session: <span class= code-output > ;[ominas_test_8@cmp ominas]$ ominas -e 'print,pref_get( IDL_PATH )'</span> <span class= code-output > ;IDL Version 8.5.1 (linux x86_64 m64). (c) 2015, Exelis Visual Information Solutions, Inc., a subsidiary of Harris Corporation.</span> <span class= code-output > ;Installation number: XXXXX.</span> <span class= code-output > ;Licensed for use by: XXXXX</span> <span class= code-output > ;</span> <span class= code-output > ;&lt;IDL_DEFAULT&gt;:+/home/ominas_test_8/ominas_data/idlastro/pro:+/home/ominas_test_8/ominas_data/icy/lib:+/home/ominas_test_8/ominas:+/home/ominas_test_8/ominas/util/xidl</span> <span class= code-output > ;[ominas_test_8@cmp ominas]$ ominas -e 'print,pref_get( IDL_DLM_PATH )'</span> <span class= code-output > ;IDL Version 8.5.1 (linux x86_64 m64). (c) 2015, Exelis Visual Information Solutions, Inc., a subsidiary of Harris Corporation.</span> <span class= code-output > ;Installation number: XXXXX.</span> <span class= code-output > ;Licensed for use by: XXXXX</span> <span class= code-output > ;</span> <span class= code-output > ;&lt;IDL_DEFAULT&gt;:+/home/ominas_test_8/ominas_data/icy/lib</span>  With this environment, one can run some demo scripts, such as: <span class= code-output > ;ominas saturn_example</span> <span class= code-output > ;ominas jupiter_example</span>     Testing the environment with ominas_env_info         OMINAS includes a utilty script that prints out the most commonly relevant about your OMINAS environment, which can be useful for debugging        (both for yourself, and when you send us questions). It can be run by calling ominas_env_info, from an ominas/ominasde session. If an argument        is provided, it will be the filename where the output will be saved into (as opposed to printing it to the console). One example: <span class= code-output > ;[user@cmp ~]$ ominas</span> <span class= code-output > ;IDL Version 8.5.1 (linux x86_64 m64). (c) 2015, Exelis Visual Information Solutions, Inc., a subsidiary of Harris Corporation.</span> <span class= code-output > ;Installation number: XXXXXX.</span> <span class= code-output > ;Licensed for use by: XXXXXX</span> <span class= code-output > ;</span> <span class= code-output > ;IDL&gt; ominas_env_info,'~/ominas_env_info.txt'</span>        Which produces: <span class= code-output > ;OMINAS variables:</span> <span class= code-output > ;OMINAS_RC=/home/user/.ominas</span> <span class= code-output > ;OMINAS_DEMO=/home/user/ominas/demo</span> <span class= code-output > ;OMINAS_DIR=/home/user/ominas</span> <span class= code-output > ;OMINAS_DATA=/home/user/ominas_data</span> <span class= code-output > ;--------------------------------------------------------------------------------</span> <span class= code-output > ;NV variables:</span> <span class= code-output > ;NV_TRANSLATORS=/home/user/ominas/config/tab/translators.tab:/home/user/ominas/demo/data/translators.tab</span> <span class= code-output > ;NV_CONFIG=/home/user/ominas/config</span> <span class= code-output > ;NV_IO=/home/user/ominas/config/tab/io.tab</span> <span class= code-output > ;NV_SPICE=/home/user/ominas/config/spice</span> <span class= code-output > ;NV_ORBIT_DATA=/home/user/ominas/config/orb/</span> <span class= code-output > ;NV_ARRAY_DATA=/home/user/ominas/config/arr/dat/</span> <span class= code-output > ;NV_TRANSFORMS=/home/user/ominas/config/tab/transforms.tab:/home/user/ominas/demo/data/transforms.tab</span> <span class= code-output > ;NV_STATION_DATA=/home/user/ominas/config/stn/</span> <span class= code-output > ;NV_RING_DATA=/home/user/ominas/config/rings/</span> <span class= code-output > ;NV_FTP_DETECT=/home/user/ominas/config/tab/filetype_detectors.tab</span> <span class= code-output > ;NV_SPICE_KER=::/home/user/ominas/demo/data</span> <span class= code-output > ;NV_INS_DETECT=/home/user/ominas/config/tab/instrument_detectors.tab:/home/user/ominas/demo/data/instrument_detectors.tab</span> <span class= code-output > ;--------------------------------------------------------------------------------</span> <span class= code-output > ;ominas_setup.sh:</span> <span class= code-output > ;#!/usr/bin/env bash</span> <span class= code-output > ;alias ominas=~/.ominas/ominas</span> <span class= code-output > ;alias ominasde=~/.ominas/ominasde</span> <span class= code-output > ;export OMINAS_DIR=/home/user/ominas</span> <span class= code-output > ;export OMINAS_DATA=/home/user/ominas_data</span> <span class= code-output > ;export OMINAS_RC=/home/user/.ominas</span> <span class= code-output > ;export DFLAG=true</span> <span class= code-output > ;source /home/user/ominas/config/ominas_env_def.sh</span> <span class= code-output > ;unset NV_Generic_kernels_DATA</span> <span class= code-output > ;unset NV_SEDR_DATA</span> <span class= code-output > ;unset NV_TYCHO2_DATA</span> <span class= code-output > ;unset NV_SAO_DATA</span> <span class= code-output > ;unset NV_GSC_DATA</span> <span class= code-output > ;unset NV_UCAC4_DATA</span> <span class= code-output > ;--------------------------------------------------------------------------------</span> <span class= code-output > ;</span> <span class= code-output > ;IDL:</span> <span class= code-output > ;** Structure !VERSION, 8 tags, length=104, data length=100:</span> <span class= code-output > ;   ARCH            STRING    'x86_64'</span> <span class= code-output > ;   OS              STRING    'linux'</span> <span class= code-output > ;   OS_FAMILY       STRING    'unix'</span> <span class= code-output > ;   OS_NAME         STRING    'linux'</span> <span class= code-output > ;   RELEASE         STRING    '8.5.1'</span> <span class= code-output > ;   BUILD_DATE      STRING    'Nov 14 2015'</span> <span class= code-output > ;   MEMORY_BITS     INT             64</span> <span class= code-output > ;   FILE_OFFSET_BITS</span> <span class= code-output > ;                   INT             64</span> <span class= code-output > ;--------------------------------------------------------------------------------</span> <span class= code-output > ;environment IDL_PATH</span> <span class= code-output > ;</span> <span class= code-output > ;--------------------------------------------------------------------------------</span> <span class= code-output > ;environment IDL_DLM_PATH</span> <span class= code-output > ;</span> <span class= code-output > ;--------------------------------------------------------------------------------</span> <span class= code-output > ;preferences IDL_PATH</span> <span class= code-output > ;&lt;IDL_DEFAULT&gt;:+/home/user/ominas_data/idlastro/pro:+/home/user/ominas:+/home/user/ominas/util/xidl:+/home/user/ominas_data/icy/lib</span> <span class= code-output > ;--------------------------------------------------------------------------------</span> <span class= code-output > ;preferences IDL_DLM_PATH</span> <span class= code-output > ;&lt;IDL_DEFAULT&gt;:+/home/user/ominas_data/icy/lib</span> <span class= code-output > ;--------------------------------------------------------------------------------</span> <span class= code-output > ;</span> <span class= code-output > ;Icy:</span> <span class= code-output > ;--------------------------------------------------------------------------------</span> <span class= code-output > ;** ICY - IDL/CSPICE interface from JPL/NAIF (not loaded)</span> <span class= code-output > ;    Version: 1.8.0, Build Date: 05-JAN-2017, Source: ed.wright@jpl.nasa.gov</span> <span class= code-output > ;    Path: /home/user/ominas_data/icy/lib/icy.so</span> <span class= code-output > ;--------------------------------------------------------------------------------</span> <span class= code-output > ;CSPICE_N0066</span> <span class= code-output > ;--------------------------------------------------------------------------------</span> <span class= code-output > ;0 loaded kernels:</span> <span class= code-output > ;--------------------------------------------------------------------------------</span> <span class= code-output > ;</span> <span class= code-output > ;OMINAS repository:</span> <span class= code-output > ;On branch master</span> <span class= code-output > ;Your branch is up-to-date with 'origin/master'.</span> <span class= code-output > ;Last commit:</span> <span class= code-output > ;b373f70 Paulo Penteado Wed Jun 14 14:03:42 2017 -0700</span>   	Troubleshooting  	This section outlines several common sources of error which are due to 	OMINAS not being configured correctly.  	One of the most common configuration problems manifests as this error: <span class= code-output > % CSPICE_STR2ET: SPICE(NOLEAPSECONDS): [str2et_c-&gt;STR2ET-&gt;TTRANS] The variable that points to the leapseconds (DELTET/DELTA_AT)</span> <span class= code-output >                 could not be located in the kernel pool.  It is likely that the leapseconds kernel has not been loaded via</span> <span class= code-output >                 the routine FURNSH.</span> 	This error comes from the Icy toolkit. It specifically refers to the Leap 	Second Kernel file, however, as the lsk is usually the first kernel which 	is loaded, this error generally means that no kernels are being loaded.  	You can check which kernels have been loaded by entering the following 	IDL commands: <span class= code-output > cspice_ktotal, 'ALL', count</span> <span class= code-output > for i=0,count-1 do begin & cspice_kdata,i,'ALL',file,type,source,handle,found & print,i,file & endfor</span> 	A list will be populated with the currently loaded SPICE kernels, and 	their load order. If no kernels are loaded, then it is likely that a bad 	path was supplied to the kernel pools. Ensure that the kernel pool was 	successfully entered into the environemnt by using the  env  command at 	the terminal prompt. The kernel pool variable names follow a convention 	like so: &lt;MIS&gt;_SPICE_&lt;*K&gt;, where &lt;MIS&gt; is the abbreviated mission name, 	and &lt;*K&gt; is the type of kernel. Therefore, for Cassini, the IDL command: <span class= code-output > spawn, env | grep CAS_SPICE </span> 	will list the path to directories containing each type of Cassini kernel. 	If the variables are not present, the easiest fix might be to run the OMINAS 	installer again  	 source configure.sh  	From the ominas directory. Then, if the Cassini package shows as installed, 	select that option at the menu (4), to uninstall it. You will be presented with 	the possibility of preserving files the OMINAS installer previously downloaded, 	or deleting them. After the uninstallation is complete, you will be returned to 	the installer menu, and Cassini should show as not configured. Then select the Cassini 	option to set it up again.  	In some cases, a demo script will run and no error will appear to occur, 	but no pointing will be overlayed on the image. This error generally occurs 	due to the PCK kernels not being loaded or the CK kernels not being loaded 	in the correct order.  	When the frame kernel (FK) is not being loaded correctly for an image, 	Icy will return the following error: <span class= code-output > % CSPICE_PXFORM: SPICE(EMPTYSTRING): [pxform_c] String  from  has length zero.</span> 	If Icy is not installed, and a script is run, something similar to the 	following error may occur: <span class= code-output > % Attempt to call undefined procedure: 'CSPICE_STR2ET'.</span> 	In general, the undefined procudure may have any cspice prefix. Icy is 	either not configured correctly, or not installed. In IDL, check that 	the Icy path has been added to the IDL path as follows: <span class= code-output > path = pref_get('IDL_PATH')</span> <span class= code-output > print, path</span> <span class= code-output > dlm_path = pref_get('IDL_DLM_PATH')</span> <span class= code-output > print, dlm_path</span> 	The path variable should appear as a colon-separated list with 	&lt;IDL_DEFAULT&gt; as the first entry. Check that both Icy and OMINAS 	directories are added to the IDL_PATH, and that Icy is added to the 	IDL_DLM_PATH. If either Icy or OMINAS are not present, the best way to fix 	it probably is to get back into the OMINAS directory and run the configure.sh 	script to uninstall/install the Core, Demo or Icy packages again.   ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("./install_guide.html#install_guide", "install_guide", 'routine in <a href="./install_guide.html">install_guide.pro</a>', "install_guide.pro", "", "install_guide", "", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("./jupiter_example.html", "jupiter_example.pro", '.pro file in <a href="./dir-overview.html">./ directory</a>', "jupiter_example.pro", "", "", " JUPITER EXAMPLE     Edited by Mark Moretto     June 2016      This example file uses an image of Jupiter, its rings, and satellites to     demonstrate various capabilities of the OMINAS software.  This includes     fitting the limb and rings simultaneously, hiding the limb and/or rings wrt     other objects in the field of view, plotting radial and longitudinal     sectors on the ring and generating map projections.      This example file can be executed from the UNIX command line using: <span class= code-output >ominas jupiter_example.pro</span>     or from within an OMINAS IDL session using: <span class= code-output >@jupiter_example</span>     After the example stops, later code samples in this file may be executed by     pasting them onto the IDL command line.   Read and display image        This first section uses dat_read to read in the image and then displays    the image using tvim.     dat_read reads the image portion (im) and the label (label) and returns a    data descriptor (dd) containing the image and label and information obtained    through OMINAS' configuration tables.  If a file exists in the same directory    and with the same name as the image, except with the extension  .dh ,    then it is assumed to be a detached header and it is read as well.     The files w1352097259.1 and n1352037683.2 are Cassini wide- and narrow-    angle frames of Jupiter.  2000r.img and 2100r.img are Galileo SSI    images of Ganymede.     tvim is called to display the image (im) in a new window with the y    coordinate as top-down: <span class= code-output > file = getenv('OMINAS_DIR')+'/demo/data/N1350122987_2.IMG'     ; Cassini Image</span> <span class= code-output > dd = dat_read(file, im, label)</span>  <span class= code-output > tvim, im, zoom=0.75, /order, /new</span>   Obtain descriptors     This section obtains the camera descriptor (cd), planet descriptors    (pd), ring descriptors (rd), and the sun descriptor (sund) for    use with subsequent commands: <span class= code-output > cd = pg_get_cameras(dd)</span> <span class= code-output > pd = pg_get_planets(dd, od=cd)</span> <span class= code-output > rd = pg_get_rings(dd, pd=pd, od=cd)</span> <span class= code-output > sund = pg_get_stars(dd, od=cd, name='SUN')</span>   NOTES     Because the detached header translator dh_std_input appears before    the Cassini Spice input translator in the default translators table, the    descriptors are taken from the detached header if it exists.  If it doesn't    exist, then they are obtained through the SPICE kernels.     The commented lines show how translator keywords can be passed to    override the keywords given in the translators table.      The keyword 'name' could be used in pg_get_planets to select only Jupiter    and the Galilean satellites.  By default, every body that's relevant to    the mission and can be found in the kernel list is returned.  Also, the    SPICE translator organizes the pd array such that pd[0] gives the    primary target of the observation, if one exists.     The keyword 'name' is used in pg_get_stars to select only the Sun.    Otherwise, star catalog stars would also be returned.  Note, however,    that the star catalog is still searched because it does appear in the    translators table.   Create a generic descriptor     This line creates a  generic  descriptor.  This is a convenience    feature wherein several descriptors are grouped into a structure that    can be passed to functions in one piece.  The field names of a generic    descriptor must follow the convention described in pg_description.txt: <span class= code-output > gd = {cd:cd, gbx:pd, dkx:rd, sund:sund}</span>    cd - camera descriptor part     gbx - globe descriptor part     dkx - disk descriptor part     sund - sun descriptor part   Compute geometric features     These commands compute the limb of each planet, the edges of the Jovian ring    system, and terminators on each planet: <span class= code-output > limb_ptd = pg_limb(gd=gd) & pg_hide, limb_ptd, gd=gd, bx=rd, /rm</span> <span class= code-output >           pg_hide, limb_ptd, /assoc, gd=gd, bx=pd, od=sund</span> <span class= code-output > ring_ptd = pg_disk(gd=gd) & pg_hide, ring_ptd, gd=gd, bx=pd</span> <span class= code-output > term_ptd = pg_limb(gd=gd, od=gd.sund) & pg_hide, term_ptd, gd=gd, bx=pd, /assoc</span>  <span class= code-output > center_ptd = pg_center(gd=gd, bx=pd)</span> <span class= code-output > center_o=pnt_points(center_ptd[0])    ;get the center of Jupiter from the points object</span> <span class= code-output > print, center_o                       ;display the center of Jupiter</span> <span class= code-output > object_ptd = [center_ptd,limb_ptd,ring_ptd,term_ptd]</span>    Note that terminators are computed    using pg_limb by specifying the sun as the observer instead of the camera.   Set plot parameters     The colors, psyms, psizes and plables variables    are defined for the plot.  The center is drawn in the default color    (!p.color), the limb is in yellow (ctyellow) and the inner and outer ring    are in red (ctred).  Here you can see that each ring is treated as two    objects (inner and outer) when defining plot characteristics.  With an    8-bit display, these color routines return the values that were previously    reserved in the color table with ctmod; with a 24-bit display, these    routines return the true color values for these colors.  nlimb stores the    number of points in the limb_ptd structure, nring, the number of points in    the ring point structure.  In plabels, the limb and ring's name is not    plotted since it would be plotted at the center of the object: <span class= code-output > ncent=n_elements(center_ptd)</span> <span class= code-output > nlimb=n_elements(limb_ptd)</span> <span class= code-output > nring=n_elements(ring_ptd)</span> <span class= code-output > nterm=n_elements(term_ptd)</span> <span class= code-output > colors=[make_array(n_elements(pd),value=!p.color), $</span> <span class= code-output >         make_array(n_elements(pd),value=ctyellow()), $</span> <span class= code-output >         make_array(2*n_elements(rd),value=ctred()), $</span> <span class= code-output >         make_array(nterm,value=ctgreen())]</span> <span class= code-output > psyms=[make_array(n_elements(pd),value=1), $</span> <span class= code-output >         make_array(n_elements(pd),value=3), $</span> <span class= code-output >         make_array(2*n_elements(rd),value=3), $</span> <span class= code-output >         make_array(nterm,value=3)]</span> <span class= code-output > psizes=1.0</span> <span class= code-output > csizes=0.75</span> <span class= code-output > plabels=[cor_name(pd), $</span> <span class= code-output >         make_array(n_elements(pd),value=''), $</span> <span class= code-output >         make_array(2*n_elements(rd),value=''), $</span> <span class= code-output >         make_array(nterm,value='')]</span>   Draw the limb, ring and planet center      This section draws the objects in the object array (center, limb, ring,  and terminator) with the colors and plot symbols and labels defined earlier: <span class= code-output >   pg_draw, object_ptd, col=colors, psy=psyms, psi=psizes, csi=csizes, pl=plabels</span>   First-cut Automatic repointing     Refine the pointing of the spacecraft by using pg_farfit, which searches    the whole image for a pattern matching the edges calculated using the    descriptors: <span class= code-output > edge_ptd = pg_edges(dd, edge=10)                ; Scan image for edges.</span> <span class= code-output > pg_draw, edge_ptd</span>            dxy = pg_farfit(dd, edge_ptd, [limb_ptd[0]])    ; Try to correlate scanned edges with the computed limb.      pg_repoint, dxy, 0d, axis=center_ptd[0], gd=gd  ; Change the pointing.      tvim, im      pg_draw, object_ptd, colors=colors, psyms=psyms, psizes=psizes, plabel=plabels            center_ptd = pg_center(gd=gd, bx=pd)      print, 'after automatic repointing, the center was shifted by:', pnt_points(center_ptd[0])-center_o, 'pixels'    Manually repoint the geometry     This pasteable section first clears the screen of the plotted points    by redisplaying the image with tvim.  It then calls pg_drag to allow    the user to use the cursor to drag the pointing, and with it the limb,    ring and planet center.  To move the pointing with pg_drag, use the left    mouse button and translate the pointing in x,y.  Use the middle mouse    button to rotate the pointing about an axis (in this case, the axis of    rotation is set as the planet center (center_ptd[0]).  When the    desired pointing is set, the right mouse button accepts it.  pg_drag    returns the delta x,y amount dragged (dxy) as well as the rotation    angle (dtheta).  pg_repoint uses the dxy and dtheta to update the    camera descriptor (cd, passed by gd).  The limb and center is then    recalculated, the image redisplayed to clear the objects drawn, and    then pg_draw is called to replot: <span class= code-output > tvim, im</span> <span class= code-output > dxy = pg_drag(object_ptd, dtheta=dtheta, axis=center_ptd[0])    ;Do the reponting</span> <span class= code-output > pg_repoint, dxy, dtheta, axis=center_ptd[0], gd=gd              ;Modify the general descriptor</span>  <span class= code-output > ;Recalculate the geometry and redisplay the image with the new overlays</span>  <span class= code-output > limb_ptd = pg_limb(gd=gd) & pg_hide, limb_ptd, gd=gd, bx=rd, /rm</span> <span class= code-output >        pg_hide, limb_ptd, /assoc, gd=gd, bx=pd, od=sund</span> <span class= code-output > ring_ptd = pg_disk(gd=gd) & pg_hide, ring_ptd, gd=gd, bx=pd</span> <span class= code-output > center_ptd = pg_center(gd=gd, bx=pd)</span> <span class= code-output > term_ptd = pg_limb(gd=gd, od=gd.sund) & pg_hide, term_ptd, gd=gd, bx=pd, /assoc</span> <span class= code-output > object_ptd = [center_ptd,limb_ptd,ring_ptd,term_ptd]</span>  <span class= code-output > tvim, im</span> <span class= code-output > pg_draw, object_ptd, colors=colors, psyms=psyms, psizes=psizes, plabel=plabels</span>   Scan the edge to find the limb and use it to correct the pointing using least-squares.     This section calls pg_cvscan to scan the image around the predicted    limb position and the ring edge position (within width of 80 pixels) and    find the points of highest correlation with a given edge model for each    object (edge_model_nav_limb = limb model used in the VICAR program NAV    and edge_model_nav_ring = ring model from NAV) and zeropoint offset in    the given model (lzero).  These points are then plotted: <span class= code-output > cvscan_ptd=pg_cvscan(dd, gd=gd, [limb_ptd[0]], edge=30, width=80, $</span> <span class= code-output >     model=[make_array(nlimb,val=ptr_new(edge_model_nav_limb(zero=lzero)))], $</span> <span class= code-output >     mzero=[make_array(nlimb,val=lzero)] )</span>  <span class= code-output > tvim, im</span> <span class= code-output > pg_draw, cvscan_ptd</span>          The commented command might be more appropriate for images in which    the planet disk is quite small.  In that case, we use a different edge    model (because the nav model cannot be scaled) and we scan a much    narrower region.   Threshold on correlation coefficient     This section calls pg_threshold to remove points with    unacceptable correlation coefficients.  The /relative flag means that    the minimum and maximum thresholds are taken as a fraction of the maximum    correlation coefficient for each set of points. In this case we use a minimun    correlation coefficent of 0.81 and a maximum of 1.0: <span class= code-output > pg_threshold, cvscan_ptd, min=0.81, max=1.0, /rel</span> <span class= code-output > tvim, im</span> <span class= code-output > pg_draw, cvscan_ptd</span>   Removing regions of bad scan points     This pasteable section calls pg_select to remove points within a    polygonal region as defined by the cursor.  Click the left mouse    button to mark a point and move the mouse to the next point and    click.  Use the middle mouse button to erase a point and the right    mouse button to end the region.  pg_trim removes the points in the    just defined region.  The scan points are then replotted.    Repeat these statements for each region a user wants to remove: <span class= code-output > region = pg_select(dd)</span> <span class= code-output > pg_trim, dd, cvscan_ptd, region</span> <span class= code-output > tvim, im</span> <span class= code-output > pg_draw, cvscan_ptd</span>   Fit the pointing to the scanned points using least squares     This section calls pg_cvscan_coeff to determine the linear least-squares    coefficients for a fit to the image coordinate translation and rotation    that matches the computed curve to the scanned curve. It then calls    pg_fit to do the fit with the calculated coefficients to calculate the    correction in translation (dxy) and rotation (dtheta).  It calls    pg_cvchisq to get the chi square of the fit.  Then calls pg_repoint to    update the pointing. Recalculates the limb and center and replots.    The determination of the curves and their subsequent fit can be    iterated on.     Note that, as shown, dx, dy, and dtheta are fit.  To fix any of these    parameters use the 'fix' keyword to pg_cvscan_coeff.  For example    with 'fix=2', dtheta will be zero: <span class= code-output > fix = [2]</span> <span class= code-output > cvscan_cf = pg_cvscan_coeff(cvscan_ptd, axis=center_ptd[0], fix=fix)</span> <span class= code-output > dxy = pg_fit([cvscan_cf], dtheta=dtheta)</span> <span class= code-output > chisq = pg_chisq(dxy, dtheta, cvscan_ptd, axis=center_ptd[0], fix=fix)</span> <span class= code-output > covar = pg_covariance([cvscan_cf])</span> <span class= code-output > print, dxy, dtheta*180./!pi, chisq, covar</span> <span class= code-output > pg_repoint, dxy, dtheta, axis=center_ptd[0], gd=gd</span>  <span class= code-output > limb_ptd = pg_limb(gd=gd) & pg_hide, limb_ptd, gd=gd, bx=rd, /rm</span> <span class= code-output >         pg_hide, limb_ptd, bx=pd, /assoc, gd=gd, od=sund</span> <span class= code-output > ring_ptd = pg_disk(gd=gd) & pg_hide, ring_ptd, gd=gd, bx=pd</span> <span class= code-output > center_ptd = pg_center(gd=gd, bx=pd)</span> <span class= code-output > term_ptd = pg_limb(gd=gd, od=gd.sund) & pg_hide, term_ptd, gd=gd, bx=pd, /assoc</span> <span class= code-output > object_ptd = [center_ptd,limb_ptd,ring_ptd,term_ptd]</span>  <span class= code-output > tvim, im</span> <span class= code-output > pg_draw, object_ptd, colors=colors, psyms=psyms, psizes=psizes, plabel=plabels</span>         Draw planet and ring latitude/longitude grid        This section calculates a latitude/longitude grid for each planet and a    radius/longitude grid for the rings.  By default it draws 12 latitude    and 12 longitude grid lines.  The longitude grid lines circle the body    and so on a map they will appear as 24 grid lines.  The ring radius grid    uses four grid lines by default between the inner and outer ring radius.    It uses pg_hide to set as not visible the points on the grid behind the    planet and ring for both objects.  It then uses pg_draw to draw the    grid points in blue (ctblue): <span class= code-output > grid_ptd = pg_grid(gd=gd, lat=lat, lon=lon)</span> <span class= code-output > pg_hide, grid_ptd, cd=cd, bx=pd, /assoc</span> <span class= code-output > pg_hide, grid_ptd, cd=cd, bx=pd, od=sund, /assoc</span> <span class= code-output > pg_hide, grid_ptd, gd=gd, bx=rd</span> <span class= code-output > pg_draw, grid_ptd, color=ctblue()</span>  <span class= code-output > plat_ptd = pg_grid(gd=gd, slon=!dpi/2d, lat=lat, nlon=0)</span> <span class= code-output > pg_hide, plat_ptd[0], cd=cd, bx=pd[0], /, bx=pd</span> <span class= code-output > pg_draw, plat_ptd[0], psym=3, plabel=strtrim(round(lat*180d/!dpi),2), /label_p</span>  <span class= code-output > plon_ptd = pg_grid(gd=gd, slat=0d, lon=lon, nlat=0)</span> <span class= code-output > pg_hide, plon_ptd[0], cd=cd, bx=pd[0], /assoc</span> <span class= code-output > pg_draw, plon_ptd[0], psym=3, plabel=strtrim(round(lon*180d/!dpi),2), /label_p</span>  <span class= code-output > dgrid_ptd=pg_grid(gd=gd, bx=rd) & pg_hide, dgrid_ptd, gd=gd, bx=pd</span> <span class= code-output > pg_draw, dgrid_ptd, color=ctpurple()</span>   Generate map projections     This section defines a map descriptor for a simple cylindrical projection    using pg_get_maps.  It then calls pg_map to create a map projection and    uses tvim to display it in a new window.  Four different map descriptors    are demonstrated.     We also call pg_grid to calculate a latitude/longitude grid on the map and    then pg_draw to draw the grid in green. For convenience, define a new generic descriptor.    Note that the map descriptor is used for the cd field. Call pg_limb to calculate the limb    on the map and then pg_draw to draw the grid in purple.   Mercator     Map descriptor: <span class= code-output > md = pg_get_maps(/over, bx=pd[0], $</span> <span class= code-output >   type='MERCATOR', $</span> <span class= code-output >   fn_data=ptr_new(),size=[400,200])</span>       Stereographic     Map descriptor: <span class= code-output > md = pg_get_maps(/over, bx=pd[0], $</span> <span class= code-output >   type='STEREOGRAPHIC', $</span> <span class= code-output >   fn_data=ptr_new(),scale=0.5, $</span> <span class= code-output >   size=[400,400], center=[!dpi/2d,0d])</span>       Orthographic     Map descriptor: <span class= code-output > md = pg_get_maps(/over, bx=pd[0], $</span> <span class= code-output >   type='ORTHOGRAPHIC', $</span> <span class= code-output >   fn_data=ptr_new(), $</span> <span class= code-output >   size=[400,400], $</span> <span class= code-output >   center=[!dpi/6d,!dpi])</span>       Rectangular     Map descriptor: <span class= code-output > md = pg_get_maps(/over, bx=pd[0], $</span> <span class= code-output >   type='RECTANGULAR', $</span> <span class= code-output >   /map_graphic,fn_data=ptr_new(),scale=1.0, $</span> <span class= code-output >   size=[400,200])</span>        Projecting the maps     Use the pg_map and the map descriptor to project the image onto a map.    Certain regions, such as rings, could be excluded from the projection    and bounds on the map can be set, if desired: <span class= code-output > ;to set projection bounds...</span> <span class= code-output > ;bounds = [-30,30,-180,180]*!dpi/180d</span>  <span class= code-output > mmap = 0</span> <span class= code-output > dd_map = pg_map(dd, md=md, gd=gd, bx=pd[0], map=mmap, bounds=bounds)</span>  <span class= code-output > ; to exclude areas covered by rings...</span> <span class= code-output > ;dd_map = pg_map(dd, md=md, gd=gd, bx=pd[0], gbx=pd[0], $</span> <span class= code-output > ;          hide_fn='pm_hide_ring', hide_data_p=ptr_new(rd), map=map, bounds=bounds)</span>  <span class= code-output > tvim, /new, mmap</span>    Call pg_grid to calculate a latitude/longitude grid on the map and    then pg_draw to draw the grid in green.     For convenience, define a new generic descriptor.  Note that the map    descriptor is used for the cd field: <span class= code-output > gdm={cd:md, od:cd, gbx:cor_select(pd,'JUPITER'), dkx:rd}</span>  <span class= code-output > map_grid_ptd = pg_grid(gd=gdm, lat=lat, lon=lon)</span> <span class= code-output > plat_ptd = pg_grid(gd=gdm, slon=!dpi/2d, lat=lat, nlon=0)</span> <span class= code-output > plon_ptd = pg_grid(gd=gdm, slat=0d, lon=lon, nlat=0)</span>  <span class= code-output > pg_draw, map_grid_ptd, col=ctgreen()</span> <span class= code-output > pg_draw, plat_ptd, psym=7, plabel=strmid(strtrim(lat*180d/!dpi,2),0,3), /label_p</span> <span class= code-output > pg_draw, plon_ptd, psym=7, plabel=strmid(strtrim(lon*180d/!dpi,2),0,3), /label_p</span>    Call pg_limb to calculate the limb on the map and then pg_draw to    draw the grid in purple: <span class= code-output > map_limb_ptd = pg_limb(gd=gdm)</span> <span class= code-output > pg_draw, map_limb_ptd, col=ctred()</span>  <span class= code-output > map_term_ptd = pg_limb(gd=gdm, od=sund)</span> <span class= code-output > pg_draw, map_term_ptd, col=ctyellow()</span>   Reproject the previous map     A map can be reprojected using a second map descriptor    and the original map descriptor as the camera descriptor: <span class= code-output > md1 = pg_get_maps(/over, bx=pd[0], $</span> <span class= code-output >   type='ORTHOGRAPHIC', $</span> <span class= code-output >   fn_data=ptr_new(), $</span> <span class= code-output >   size=[400,400], $</span> <span class= code-output >   center=[!dpi/6d,!dpi])</span>  <span class= code-output > map=0</span> <span class= code-output > dd_map1 = pg_map(dd_map, md=md1, cd=md, map=map1, bounds=bounds)</span> <span class= code-output > tvim, /new, map1</span>       Output the new state     This section shows how you can save your output.   Output descriptors     These commands write the descriptor information out through the    translators.  The exact behavior is translator-dependent.  The detached    header translator just modifies the detached header (stored in the data    descriptor).  The SPICE output translator writes a C-kernel if a file    name is specified using the ck_out translator keyword (as in the commented    line): <span class= code-output > pg_put_rings, dd, od=gd.cd, rd=rd</span> <span class= code-output > pg_put_planets, dd, od=gd.cd, pd=pd</span> <span class= code-output > pg_put_cameras, dd, cd=cd</span> <span class= code-output > ; cor_set_udata, cd, 'CK_COMMENT', 'This is a comment.'</span> <span class= code-output > ; pg_put_cameras, dd, gd=gd, 'ck_out=./test.bc'</span> <span class= code-output > ; print, spice_daf_comment('./test.bc')</span> <span class= code-output > pg_put_stars, dd, sd=sund, od=gd.cd</span>    Write image file and header     dat_write writes the image file from the data descriptor.  The detached header    is also written into a file with the same name as the image file except with    the extension '.dh'.  If this file does not already exist, it is created: <span class= code-output > split_filename, file, dir, name</span> <span class= code-output > dat_write, getenv('OMINAS_DATA')+'/' + name, dd</span>   Write map file and header     pg_put_maps causes the detached header translator to generate a new detached    header and write the map descriptor into it.     As above, dat_write writes the map image file and the detached header. Notice    that the filetype is given explicitly because the data descriptor was not    created by dat_read, which would have detected the filetype: <span class= code-output > pg_put_maps, dd_map, md=md</span>  <span class= code-output > split_filename, file, dir, name</span> <span class= code-output > dat_write, getenv('OMINAS_DATA')+'/' + name + '.map', dd_map, filetype = 'VICAR'</span>    To read the new map file, use dat_read just as the image file was read at the    beginning of this example script.  To read the map descriptor from the    detached header, use: <span class= code-output > md = pg_get_maps(dd_map)</span>  ", "", "          -1", "");
  

libdata[libdataItem++] = new Array("./map-disk_example.html", "map-disk_example.pro", '.pro file in <a href="./dir-overview.html">./ directory</a>', "map-disk_example.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("./map-globe_example.html", "map-globe_example.pro", '.pro file in <a href="./dir-overview.html">./ directory</a>', "map-globe_example.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("./mosaic_example.html", "mosaic_example.pro", '.pro file in <a href="./dir-overview.html">./ directory</a>', "mosaic_example.pro", "", "", " MOSAIC EXAMPLE     This example requires the following kernel files, which are    included in the demo's data directory: <span class= code-output > $CAS_SPICE_CK/001103_001105ra.bc</span> <span class= code-output > $CAS_SPICE_CK/001105_001108.bc</span> <span class= code-output > $CAS_SPICE_CK/001026_001029ra.bc</span> <span class= code-output > $CAS_SPICE_CK/001029_001031ra.bc</span>    This example file demonstrates how to construct a mosaic using OMINAS.    This example file can be executed from the UNIX command line using:   	  ominas mosaic_example     or from within an OMINAS IDL session using:   	  @mosaic_example     After the example stops, later code samples in this file may be executed by    pasting them onto the IDL command line. ;    This first section uses dat_read to read in the image and then displays    the image using tvim.   Read and display image     dat_read reads the image portion (im) and the label (label) and returns a    data descriptor (dd) containing the image and label and information obtained    through OMINAS' configuration tables.  If a file exists in the same directory    and with the same name as the image, except with the extension  .dh ,    then it is assumed to be a detached header and it is read as well.     The files w1352097259.1 and n1352037683.2 are Cassini wide- and narrow-    angle frames of Jupiter.  2000r.img and 2100r.img are Galileo SSI    images of Ganymede.     ctmod is called to reserve several colors in the case of an 8-bit display.     tvim is called to display the image (im) in a new window with the y    coordinate as top-down: <span class= code-output > files = getenv('OMINAS_DIR')+'/demo/data/'+['n1350122987.2','/n1351469359.2']</span> <span class= code-output > n = n_elements(files)</span>  <span class= code-output > dd = dat_read(files)</span>  <span class= code-output > zoom = 0.3</span> <span class= code-output > for i=0, n-1 do tvim, dat_data(dd[i]), zoom=zoom, /order, /new</span> <span class= code-output > tvim, /list, wnum=ww</span>              Get camera, planets, rings and sun objects: <span class= code-output > _gd = {cd:obj_new(), gbx:obj_new(), dkx:obj_new(), sund:obj_new()}</span> <span class= code-output > gd = replicate(_gd, n)</span>  <span class= code-output > for i=0, n-1 do gd[i].cd = pg_get_cameras(dd[i])</span> <span class= code-output > for i=0, n-1 do gd[i].gbx = pg_get_planets(dd[i], od=gd[i].cd, name='JUPITER')</span> <span class= code-output > for i=0, n-1 do gd[i].dkx = pg_get_rings(dd[i], pd=gd[i].gbx, od=gd[i].cd)</span> <span class= code-output > for i=0, n-1 do gd[i].sund = pg_get_stars(dd[i], od=gd[i].cd, name='SUN')</span>    Compute limb: <span class= code-output > limb_ptd = objarr(n)</span> <span class= code-output > for i=0, n-1 do limb_ptd[i] = pg_limb(gd=gd[i])</span>   Navigate on limbs automatically     pg_farfit finds the limb to within a few pixels.  In reality, you would    want to refine the pointing by scanning for the limb and performing a    least-squares fit, but for the purposes of clarity in this example, the    inital fit will do: <span class= code-output > edge_ptd = objarr(n)</span> <span class= code-output > for i=0, n-1 do edge_ptd[i] = pg_edges(dd[i], edge=10)</span>    Run pg_farfit to obtain the offsets between the computed points (limb_ptd)    and the image edges (edge_ptd) and apply the offsets with pg_repoint: <span class= code-output > dxy = dblarr(2,n)</span> <span class= code-output > for i=0, n-1 do dxy[*,i] = pg_farfit(dd[i], edge_ptd[i], [limb_ptd[i]], ns=[5,5])</span> <span class= code-output > for i=0, n-1 do pg_repoint, dxy[*,i], 0d, gd=gd[i]</span>    Recompute the geometry now that the pointing was corrected: <span class= code-output > for i=0, n-1 do limb_ptd[i] = pg_limb(gd=gd[i])</span> <span class= code-output > for i=0, n-1 do  pg_draw, limb_ptd[i], wnum=ww[i]</span>              See jup_cassini.example and dione.example for examples    of least-squares fits to image features    Correct photometry     Here, a crude photometric correction is performed for the purposes    of this example.     In addition to the corrected images, the output descriptors, dd_pht,    will contain the photometric angles in their user data arrays with    the names 'EMM', 'INC' and 'PHASE': <span class= code-output > dd_pht = objarr(n)</span> <span class= code-output > for i=0, n-1 do dd_pht[i] = pg_photom(dd[i], gd=gd[i], $</span> <span class= code-output >   refl_fn='pht_refl_minneart',refl_parm=[0.9d], outline=limb_ptd[i])</span>  <span class= code-output > for i=0, n-1 do tvim, dat_data(dd_pht[i]), ww[i]</span>             Project maps     Note that all map projections use the same map descriptor.     Also, aux=['EMM'] is used with pg_map to direct it to reproject    the emmision angle array that was produced and stored in the data descriptor    by pg_photom.  That array will be needed by pg_mosaic: <span class= code-output > map_xsize = 800</span> <span class= code-output > map_ysize = 400</span>    Create the map descriptor to use for the projections: <span class= code-output > md = pg_get_maps(/over, gbx = pd1, $</span> <span class= code-output >   name='JUPITER',$</span> <span class= code-output >   type='RECTANGULAR', $</span> <span class= code-output >   fn_data=ptr_new(), $</span> <span class= code-output >   size=[map_xsize,map_ysize], $</span> <span class= code-output >   origin=[map_xsize,map_ysize]/2 )</span>  <span class= code-output > Do the map projections, frmo objects dd_pht, using map descriptor md:</span>      dd_map = objarr(n)      for i=0, n-1 do dd_map[i] = pg_map(dd_pht[i], md=md, gd=gd[i], aux=['EMM'])     Display the results: <span class= code-output > for i=0, n-1 do tvim, dat_data(dd_map[i]), /new</span>             Introducing wind profiles   Use the commented commands instead to include a zonal wind profile in  the projection: <span class= code-output > for i=0, n-1 do $</span> <span class= code-output >   dd_map[i] = pg_map(dd_pht[i], md=md, gd=gd[i], aux=['EMM'], $</span> <span class= code-output >   wind_fn='pm_wind_zonal', $</span> <span class= code-output >   wind_data={vel:cos((dindgen(181)-90)*!dpi/180d) * 100d, $</span> <span class= code-output >   dt:bod_time(gd[i].cd)-bod_time(gd[0].cd)})</span>   Construct the mosaic     The combination function 'emm' combines the maps    using wighting proprtional to emm^x, where emm is the emmision    cosine.  It also imposes a minimum emmision cosine, emm0.  Note    that the emission angles were computed by pg_photom and    reprojected by pg_map, as directed by the 'aux' keyword: <span class= code-output > dd_mosaic = pg_mosaic(dd_map, mosaic=mosaic, $</span> <span class= code-output >   wt='emm', comb='sum', data={x:5, emm0:cos(85d*!dpi/180d)})</span> <span class= code-output > tvim, mosaic, /new</span>        Save the mosaic and map info     To read the mosaic and projection info: <span class= code-output > dd = dat_read('./data/test.msc', mosaic, label)</span> <span class= code-output > md = pg_get_maps(dd)</span>  ", "", "          -1", "");
  

libdata[libdataItem++] = new Array("./multiinstrument_example.html", "multiinstrument_example.pro", '.pro file in <a href="./dir-overview.html">./ directory</a>', "multiinstrument_example.pro", "", "", " MULTI-INSTRUMENT EXAMPLE     This script demonstrates reading Cassini RADAR SAR, VIMS and ISS images and    projecting them onto an orthographical map for display as a RGB composite.     The SAR data file used, BIFQI22N068_D045_T003S01_V02.IMG, is too large (202 MB)    to include with the OMINAS distribution. This script will look for the file    under ~/ominas_data/sar/, and if not found, will download it from    PDS&lt;http://pds-imaging.jpl.nasa.gov/data/cassini/cassini_orbiter/CORADR_0045/DATA/BIDR/BIFQI22N068_D045_T003S01_V02.ZIP&gt;,    then unzip it.     Setup: The instrument detectors, translators and transforms must contain the    RADAR, ISS and VIMS definitions, as is included in demo/data/instrument_detectors.tab,    demo/data/translators.tab, and demo/data/transforms.tab. The PDS detector    and io functions must also be set up    in the corresponding tables, as is in config/tab/filetype_detectors.tab    and config/tab/io.tab.     This example requires SPICE/Icy to have been setup. It can be run just by doing: <span class= code-output > .run multiinstrument_example</span>    From within an OMINAS IDL session.     Troubleshooting: This example uses ISS, VIMS and RADAR data, so each of these    3 might independently fail. If this example fails, it may be helpful to try first    running the 3 individual instrument's example scripts first: jupiter_example.pro (ISS),    vims_example.pro and radar_example.pro, to see which instruments work in your    setup and which do not.   Read and display SAR file     Download the Cassini RADAR SAR image and unzip it, if needed: <span class= code-output > ;Download the SAR file, if needed</span> <span class= code-output > ldir='~/ominas_data/sar'</span> <span class= code-output > spawn,'eval echo '+ldir,res</span> <span class= code-output > ldir=res</span> <span class= code-output > img=ldir+path_sep()+'BIFQI22N068_D045_T003S01_V02.IMG'</span> <span class= code-output > if ~file_test(img,/read) then begin</span> <span class= code-output >   print,'SAR file needed for the demo not found. Downloading it from PDS...'</span> <span class= code-output >   p=pp_wget('http://pds-imaging.jpl.nasa.gov/data/cassini/cassini_orbiter/CORADR_0045/DATA/BIDR/BIFQI22N068_D045_T003S01_V02.ZIP',localdir=ldir)</span> <span class= code-output >   p.geturl</span> <span class= code-output >   print,'ZIP file downloaded, decompressing it...'</span> <span class= code-output >   file_unzip,ldir+path_sep()+'CORADR_0045/DATA/BIDR/BIFQI22N068_D045_T003S01_V02.ZIP',/verbose</span> <span class= code-output > endif</span> <span class= code-output > ;Read the file</span> <span class= code-output > dd=dat_read(img)</span>    Saturate the data to make the image better looking, since this is just for display    purposes: <span class= code-output > da=dat_data(dd)</span> <span class= code-output > dat_set_data,dd,0&gt;da&lt;1d0</span>    Show it a 1/20 resolution: <span class= code-output > tvim,0d0&gt;da&lt;1d0,zoom=0.05,/order,/new</span>         Read and display VIMS and ISS files       Set up a hash containing the file names and precomputed pointing offsets: <span class= code-output > hdxy=hash()</span> <span class= code-output > hdxy['data/CM_1503358311_1_ir_eg.cub']=[5d0,-1d0]</span> <span class= code-output > hdxy['data/W1477456695_6.IMG']=[0d0,0d0]</span> <span class= code-output > files=getenv('OMINAS_DIR')+'/demo/data/'+(hdxy.keys()).toarray()</span> <span class= code-output > nv = n_elements(files)</span> <span class= code-output > ddv = dat_read(files)</span> <span class= code-output > sb=bytarr(nv)</span> <span class= code-output > for i=0,nv-1 do sb[i]=strmatch(files[i],'*.IMG')</span>      Create an array of global descriptors and populate it: <span class= code-output > gdv = replicate({cd:obj_new(), gbx:obj_new(), dkx:obj_new(), sund:obj_new()}, nv)</span> <span class= code-output > for i=0, nv-1 do gdv[i].cd = pg_get_cameras(ddv[i])</span> <span class= code-output > for i=0, nv-1 do gdv[i].gbx = pg_get_planets(ddv[i], od=gdv[i].cd, name='TITAN')</span> <span class= code-output > for i=0, nv-1 do gdv[i].sund = pg_get_stars(ddv[i], od=gdv[i].cd, name='SUN')</span>      Apply the pointing shifts and compute the limbs: <span class= code-output > dxy = dblarr(2,nv)</span> <span class= code-output > limb_psv=objarr(nv)</span> <span class= code-output > for i=0, nv-1 do dxy[*,i] = hdxy[file_basename(files[i])]</span> <span class= code-output > for i=0, nv-1 do pg_repoint, dxy[*,i], 0d, gd=gdv[i]</span> <span class= code-output > for i=0, nv-1 do limb_psv[i] = pg_limb(gd=gdv[i])</span>      Display the VIMS and ISS images: <span class= code-output > band=70</span> <span class= code-output > for i=0,1 do begin</span> <span class= code-output >   zoom=sb[i] ? 1 : 8</span> <span class= code-output >   offset=sb[i] ? [200d0,200d0] : [-15,-10]</span> <span class= code-output >   sband=sb[i] ? 0 : band</span> <span class= code-output >   tvim, (dat_data(ddv[i]))[*,*,sband], $</span> <span class= code-output >     zoom=zoom,/order, /new,offset=offset,$</span> <span class= code-output >     xsize=600,ysize=600</span> <span class= code-output >   pg_draw, limb_psv[i]</span> <span class= code-output > endfor</span>                     Correct the illumination with a Lambertian function: <span class= code-output > dd_phtv = objarr(nv)</span> <span class= code-output > for i=0, nv-1 do dd_phtv[i] = pg_photom(ddv[i], gd=gdv[i], refl_fn='pht_lamb', $</span> <span class= code-output >   refl_parm=[0.9d], outline=limb_psv[i])</span>    Map images     SAR data is provided in PDS as a map on the target, in an oblique rectangular projection, shown above.    To use it, first we need to obtain the proper map descriptor from the data object: <span class= code-output > mdr=pg_get_maps(dd)</span>    Now we will display it in an orthogonal projection. First we define it: <span class= code-output > map_xsize = 1000</span> <span class= code-output > map_ysize = 1000</span>    Create the new map descriptor: <span class= code-output > mdp= pg_get_maps(/over,  $</span> <span class= code-output >   name='TITAN',$</span> <span class= code-output >   type='ORTHOGRAPHIC', $</span> <span class= code-output >   size=[map_xsize,map_ysize], $</span> <span class= code-output >   origin=[map_xsize,map_ysize]/2, $</span> <span class= code-output >   center=[0d0,-0.6d0*!dpi])</span>    Now, do the projection of all 3 images: <span class= code-output > for i=0,nv-1 do dat_set_data,dd_phtv[i],(dat_data(dd_phtv[i]))[*,*,sb[i] ? 0 : band]</span> <span class= code-output > dd_mapv = objarr(nv)</span> <span class= code-output > for i=0, nv-1 do dd_mapv[i] = pg_map(dd_phtv[i], md=mdp, gd=gdv[i], aux=['EMM'])</span> <span class= code-output > dd_map=pg_map(dd,md=mdp,cd=mdr,pc_xsize=500,pc_ysize=500)</span>    Renormalize the data for display, so that all 3 are in the 0-1 range: <span class= code-output > mds=[dd_map,dd_mapv]</span> <span class= code-output > for i=0,2 do begin</span> <span class= code-output >   mdd=dat_data(mds[i])</span> <span class= code-output >   mddr=minmax(mdd)</span> <span class= code-output >   dat_set_data,mds[i],(mdd-mddr[0])/(mddr[1]-mddr[0])</span> <span class= code-output > endfor</span>    Visualize the result as 3 planes in grim: <span class= code-output > grim,mds,cd=replicate(mdp,3),/new;,overlays=['planet_grid']</span>        ", "", "          -1", "");
  

libdata[libdataItem++] = new Array("./multimission_example.html", "multimission_example.pro", '.pro file in <a href="./dir-overview.html">./ directory</a>', "multimission_example.pro", "", "", " MULTI-MISSION EXAMPLE     Created by Joe Spitale     Feb 2017      This example file loads images from various missions onto planes of a     GRIM window and computes the centers of all available planets for each     image to demonstrates OMINAS' multi-mission capabilities.      This example file can be executed from the UNIX command line using: <span class= code-output >ominas multimission_example.pro</span>     or from within an OMINAS IDL session using: <span class= code-output >@multimission_example.pro</span>    Load the 3 images into grim, with planet centers as overlays: <span class= code-output > grim, over='planet_center', dat_read(getenv('OMINAS_DIR')+'/demo/data/'+ $</span> <span class= code-output > ['N1350122987_2.IMG','2100r.img','c3440346.gem'])</span>    The Jupiter observation (from Cassini, the first one displayed in grim) looks like:          And the Ganymede observation (from Galileo) looks like:          (that image is in the second plane in grim: use the     Plane-&gt;next menu option, or click the black double right-arrow button on the left     side of the top toolbar to switch planes)     And the Saturn observation (from Voyager) looks like:          (that image is in the third plane in grim: use the     Plane-&gt;next menu option, or click the black double right-arrow button on the left     side of the top toolbar to switch planes)  ", "", "          -1", "");
  

libdata[libdataItem++] = new Array("./radar_example.html", "radar_example.pro", '.pro file in <a href="./dir-overview.html">./ directory</a>', "radar_example.pro", "", "", " RADAR EXAMPLE     This script demonstrates reading a Cassini RADAR SAR image and projecting it    onto an orthographical map for display.     The data file used, BIFQI22N068_D045_T003S01_V02.IMG, is too large (202 MB)    to include with the OMINAS distribution. This script will look for the file    under ~/ominas_data/sar/, and if not found, will download it from    PDS&lt;http://pds-imaging.jpl.nasa.gov/data/cassini/cassini_orbiter/CORADR_0045/DATA/BIDR/BIFQI22N068_D045_T003S01_V02.ZIP&gt;,    then unzip it.     Setup: The instrument detectors, translators and transforms must contain the    RADAR definitions, as is included in demo/data/instrument_detectors.tab,    demo/data/translators.tab, and demo/data/transforms.tab. Since the RADAR    data is in PDS format, the PDS detector and io functions must also be set up    in the corresponding tables, as is in config/tab/filetype_detectors.tab    and config/tab/io.tab.     There is no need for SPICE/Icy for this example. It can be run just by doing: <span class= code-output > .run radar_example</span>    From within an OMINAS IDL session.   Read SAR file     Cassini RADAR SAR image to read must be set in the variable img, otherwise    this default location is used: <span class= code-output > ;Download the file, if needed</span> <span class= code-output > ldir='~/ominas_data/sar'</span> <span class= code-output > spawn,'eval echo '+ldir,res</span> <span class= code-output > ldir=res</span> <span class= code-output > img=ldir+path_sep()+'BIFQI22N068_D045_T003S01_V02.IMG'</span> <span class= code-output > if ~file_test(img,/read) then begin</span> <span class= code-output >   print,'SAR file needed for the demo not found. Downloading it from PDS...'</span> <span class= code-output >   p=pp_wget('http://pds-imaging.jpl.nasa.gov/data/cassini/cassini_orbiter/CORADR_0045/DATA/BIDR/BIFQI22N068_D045_T003S01_V02.ZIP',localdir=ldir)</span> <span class= code-output >   p.geturl</span> <span class= code-output >   print,'ZIP file downloaded, decompressing it...'</span> <span class= code-output >   file_unzip,ldir+path_sep()+'CORADR_0045/DATA/BIDR/BIFQI22N068_D045_T003S01_V02.ZIP',/verbose</span> <span class= code-output > endif</span>  <span class= code-output > ;Read the file</span> <span class= code-output > dd=dat_read(img)</span>   Display SAR file     Saturate the data to make the image better looking, since this is just for display    purposes: <span class= code-output > da=dat_data(dd)</span> <span class= code-output > dat_set_data,dd,da&lt;4.5d0</span>    Show it a 1/20 resolution: <span class= code-output > tvim,da&lt;4.5,zoom=0.05,/order,/new</span>         Map SAR file     SAR data is provided in PDS as a map on the target, in an oblique rectangular projection, shown above.    To use it, first we need to obtain the proper map descriptor from the data object: <span class= code-output > mdr=pg_get_maps(dd)</span>    Now we will display it in an orthogonal projection. First we define it: <span class= code-output > map_xsize = 4000</span> <span class= code-output > map_ysize = 4000</span>    Create the new map descriptor: <span class= code-output > mdp= pg_get_maps(/over,  $</span> <span class= code-output >   name='TITAN',$</span> <span class= code-output >   type='ORTHOGRAPHIC', $</span> <span class= code-output >   size=[map_xsize,map_ysize], $</span> <span class= code-output >   origin=[map_xsize,map_ysize]/2, $</span> <span class= code-output >   center=[0d0,-0.4d0*!dpi])</span>    Now, do the projection: <span class= code-output > dd_map=pg_map(dd,md=mdp,cd=mdr,pc_xsize=800,pc_ysize=800)</span>    Visualize the result, now with grim: <span class= code-output > grim,dd_map,cd=mdp;,overlays=['planet_grid']</span>        ", "", "          -1", "");
  

libdata[libdataItem++] = new Array("./saturn_example.html", "saturn_example.pro", '.pro file in <a href="./dir-overview.html">./ directory</a>', "saturn_example.pro", "", "", " Saturn Example    	 This example file uses Saturn and its rings to show various   	 capabilities of the software.  This includes fitting the   	 limb and rings simultaneously, hiding the limb and/or rings wrt   	 other objects in the field of view, plotting radial and longitudinal   	 sectors on the ring and mapping the saturn cloud tops.    	 This example file can be executed from the UNIX command line using: <span class= code-output >	  ominas ominas saturn_example</span>   	 or from within an OMINAS IDL session using: <span class= code-output >	  @saturn_example</span>   	 After the example stops, later code samples in this file may be executed by   	 pasting them onto the IDL command line.   Image read and display  	  	This first section uses dat_read to read in the image.  The image file    c3440346.gem is a Voyager VICAR format file where the image has had    the camera distortions removed with the VICAR program GEOMA.  dat_read    reads the image portion (im) and the image label (label) and its output    is a data descriptor (dd).  ctmod is called to reserve several colors    in the case of an 8-bit display.  tvim is called to display the image    (im) at 1/2 size in a new window with the y coordinate as top-down.  	For Example: <span class= code-output >  dd = dat_read(getenv('OMINAS_DIR')+'/demo/data/c3440346.gem', im, label)</span> <span class= code-output >  tvim, im, zoom=0.5, /order, /new</span>    Obtaining the descriptors     This section obtains the camera descriptor (cd), the planet descriptor    (pd) and the ring descriptor (rd) for use by the software.  In this    example, the various elements of these descriptors are overridden with    values that causes the software not to try to read these values from    a detached header or through a translator that would access the data    from the default source.     Change override to zero to read the data through the translators instead: <span class= code-output > override=1</span>    Camera descriptor: <span class= code-output > if(override) then $</span> <span class= code-output >   cd = pg_get_cameras(dd, /over, $</span> <span class= code-output >   name='VGR1_ISS_NA', $</span> <span class= code-output >   orient= $</span> <span class= code-output >   [ [-0.177287575, -0.966450211, -0.185857758 ], $</span> <span class= code-output >   [ 0.507898045, -0.251604865,  0.823853487 ], $</span> <span class= code-output >   [ 0.842976092, -0.051662194, -0.535464589 ] ], $</span> <span class= code-output >   avel=tr([0.0, 0.0, 0.0]), $</span> <span class= code-output >   pos=tr([0.0, 0.0, 0.0]), $</span> <span class= code-output >   vel=tr([0.0, 0.0, 0.0]), $</span> <span class= code-output >   time=972603249.d, $</span> <span class= code-output >   scale=[7.858656e-06,7.858656e-06], $</span> <span class= code-output >   oaxis=[499.0,499.0], $</span> <span class= code-output >   size=[1000,1000], $</span> <span class= code-output >   fn_focal_to_image='cam_focal_to_image_linear', $</span> <span class= code-output >   fn_image_to_focal='cam_image_to_focal_linear', $</span> <span class= code-output >   fi_data=ptr_new())</span>    Planet descriptor: <span class= code-output >   if(override) then $</span> <span class= code-output >     pd = pg_get_planets(dd, od=cd, /over, $</span> <span class= code-output >     name='SATURN', $</span> <span class= code-output >     orient= $</span> <span class= code-output >     [ [-0.254669368,  0.963251789,  0.085378596], $</span> <span class= code-output >     [-0.962535206, -0.260997177,  0.073528563], $</span> <span class= code-output >     [ 0.093110093, -0.063454432,  0.993631746] ], $</span> <span class= code-output >     avel=tr([0.0854, 0.0732, 0.9937])*1.74e-4, $</span> <span class= code-output >     pos=tr([-23433172000.0, -6105736000.0, -1223129375.0]), $</span> <span class= code-output >     vel=[ tr([9500.0, 0.0, 0.0]), $</span> <span class= code-output >     tr([0.0, 0.1, 0.0]) ], $</span> <span class= code-output >     time=972603249.d, $</span> <span class= code-output >     radii=[60268000.,60268000.,54364000.], $</span> <span class= code-output >     lora=0.0)</span>    Rings descriptor: <span class= code-output >     if(override) then $</span> <span class= code-output >       rd = pg_get_rings(dd, pd=pd, od=cd, /over, $</span> <span class= code-output >       name='MAIN_RING_SYSTEM', $</span> <span class= code-output >       primary=pd, $</span> <span class= code-output >       orient= $</span> <span class= code-output >       [ [-0.254669368,  0.963251789,  0.085378596], $</span> <span class= code-output >       [-0.962535206, -0.260997177,  0.073528563], $</span> <span class= code-output >       [ 0.093110093, -0.063454432,  0.993631746] ], $</span> <span class= code-output >       avel=tr([0.0854, 0.0732, 0.9937])*1.74e-4, $</span> <span class= code-output >       pos=tr([-23433172000.0, -6105736000.0, -1223129375.0]), $</span> <span class= code-output >       vel=[tr([9500.0, 0.0, 0.0]), $</span> <span class= code-output >       tr([0.0, 0.1, 0.0]) ] , $</span> <span class= code-output >       time=972603249.d, $</span> <span class= code-output >       sma=tr([75000000.0,136800000.0]), $</span> <span class= code-output >       ecc=tr([0.0, 0.0]))</span>    Sun (star) descriptor: <span class= code-output >       if(override) then $</span> <span class= code-output >         sund = pg_get_stars(dd, od=cd, /over, $</span> <span class= code-output >         name='SUN', $</span> <span class= code-output >         pos=tr([1.421392d12,4.3105676d10,-4.3613585d10]))</span>    If override was not set, the above could be done with just: <span class= code-output >       if(NOT override) then cd = pg_get_cameras(dd)</span> <span class= code-output >       if(NOT override) then pd = pg_get_planets(dd, od=cd)</span> <span class= code-output >       if(NOT override) then rd = pg_get_rings(dd, pd=pd, od=cd, '/system')</span> <span class= code-output >       if(NOT override) then sund = pg_get_stars(dd, od=cd, name='SUN')</span>     This example, commented out, shows how two objects can be included in   one planet descriptor.   Filling the generic descriptor    	This line fills a  generic  descriptor.  This is a convenience   	feature where in several descriptors are grouped into a structure that   	can be passed to functions in one piece.    	cd - camera descriptor part   	gbx - globe descriptor part   	dkx - disk descriptor part: <span class= code-output > 	  gd = {cd:cd, gbx:pd, dkx:rd, sund:sund}</span>   Calculating the limb, ring and planet center   Determining the plot characteristics    This section uses pg_limb to calculate the limb point structure (limb_ptd)   containing the limb points, the ring point structure (ring_ptd) and also   the planet center (center_ptd) using the routine pg_center.  It uses the   generic descriptor (gd) to pass the camera, planet and ring descriptors   to these routines.  It also uses pg_hide to remove (/rm) points from the   ring from the limb points and then again to remove the ring points   covered by the planet.  It then groups each of these into   object_ptd for plotting.  The colors, psyms, psizes and plables variables   are defined for the plot.  The center is drawn in the default color   (!p.color), the limb is in yellow (ctyellow) and the inner and outer ring   are in red (ctred).  Here you can see that each ring is treated as two   objects (inner and outer) when defining plot characteristics.  With an   8-bit display, these color routines return the values that were previously   reserved in the color table with ctmod; with a 24-bit display, these   routines return the true color values for these colors.  nlimb stores the   number of points in the limb_ptd structure, nring, the number of points in   the ring point structure.  In plabels, the limb and ring's name is not   plotted since it would be plotted at the center of the object: <span class= code-output > limb_ptd = pg_limb(gd=gd) & pg_hide, limb_ptd, gd=gd, bx=rd</span> <span class= code-output > ring_ptd = pg_disk(gd=gd) & pg_hide, ring_ptd, gd=gd, bx=pd</span> <span class= code-output > shadow_ptd = pg_shadow_globe(gd=gd, ring_ptd)</span> <span class= code-output > center_ptd = pg_center(gd=gd, bx=pd)</span> <span class= code-output > object_ptd = [center_ptd,limb_ptd,ring_ptd,shadow_ptd]</span> <span class= code-output > colors = [!p.color,ctyellow(),ctred(),ctred(),ctblue()] & psyms=[1,3,3,3,3] & psizes=[0.5]</span> <span class= code-output > plabels = [cor_name(pd), '', '']</span> <span class= code-output > nlimb = n_elements(limb_ptd)</span> <span class= code-output > nring = n_elements(ring_ptd)</span>   Drawing the limb, ring and planet center  	   This section draws the objects in the object structure (center, limb  and ring) with the colors and plot symbols and labels defined earlier.  Notice how the limb and ring curves cut off at the points of intersection  between the objects: <span class= code-output > pg_draw, object_ptd, colors=colors, psyms=psyms, psizes=psizes, plabel=plabels</span>   Draw planet and ring latitude/longitude grid  	     This sections calculates a latitude/longitude grid for the planet and a   	radius/longitude grid for the rings.  By default it draws 12 latitude   	and 12 longitude grid lines.  The longitude grid lines circle the body   	and so on a map they will appear as 24 grid lines.  The ring radius grid   	uses four grid lines by default between the inner and outer ring radius.   	It uses pg_hide to set as not visible the points on the grid behind the   	planet and ring for both objects.  It then uses pg_draw to draw the   	planet grid points in blue (ctblue) and the ring grid points in purple   	(ctpurple).    	Here is where the example then stops: <span class= code-output > 	  grid_ptd = pg_grid(gd=gd, bx=pd)</span> <span class= code-output >    pg_hide, grid_ptd, gd=gd, bx=pd, /assoc</span> <span class= code-output >    pg_hide, grid_ptd, gd=gd, bx=rd</span> <span class= code-output >    pg_draw, grid_ptd, color=ctblue()</span>  <span class= code-output >    dgrid_ptd = pg_grid(gd=gd, bx=rd) & pg_hide, dgrid_ptd, gd=gd, bx=pd</span> <span class= code-output >    pg_draw, dgrid_ptd, color=ctpurple()</span>   First-cut automatic repointing    In this section, pg_farfit is used to automatically calculate a pointing   correction, by fitting a curve to the planet's limb.    First, we draw a clean image: <span class= code-output >  tvim, im</span>   Then, we calculate the edges in the image with pg_edges, and draw them: <span class= code-output >  edge_ptd = pg_edges(dd, edge=50)</span> <span class= code-output >  pg_draw, edge_ptd</span>        Now, pg_farfit is used to find a x/y offset, by fitting the points in edge_ptd   (the edges found in the image) to the points that make up the limb, rings and   shadow (limb_ptd, ring_ptd, shadow_ptd): <span class= code-output >  dxy = pg_farfit(dd, edge_ptd, [limb_ptd[0], ring_ptd[1], shadow_ptd[0]])</span>   Now, we use pg_repoint to apply the dxy offsets, and calculate new limb, ring   shadow points: <span class= code-output >  pg_repoint, dxy, 0d, axis=center_ptd[0], gd=gd</span> <span class= code-output >  limb_ptd = pg_limb(gd=gd) & pg_hide, limb_ptd, gd=gd, bx=rd, /rm</span> <span class= code-output >  ring_ptd = pg_disk(gd=gd) & pg_hide, ring_ptd, gd=gd, bx=pd, /rm</span> <span class= code-output >  shadow_ptd = pg_shadow_globe(gd=gd, ring_ptd)</span> <span class= code-output >  center_ptd = pg_center(gd=gd, bx=pd)</span> <span class= code-output >  object_ptd = [center_ptd,limb_ptd,ring_ptd,shadow_ptd]</span>    Now, we draw the newly-derived limb, ring and shadow points on a clean image: <span class= code-output >  tvim, im</span> <span class= code-output >  pg_draw, object_ptd, colors=colors, psyms=psyms, psizes=psizes, plabel=plabels</span>        Manually repointing the geometry    This pasteable section first clears the screen of the plotted points   by redisplaying the image with tvim.  It then calls pg_drag to allow   the user to use the cursor to drag the pointing, and with it the limb,   ring and planet center.  To move the pointing with pg_drag, use the left   mouse button and translate the pointing in x,y.  Use the middle mouse   button to rotate the pointing about an axis (in this case, the axis of   rotation is set as the planet center (center_ptd[0]).  When the   desired pointing is set, the right mouse button accepts it.  pg_drag   returns the delta x,y amount dragged (dxy) as well as the rotation   angle (dtheta).  pg_repoint uses the dxy and dtheta to update the   camera descriptor (cd, passed by gd).  The limb and center is then   recalculated, the image redisplayed to clear the objects drawn, and   then pg_draw is called to replot: <span class= code-output > tvim, im</span> <span class= code-output > dxy = pg_drag(object_ptd, dtheta=dtheta, axis=center_ptd[0])</span> <span class= code-output > pg_repoint, dxy, dtheta, axis=center_ptd[0], gd=gd</span>  <span class= code-output > limb_ptd = pg_limb(gd=gd) & pg_hide, limb_ptd, gd=gd, bx=rd, /rm</span> <span class= code-output > ring_ptd = pg_disk(gd=gd) & pg_hide, ring_ptd, gd=gd, bx=pd, /rm</span> <span class= code-output > shadow_ptd = pg_shadow_globe(gd=gd, ring_ptd)</span> <span class= code-output > center_ptd = pg_center(gd=gd, bx=pd)</span> <span class= code-output > object_ptd = [center_ptd,limb_ptd,ring_ptd,shadow_ptd]</span>  <span class= code-output > tvim, im</span> <span class= code-output > pg_draw, object_ptd, colors=colors, psyms=psyms, psizes=psizes, plabel=plabels</span>   Scanning the edge to find the limb and using it to calculate the pointing    This section calls pg_cvscan to scan the image around the predicted   limb position and the ring edge position (within width of 80 pixels) and   find the points of highest correlation with a given edge model for each   object (edge_model_nav_limb = limb model used in the VICAR program NAV   and edge_model_nav_ring = ring model from NAV) and zeropoint offset in   the given model (lzero).  These points are then plotted: <span class= code-output > cvscan_ptd = pg_cvscan(dd, gd=gd, [limb_ptd,ring_ptd], edge=30, width=80, $</span> <span class= code-output > model=[make_array(nlimb,val=ptr_new(edge_model_nav_limb(zero=lzero))), $</span> <span class= code-output >   make_array(nring,val=ptr_new(edge_model_nav_ring(zero=rzero)))], $</span> <span class= code-output >   mzero=[make_array(nlimb,val=lzero),$</span> <span class= code-output >   make_array(nring,val=rzero)] )</span> <span class= code-output > tvim, im</span> <span class= code-output > pg_draw, cvscan_ptd</span>        Thresholding using correlation coefficient    This section (optional) calls pg_threshold to remove points with lower   correlation coefficients.  The /relative flag means that the minimum   and maximum thresholds are taken as a fraction to the maximum value   in the array.  Notice here again that the ring is treated as two   objects: <span class= code-output > pg_threshold, cvscan_ptd, min=[0.8, 1.0, 0.8], max=[1.2, 1.0, 1.2], /rel</span> <span class= code-output > tvim, im</span> <span class= code-output > pg_draw, cvscan_ptd</span>       Removing regions of bad points    This section (optional) calls pg_select to remove points within a   polygonal region as defined by the cursor.  Click the left mouse   button to mark a point and move the mouse to the next point and   click.  Use the middle mouse button to erase a point and the right   mouse button to end the region.  pg_trim removes the points in the   just defined region.  The scan points are then replotted.   Repeat these statements for each region a user wants to remove: <span class= code-output > region = pg_select(dd)</span> <span class= code-output > pg_trim, dd, cvscan_ptd, region</span> <span class= code-output > tvim, im</span> <span class= code-output > pg_draw, cvscan_ptd</span>   Fitting the pointing to the scanned points    This section calls pg_cvscan_coeff to determine the linear least-squares   coefficients for a fit to the image coordinate translation and rotation   which matches the computed curve to the scanned curve. It then calls   pg_fit to do the fit with the calculated coefficients to calculate the   correction in translation (dxy) and rotation (dtheta).  It calls   pg_cvchisq to get the chi square of the fit.  Then calls pg_repoint to   update the pointing. Recalculates the limb and center and replots.   The determination of the curves and their subsequent fit can be   iterated on: <span class= code-output > cvscan_cf = pg_cvscan_coeff(cvscan_ptd, axis=center_ptd[0])</span> <span class= code-output > dxy = pg_fit([cvscan_cf], dtheta=dtheta)</span> <span class= code-output > chisq = pg_chisq(dxy, dtheta, cvscan_ptd, axis=center_ptd[0])</span> <span class= code-output > print, dxy, dtheta*180./!pi, chisq</span> <span class= code-output > pg_repoint, dxy, dtheta, axis=center_ptd[0], gd=gd</span>  <span class= code-output > limb_ptd = pg_limb(gd=gd) & pg_hide, limb_ptd, gd=gd, bx=rd, /rm</span> <span class= code-output > ring_ptd = pg_disk(gd=gd) & pg_hide, ring_ptd, gd=gd, bx=pd, /rm</span> <span class= code-output > center_ptd = pg_center(gd=gd, bx=pd)</span> <span class= code-output > object_ptd = [center_ptd,limb_ptd,ring_ptd]</span>  <span class= code-output > tvim, im</span> <span class= code-output > pg_draw, object_ptd, colors=colors, psyms=psyms, psizes=psizes, plabel=plabels</span>    Draw planet and ring latitude/longitude grid    This sections calculates a latitude/longitude grid for each planet and a   radius/longitude grid for the rings.  By default it draws 12 latitude   and 12 longitude grid lines.  The longitude grid lines circle the body   and so on a map they will appear as 24 grid lines.  The ring radius grid   uses four grid lines by default between the inner and outer ring radius.   It uses pg_hide to set as not visible the points on the grid behind the   planet and ring for both objects.  It then uses pg_draw to draw the   grid points in blue (ctblue): <span class= code-output > tvim, im</span> <span class= code-output > grid_ptd = pg_grid(gd=gd, lat=lat, lon=lon)</span> <span class= code-output > pg_hide, grid_ptd, cd=cd, gbx=pd, /assoc</span> <span class= code-output > pg_hide, grid_ptd, cd=cd, gbx=pd, od=sund, /assoc</span> <span class= code-output > pg_hide, grid_ptd, gd=gd, bx=rd</span> <span class= code-output > pg_draw, grid_ptd, color=ctblue()</span>  <span class= code-output > plat_ptd = pg_grid(gd=gd, slon=!dpi/2d, lat=lat, nlon=0)</span> <span class= code-output > pg_hide, plat_ptd[0], cd=cd, gbx=pd[0], /assoc</span> <span class= code-output > pg_draw, plat_ptd[0], psym=3, plabel=strtrim(round(lat*180d/!dpi),2), /label_p</span>  <span class= code-output > plon_ptd = pg_grid(gd=gd, slat=0d, lon=lon, nlat=0)</span> <span class= code-output > pg_hide, plon_ptd[0], cd=cd, gbx=pd[0], /limb</span> <span class= code-output > pg_draw, plon_ptd[0], psym=3, plabel=strtrim(round(lon*180d/!dpi),2), /label_p</span>  <span class= code-output > dgrid_ptd = pg_grid(gd=gd, bx=rd) & pg_hide, dgrid_ptd, gd=gd, bx=pd</span> <span class= code-output > pg_draw, dgrid_ptd, color=ctpurple()</span>        Defining a ring sector for a plot    To plot a ring radius vs. intensity or longitude vs. intensity, the   user must first define the limits of the ring sector.  Here it is   done in one of two ways, the first is to define the longitude (lon)   and radius (rad) limits in an array.  The second method is to use   the cursor to sweep out a ring sector, pg_ring_sector is called to   do this.  To use the mouse, click in one corner of your desired sector   and drag the cursor to the opposite corner.  In this example,   counterclockwise is the direction of increasing longitude.  The chosen   sector is then calculated using pg_profile_ring with the /outline   keyword.  This outline is then drawn with pg_draw: <span class= code-output > tvim,im</span> <span class= code-output > outline_ptd = pg_ring_sector(gd=gd, rad=rad, lon=lon, slope=slope)</span> <span class= code-output > pg_draw, outline_ptd, col=ctgreen()</span>        Plotting ring sector plots       Below is the code for four different types of plots using pg_profile_ring.      Radial (default) and longitudinal (/azimuthal), interpolated (default)      and binned (/bin).  There is an oversamp keyword which defines the amount      to oversample (vs. 1 pixel).  In the case of a longitudinal bin scan,      pixelization can cause some bins to contain very low numbers or none at      all.  In this example oversamp=0.3 to cause the plot to have larger bins      to help alleviate this problem.  The calculated profile is then plotted      in a new window.       Radial scan: <span class= code-output >   dd_prof=pg_profile_ring(dd, gd=gd, outline_ptd, dsk_pts=dsk_pts, profile=profile)</span> <span class= code-output >   window, /free, xs=500, ys=300</span> <span class= code-output >   plot, dsk_pts[*,0], profile</span>              Longitudinal scan: <span class= code-output > dd_prof = pg_profile_ring(dd, gd=gd, outline_ptd, /azimuthal, dsk_pts=dsk_pts, profile=profile)</span> <span class= code-output > window, /free, xs=500, ys=300</span> <span class= code-output > plot, dsk_pts[*,1], profile, /yno</span>          ", "", "          -1", "");
  

libdata[libdataItem++] = new Array("defunct/stars_example.html", "stars_example.pro", '.pro file in <a href="defunct/dir-overview.html">defunct/ directory</a>', "stars_example.pro", "", "", " Star fitting example   This example requires a star catalog. The options are: UCAC4, UCACT,  TYCHO2, SAO, and GSC2. To learn more about where to obtain these  catalogs, please see the documentation for the star catalog translators,  strcat_ucac4_input, strcat_ucact_input, strcat_tycho2_input,  strcat_sao_input, and strcat_gsc2_input.   In this script, the star fitting capabilities of OMINAS will be demonstrated.   This example file can be executed from the UNIX command line using: <span class= code-output >ominas stars_example</span>  or from within an OMINAS IDL session using: <span class= code-output >@stars_example</span>  After the example stops, later code samples in this file may be executed by  pasting them onto the IDL command line.   Image read and display   This first section uses dat_read to read in the image. There are several  available image files to use for the preocessing:   	c1138223.gem: Voyager VICAR format file where the image has had  	the camera distortions removed with the VICAR program GEOMA.   	N1456251768_1.IMG: Cassini ISS-NA image, obtained from the PDS imaging  	node.   dat_read reads the image portion (im) and the image label (label) and its  output is a data descriptor (dd). tvim is called to display the image (im)  at 3/4 size in a new window with the y coordinate as top-down.   Note: Users with a 24-bit display, you may want to do the device command  'pseudo=8' so that xloadct can be used to contrast enhance the image.   Code: <span class= code-output >;dd = dat_read('data/c1138223.gem', im, label)           ; VICAR format file</span> <span class= code-output >dd = dat_read(getenv('OMINAS_DIR')+'/demo/data/N1456251768_1.IMG', im, label)    ; Cas ISS-NA image</span> <span class= code-output >tvim, im, zoom=0.75, /order</span>   Filling the descriptors   This section fills the camera descriptor (cd), the planet descriptor  (pd) and the ring descriptor (rd) for use by the software.   Code: <span class= code-output >cd = pg_get_cameras(dd)</span> <span class= code-output >pd = pg_get_planets(dd, od=cd)</span> <span class= code-output >rd = pg_get_rings(dd, pd=pd, od=cd)</span>   Filling the generic descriptor   This line fills a  generic  descriptor, which is a standard IDL struct.  Generic descriptors are a convenient notation for several descriptors to  be grouped into a structure that can be passed to functions in one piece.   The components of the generic descriptor are: <span class= code-output >cd - camera descriptor part</span> <span class= code-output >gbx - globe descriptor part</span> <span class= code-output >dkx - disk descriptor part</span>  Code: <span class= code-output >gd = {cd:cd, gbx:pd, dkx:rd}</span>   Filling the star descriptor   This line fills a star descriptor by reading the star catalog using  pg_get_stars. pg_get_stars calls back-end functions to read the  translator table. Therefore, for a specific instrument (for instance,  both ISS-NA and ISS-WA), the star catalog should be specified. The  translators.tab for this demo (in data/translators.tab) should contain  a line with the star catalog to be used: <span class= code-output > -   strcat_tycho2_input     -       /j2000    # or /b1950 if desired</span>  This line specifies that the tycho2 catalog should be used, and all  coordinates should be for the j2000 epoch. Likewise, such a line should  be included in the translator for any mission to be processed.   NOTES:   If the keyword 'tr_override' is specified, only the specified   translator is called instead of whatever star catalog   translators are listed in the translators table.    The translator keyword 'faint' selects only stars with magnitudes   brighter than 14.  The keyword, 'bright' may be used place an upper   bound on the brightness.    /no_sort suppresses the default behavior of returning only   the first object found with any given name.  That operation can be   very time consuming when a large number of objects are returned   by the translators.  In the first case, we have specified that only one   translator will be called, and we know that it will not return   duplicate objects.   Code: <span class= code-output >;sd = pg_get_stars(dd, od=cd, /no_sort, tr_ov='strcat_gsc2_input', 'faint=8')</span> <span class= code-output >sd = pg_get_stars(dd, od=cd, 'faint=14')</span>   Calculating the star centers   The star centers are calculated using pg_center. bx is an output  keyword which contains the body descriptor, in this case it is an  array of star descriptors. Each star descriptor describes the  data for one star.   pg_hide is called to remove (/rm) any star points covered by the  planet (/globe). Although there is no planet in the Cassini image,  this technique should be used to hide star points in general, were  there to be a limb_ptd.   Determining the plot characteristics   The star elements are chosen to be red, with a symbol type of *  (code 2), a font size of 2, and labels corresponding to the name of  each star. Stars can have either catalog names or common names.   Code: <span class= code-output >star_ptd=pg_center(bx=sd, gd=gd) & pg_hide, star_ptd, gd=gd, bx=pd, /rm</span> <span class= code-output >n_stars=n_elements(sd)</span> <span class= code-output >color = ctred()</span> <span class= code-output >psym = 6</span> <span class= code-output >csizes = 2</span> <span class= code-output >plabels = cor_name(sd)</span>   Drawing the star centers   This section draws the stars in the star_ptd with the colors, plot  symbols, font size, and labels defined earlier.   In this particular example, the planet does not appear in the image.   Code: <span class= code-output >pg_draw, star_ptd, color=color, psym=psym, plabel=plabels, csi=csizes</span>   Drawing the stellar spectral types   This pasteable section uses the stellar library function str_sp to return  spectral types of the stars and uses them instead of the star names. If  the spectral type is not available for the catalog, then no information  will be plotted in the labels.   Code: <span class= code-output >tvim, im</span> <span class= code-output >spt=str_sp(sd)</span> <span class= code-output >psyms_str=make_array(n_stars,val=6)</span> <span class= code-output >pg_draw, star_ptd, color=color, psym=psym, plabel=spt, csi=csizes</span>   Drawing stellar magnitudes   This pasteable section uses the stellar library function str_get_mag to get  visual magnitudes of the stars and uses them instead of the star names.   Code: <span class= code-output >tvim, im</span> <span class= code-output >sm = str_get_mag(sd)</span> <span class= code-output >smag = string(sm, format='(f4.1)')</span> <span class= code-output >psyms_str=make_array(n_stars,val=6)</span> <span class= code-output >pg_draw, star_ptd, color=color, psym=psym, plabel=smag, csi=csizes</span>   Manually repointing the geometry   This pasteable section first clears the screen of the plotted points  by redisplaying the image with tvim.  It then calls pg_drag to allow  the user to use the cursor to drag the pointing, and with it the stars.  To move the pointing with pg_drag, use the left mouse button and  translate the pointing in x,y.  Use the middle mouse button to rotate  the pointing about an axis (in this case, the axis of rotation is set  as the optic axis of the image (star_ptd) which is defined using the  routine pnt_create_descrptors with the points being the camera optic  axis as returned by the camera library routine cam_oaxis.  When the  desired pointing is set, the right mouse button accepts it.  pg_drag  returns the delta x,y amount dragged (dxy) as well as the rotation  angle (dtheta).  pg_repoint uses the dxy and dtheta to update the  camera descriptor (cd, passed by gd).  The limb, ring and star points  are then recalculated, the image redisplayed to clear the objects drawn,  and then pg_draw is called to replot.   Code: <span class= code-output >optic_ptd = pnt_create_descriptors(points=cam_oaxis(cd))</span> <span class= code-output >tvim, im</span> <span class= code-output >dxy = pg_drag(star_ptd, dtheta=dtheta, axis=optic_ptd, symbol=6)  ; square</span> <span class= code-output >pg_repoint, dxy, dtheta, axis=optic_ptd, gd=gd</span> <span class= code-output >star_ptd=pg_center(bx=sd, gd=gd) & pg_hide, star_ptd, gd=gd, bx=pd, /rm</span> <span class= code-output >tvim, im</span> <span class= code-output >pg_draw, star_ptd, color=color, psym=psym, plabel=plabels</span>   Scanning to find the stars and using it to calculate the pointing   This section calls pg_ptscan to scan the image around the predicted  star positions (within width of 40 pixels) and find the pixels with  the highest correlation with a given edge model (example uses the  default gaussian) for each star.  These points are then plotted.   Code: <span class= code-output >ptscan_ptd = pg_ptscan(dd, star_ptd, edge=30, width=40)</span> <span class= code-output >pg_draw, ptscan_ptd, psym=1, col=ctyellow()</span>   Thresholding using correlation coefficient   This section (optional) calls pg_threshold to remove points with lower  correlation coefficients.  This example only keeps stars with a  correlation coefficient above 0.6.  Notice that each object can have  its own min and max value.   Code: <span class= code-output >pg_threshold, ptscan_ptd, min=make_array(n_stars,val=0.6), $</span> <span class= code-output >                          max=make_array(n_stars,val=1.0)</span> <span class= code-output >tvim, im</span> <span class= code-output >pg_draw, object_ptd, colors=colors, psyms=psyms, psizes=psizes, plabel=plabels</span> <span class= code-output >pg_draw, ptscan_ptd, psym=1, col=ctyellow()</span>   Removing regions of bad points   This section (optional) calls pg_select to remove points within a  polygonal region as defined by the cursor.  Click the left mouse  button to mark a point and move the mouse to the next point and  click.  Use the middle mouse button to erase a point and the right  mouse button to end the region.  pg_trim removes the points in the  just defined region.  The scan points are then replotted.  Repeat these statements for each region a user wants to remove.   Code: <span class= code-output >region=pg_select(dd)</span> <span class= code-output >pg_trim, dd, ptscan_ptd, region</span> <span class= code-output >tvim, im</span> <span class= code-output >pg_draw, object_ptd, colors=colors, psyms=psyms, psizes=psizes, plabel=plabels</span> <span class= code-output >pg_draw, ptscan_ptd, psym=1, col=ctyellow()</span>   Fitting the pointing to the found stars   This section calls pg_ptscan_coeff to determine the linear  least-squares coefficients for a fit to the image coordinate translation  and rotation which matches the computed positions to the scanned  positions. It then calls pg_fit to do the fit with the calculated  coefficients to calculate the correction in translation (dxy) and  rotation (dtheta).  It calls pg_ptchisq to get the chi square of the  fit.  It then calls pg_repoint to update the pointing.  Recalculates  the limb, rings and stars and replots.   Code: <span class= code-output >optic_ptd = pnt_create_descriptors(points=cam_oaxis(cd))</span> <span class= code-output >ptscan_cf = pg_ptscan_coeff(ptscan_ptd, axis=optic_ptd)</span> <span class= code-output >dxy = pg_fit([ptscan_cf], dtheta=dtheta)</span> <span class= code-output >chisq = pg_chisq(dxy, dtheta, ptscan_ptd, axis=optic_ptd[0])</span> <span class= code-output >covar = pg_covariance([ptscan_cf])</span> <span class= code-output >print, dxy, dtheta*180./!pi, chisq, covar</span> <span class= code-output >pg_repoint, dxy, dtheta, axis=optic_ptd, gd=gd</span> <span class= code-output >star_ptd = pg_center(bx=sd, gd=gd) & pg_hide, star_ptd, gd=gd, bx=pd, /rm</span> <span class= code-output >tvim, im</span> <span class= code-output >pg_draw, star_ptd, color=color, psym=psym, plabel=plabels</span>   Output the new state   This section (optional) shows how you can save your output: any changes  to the image data into a new file and the new pointing into a detached  header.   Code: <span class= code-output >pg_put_cameras, dd, gd=gd</span> <span class= code-output >dat_write, getenv('OMINAS_DIR')+'/demo/data/c1138223_nv.gem', dd</span>  ", "", "          -1", "");
  

libdata[libdataItem++] = new Array("./tiepoints_example.html", "tiepoints_example.pro", '.pro file in <a href="./dir-overview.html">./ directory</a>', "tiepoints_example.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("./vims_example.html", "vims_example.pro", '.pro file in <a href="./dir-overview.html">./ directory</a>', "vims_example.pro", "", "", " VIMS EXAMPLE     This script demonstrates reading Cassini RADAR VIMS cubes and projecting them    onto an equirectangular mosaic.     The data files are provided in the demo/data directory.     Setup: The instrument detectors, translators and transforms must contain the    VIMS definitions, as is included in demo/data/instrument_detectors.tab,    demo/data/translators.tab, and demo/data/transforms.tab.     This example requires SPICE/Icy to have been setup. It can be run just by doing: <span class= code-output > .run vims_example</span>    from within an OMINAS IDL session.   Read VIMS files       Set up a hash containing the file names and precomputed pointing offsets: <span class= code-output > hdxy=hash()</span> <span class= code-output > hdxy['CM_1559100372_1_ir_eg.cub']=[-2d0,-2d0]</span> <span class= code-output > hdxy['CM_1503358311_1_ir_eg.cub']=[5d0,-1d0]</span> <span class= code-output > hdxy['CM_1477456632_1_ir_eg.cub']=[2d0,-3d0]</span> <span class= code-output > hdxy['CM_1504754217_1_ir_eg.cub']=[1d0,-2d0]</span>  <span class= code-output > files=getenv('OMINAS_DIR')+'/demo/data/'+((hdxy.keys()).toarray())</span> <span class= code-output > n = n_elements(files)</span> <span class= code-output > dd = dat_read(files)</span> <span class= code-output > foreach ddd,dd do dat_set_data,ddd,0.&gt;dat_data(ddd)&lt;0.1</span>   Set up descriptors needed to make the grids and mosaic       Create an array of global descriptors and populate it: <span class= code-output > gd = replicate({cd:obj_new(),cds:objarr(256), gbx:obj_new(), dkx:obj_new(), sund:obj_new()}, n)</span> <span class= code-output > for i=0, n-1 do gd[i].cds = pg_get_cameras(dd[i])</span> <span class= code-output > for i=0, n-1 do gd[i].cd=gd[i].cds[0]</span> <span class= code-output > for i=0, n-1 do gd[i].gbx = pg_get_planets(dd[i], od=gd[i].cd, name='TITAN')</span> <span class= code-output > for i=0, n-1 do gd[i].sund = pg_get_stars(dd[i], od=gd[i].cd, name='SUN')</span>      Apply the pointing shifts and compute the limbs: <span class= code-output > limb_ps = objarr(n)</span> <span class= code-output > dxy = dblarr(2,n)</span> <span class= code-output > for i=0, n-1 do dxy[*,i] = hdxy[file_basename(files[i])]</span> <span class= code-output > for i=0, n-1 do for j=0,255 do pg_repoint, dxy[*,i], 0d, cd=gd[i].cds[j]</span> <span class= code-output > for i=0, n-1 do gd[i].cd=gd[i].cds[0]</span> <span class= code-output > for i=0, n-1 do limb_ps[i] = pg_limb(gd=gd[i]);</span>   Display an image of one of the bands with a limb and grid on top       Create an array of global descriptors and populate it: <span class= code-output > xsize=800</span> <span class= code-output > ysize=800</span> <span class= code-output > zoom=8</span> <span class= code-output > offset=[-20,-20]</span> <span class= code-output > for i=0, n-1 do begin</span> <span class= code-output >   tvim, (dat_data(dd[i]))[*,*,70], $</span> <span class= code-output >     zoom=zoom,/order, /new,offset=offset,$</span> <span class= code-output >     xsize=xsize,ysize=ysize</span> <span class= code-output >   pg_draw, limb_ps[i]</span> <span class= code-output >   write_png,tvrd()</span> <span class= code-output > endfor</span> <span class= code-output > tvim, /list, wnum=ww</span>      Create and draw the lat/lon grid and labels: <span class= code-output > imc=0</span> <span class= code-output > for i=0,n-1 do begin</span> <span class= code-output >   grid_ps = pg_grid(gd=gd[i], lat=lat, lon=lon)</span> <span class= code-output >   pg_hide, grid_ps, cd=gd[i].cd, gbx=gd[i].gbx</span> <span class= code-output >   pg_hide, grid_ps, cd=gd[i].cd, gbx=gd[i].gbx,$</span> <span class= code-output >     od=gd[i].sund</span> <span class= code-output >   pg_draw, grid_ps, color=ctblue(),wnum=ww[i]</span> <span class= code-output >   plat_ps = pg_grid(gd=gd[i],slon=!dpi/2d,lat=lat,nlon=0)</span> <span class= code-output >   pg_hide, plat_ps[0], cd=gd[i].cd, gbx=gd[0].gbx</span> <span class= code-output >   pg_draw, plat_ps[0], psym=3, $</span> <span class= code-output >     plabel=strtrim(round(lat*180d/!dpi),2),$</span> <span class= code-output >     /label_p,wnum=ww[i]</span> <span class= code-output >   plon_ps = pg_grid(gd=gd[i], slat=0d, lon=lon, nlat=0)</span> <span class= code-output >   pg_hide, plon_ps[0], cd=gd[i].cd, gbx=gd[i].gbx</span> <span class= code-output >   pg_draw, plon_ps[0], psym=3, $</span> <span class= code-output >     plabel=strtrim(round(lon*180d/!dpi),2),$</span> <span class= code-output >     /label_p,wnum=ww[i]</span> <span class= code-output > endfor</span>      These 4 images would look like                                Create a 3-band mosaic       Correct the illumination with a Lambertian function: <span class= code-output > dd_pht = objarr(n)</span> <span class= code-output > for i=0, n-1 do dd_pht[i] = pg_photom(dd[i], gd=gd[i],</span> <span class= code-output >   refl_fn='pht_lamb', refl_parm=[0.9d], outline=limb_ps[i])</span> <span class= code-output > phtdata=list()</span> <span class= code-output > for i=0,n-1 do phtdata.add,(dat_data(dd_pht[i]))</span>      Set up the mosaic: <span class= code-output > bands=[70,104,106]</span> <span class= code-output > map_xsize = 1600</span> <span class= code-output > map_ysize = 800</span> <span class= code-output > moslim=[[0d0,0.2d0],[0d0,0.01d0],[0d0,0.1d0]]</span> <span class= code-output > mosaics=list()</span>      Loop over bands, projecting and displaying each image: <span class= code-output > foreach band,bands,iband do begin</span> <span class= code-output >   for i=0,n-1 do dat_set_data,dd_pht[i],phtdata[i,*,*,band]</span> <span class= code-output >   md = pg_get_maps(/over, gbx = pd1, name='TITAN',$</span> <span class= code-output >    type='RECTANGULAR',fn_data=ptr_new(),$</span> <span class= code-output >    size=[map_xsize,map_ysize],origin=[map_xsize,map_ysize]/2)</span> <span class= code-output >   dd_map = objarr(n)</span> <span class= code-output >   for i=0, n-1 do begin</span> <span class= code-output >    dd_map[i]=pg_map(dd_pht[i],md=md,gd=gd[i],aux=['EMM'])</span> <span class= code-output >    tvim,dat_data(dd_map[i])&lt;max((dat_data(dd[i]))[*,*,band]),/new</span> <span class= code-output >   endfor</span>      These projected images would look like:                                   Combine the images in a mosaic and display it: <span class= code-output >   dd_mosaic = pg_mosaic(dd_map, mosaic=mosaic, $</span> <span class= code-output >     wt='emm', comb='sum', data={x:1, emm0:cos(90d*!dpi/180d)})</span> <span class= code-output >   tvim,moslim[0,iband]&gt;mosaic&lt;moslim[1,iband],/new</span>      Add a grid on top: <span class= code-output >   pd = pg_get_planets(dd[0], od=gd[0].cd)</span> <span class= code-output >   gdm={cd:md,od:(gd[0].cd)[0],gbx:cor_select(pd,'TITAN'),$</span> <span class= code-output >    dkx:gd[0].dkx}</span> <span class= code-output >   map_grid_ps=pg_grid(gd=gdm, lat=lat, lon=lon)</span> <span class= code-output >   plat_ps=pg_grid(gd=gdm, slon=!dpi/2d, lat=lat, nlon=0)</span> <span class= code-output >   plon_ps=pg_grid(gd=gdm, slat=0d, lon=lon, nlat=0)</span> <span class= code-output >   pg_draw, map_grid_ps, col=ctgreen()</span> <span class= code-output >   pg_draw,plat_ps,psym=7,$</span> <span class= code-output >    plabel=strmid(strtrim(lat*180d/!dpi,2),0,3),/label_p</span> <span class= code-output >   pg_draw,plon_ps,psym=7,$</span> <span class= code-output >     plabel=strmid(strtrim(lon*180d/!dpi,2),0,3),/label_p</span> <span class= code-output >   mosaics.add,mosaic</span> <span class= code-output > endforeach</span>      The mosaics would look like, for each band:                       ", "", "          -1", "");
  

libdata[libdataItem++] = new Array("./voyager-cp_example.html", "voyager-cp_example.pro", '.pro file in <a href="./dir-overview.html">./ directory</a>', "voyager-cp_example.pro", "", "", "", "", "          -1", "");
  

libdata[libdataItem++] = new Array("./voyager-pn.example.html", "voyager-pn.example.pro", '.pro file in <a href="./dir-overview.html">./ directory</a>', "voyager-pn.example.pro", "", "", "", "", "          -1", "");
  

