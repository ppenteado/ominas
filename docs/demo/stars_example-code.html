<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.6.1 on Fri Jun 23 14:05:47 2017 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>stars_example.pro (OMINAS API Documentation)</title>

    
    <style type="text/css" media="all">
            /* setup page */
      body { font-family: Helvetica, sans-serif; font-size: 12pt; margin: 0; padding: 0; }
      div.content { padding: 1em; }
      p { line-height: 1.4; }
      td p { padding-bottom: 0.5em; }
      img { border: 0; }
      
      /* link styles */
      a { text-decoration: none; }
      a:link, a:visited { color: #0000FF; }
      a:hover, a:focus { background: yellow; border-bottom: 1emx dotted #303099; }
      
      /* dir-overview styles */
      dt.filename { margin-top: 0.5em; }
      dl.file_listing { margin-left: 1em; }
      
      /* titles */
      h1, h2, h3, h4 { font-weight:normal; color: #871E31; margin-top: 1.5em; }
      h4 { margin-bottom: 0.25em; }
      .center { margin-left: auto; margin-right: auto; }
      .small { font-family: Verdana, Helvetica, sans-serif; font-size: 90%; }
      .smaller { font-family: Verdana, Helvetica, sans-serif; font-size: 80%; }
      .smallest { font-family: Verdana, Helvetica, sans-serif; font-size: 70%; }
      h1.basename { margin-top: 0; margin-bottom: 0; }
      h1.basename span.file-attributes { font-size: 70%; margin-left: 3em; color: #384806; }
      h2.directory { font-size: 90%; margin-bottom: 0; }
      h2.routine-name { margin-top: 0; margin-bottom: 0; }
      p.categories { color: #384806; margin-top: 0; }
      span.file_attribute { float: right; color: #384806; margin: 0 0 1em 3em; }
      div#file_comments { margin-top: 1em; }
      
      div.routine-details { border: 1px dotted #C0C0C0; margin-top: 1em; padding: 1em; }
      span.routine-attributes { font-size: 70%; margin-left: 3em; color: #384806; }
      div.details dt { color: #871E31; margin-left: 2em; }
      div.details dt span { color: #384806; margin-left: 2em; }
      div.details dd { margin: 0.5em 2em 1em 4em; }
      a.top {
        font-family: Verdana, Helvetica, sans-serif;
        font-size: 8pt;
        font-weight: bold;
        color: #5070ff;
        text-transform: uppercase;
        float: right;
        margin-left: 1em;
      }
      
      /* comments */
      .pre { white-space: pre; }
      
      /* code styles */
      code { font-family: Monaco, "Courier New", Courier, monospace; font-size: 95%; }
      code.listing { white-space: pre; display: block; margin: 0.75em 0 0.75em 0; padding: 0 3em 0 1em; line-height: 1.4em; }
      code.source { white-space: pre; display: block; }
      code.source span.comments { color: #408080; }
      .syntax { margin-top: 1em; margin-left: 1.5em; text-indent: -1.5em; }
      .var { font-style: italic; }
      .argument { } /* white-space: nowrap; does not work in Safari (and sometimes not even in Firefox) */
      
      dl.routine-summary dt { margin-bottom: 0.25em; }
      dl.routine-summary dd { margin-bottom: 0.5em; margin-left: 2em; }
      
      ul.inherited-method-summary { padding-left: 0em; margin-left: 0em; }
      
      /* general styles */
      ul li { list-style-type: none; }
      table { empty-cells: show; }
      thead { color: #871E31; }
      dd { margin-bottom: 0.35em; }
      input, textarea { background: #F3F6ED; border: #E1D6C6 1px solid; padding: 2px 1em 2px 0.5em; }
      input.text { background: #FFFFC0; }
      
      div.note { margin: 1em 2em 1em 2em; background: #EFEFEF; border: 1px #A0A0A0 dotted; padding: 0 1em 0 1em; }
      p.indent { margin-left: 2em; }
      
      /* An attribute table is a vertical list of name-value pairs. */
      table.box {
        background: #EFEFEF;
        border: 1px #A0A0A0 dotted;
        padding-top: 0.75em;
        padding-bottom: 0.75em;
      }
      table.attribute { padding-left: 0.75em; padding-right: 0.75em; }
      table td { vertical-align: top; }
      table.attribute p { margin: 0; }
      table td.name { font-style: normal; padding-right: 1.5em; }
      ul.fieldslist { padding-top: 0; color: #909090; }
      ul.fieldslist li { margin-bottom: 0.25em; }
      span.fieldname { color: #000000; }
      
      dl.attribute dt { color: #990000; }
      
      /* header/navbar styles */
      div.header { padding: 2em 2em 0 2em; background: #9E9D7B; border-bottom: 2px #262626 solid; }
      div.header h1 { color: white; margin:0; font-weight: normal; }
      div.header h2 { color: white; margin-top: 0; margin-bottom: 1em; font-weight: normal; font-style: italic; font-size: 100%; }
      table.navbar { background: #CCC097; margin: 0; padding: 0; border-bottom: 1px #262626 dotted; width: 100%; }
      table.navbar td { padding: 4px 0.5em 3px 0.5em; white-space: nowrap; vertical-align: top; }
      table.navbar td.flexible { width: 100%; text-align: right; padding-right: 1em; white-space: nowrap; }
      table.navbar td.selected { background: #262626; }
      table.navbar td.selected, table.navbar td.selected a { color: white; }
      table.navbar a:hover, table.navbar a:focus { background: inherit; border-bottom: 1px solid #303099; }
      p.localnavbar { text-align: right; margin: 0.2em 1em 0.2em 0.2em; padding: 0; }
      
      /* CSS graphics styles */
      div.box {
        margin-left: 0.25em;
        display: inline-block;
        width: 0.9em;
        height: 0.9em;
        vertical-align: -1px;
      }
      .red { background-color: #A00; }
      .orange { background-color: #F40; }
      .green { background-color: #480; }
      
      /* index styles */
      span.index_type { margin-left: 1em; }
      dl.index_listing dd { margin-bottom: 0.5em; margin-left: 2em; }
      dl.index_listing dd p { margin-top: 0.2em; margin-bottom: 0em; }
      
      /* search styles */
      fieldset { border: #ddd 1px solid; padding: 1em; margin-top: 3em; }
      legend { color: #871E31; font-size: 120%; }
      label { white-space: nowrap; }
      p.description { margin: 2em 2em 1em 2em; }
      form table td.name { vertical-align: middle; }
      
      /* footer styles */
      div.footer { padding: 0.5em 1em 0.5em 1em; background: #EFEFEF; border-top: 1px #A0A0A0 dotted; }
      div.footer table { width: 100%; }
      div.footer td.right { text-align: right; }

    </style>
    <style type="text/css" media="print">
            p.localnavbar { display: none; }
      
      div.header { background: white; }
      div.header h1 { color: black; }
      div.header h2 { color: black; }

    </style>
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="stars_example.pro (OMINAS API Documentation)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">; docformat = 'rst'</span>
<span class="comments">;==============================================================================</span>
<span class="comments">;+</span>
<span class="comments">; Star fitting example</span>
<span class="comments">; ====================</span>
<span class="comments">;</span>
<span class="comments">; Note: One optional image in this example requires the voyager SEDR</span>
<span class="comments">; files, which is not supplied in the default installation.</span>
<span class="comments">;</span>
<span class="comments">; This example requires a star catalog. The options are: UCAC4, UCACT,</span>
<span class="comments">; TYCHO2, SAO, and GSC2. To learn more about where to obtain these</span>
<span class="comments">; catalogs, please see the documentation for the star catalog translators,</span>
<span class="comments">; `strcat_ucac4_input`, `strcat_ucact_input`, `strcat_tycho2_input`, </span>
<span class="comments">; `strcat_sao_input`, and `strcat_gsc2_input`.</span>
<span class="comments">;</span>
<span class="comments">; In this script, the star fitting capabilities of OMINAS will be demonstrated.</span>
<span class="comments">;</span>
<span class="comments">; This example file can be executed from the UNIX command line using::</span>
<span class="comments">;</span>
<span class="comments">;  ominas stars_example</span>
<span class="comments">;</span>
<span class="comments">; or from within an OMINAS IDL session using::</span>
<span class="comments">;</span>
<span class="comments">;  @stars_example</span>
<span class="comments">;</span>
<span class="comments">; After the example stops, later code samples in this file may be executed by</span>
<span class="comments">; pasting them onto the IDL command line.</span>
<span class="comments">;-</span>
<span class="comments">;==============================================================================</span>
!quiet = 1
<span class="comments">;-------------------------------------------------------------------------</span>
<span class="comments">;+</span>
<span class="comments">; Image read and display</span>
<span class="comments">; ======================</span>
<span class="comments">;</span>
<span class="comments">; This first section uses `dat_read` to read in the image. There are several</span>
<span class="comments">; available image files to use for the preocessing:</span>
<span class="comments">;</span>
<span class="comments">; 	c1138223.gem: Voyager VICAR format file where the image has had</span>
<span class="comments">; 	the camera distortions removed with the VICAR program GEOMA.</span>
<span class="comments">; </span>
<span class="comments">; 	N1456251768_1.IMG: Cassini ISS-NA image, obtained from the PDS imaging</span>
<span class="comments">; 	node. </span>
<span class="comments">;</span>
<span class="comments">; `dat_read` reads the image portion (im) and the image label (label) and its</span>
<span class="comments">; output is a data descriptor (dd). tvim is called to display the image (im)</span>
<span class="comments">; at 3/4 size in a new window with the y coordinate as top-down.</span>
<span class="comments">;</span>
<span class="comments">; Note: Users with a 24-bit display, you may want to do the device command</span>
<span class="comments">; `'pseudo=8'` so that xloadct can be used to contrast enhance the image.</span>
<span class="comments">;</span>
<span class="comments">; Code::</span>
<span class="comments">;</span>
<span class="comments">;  ;dd = dat_read('data/c1138223.gem', im, label)           ; VICAR format file</span>
<span class="comments">;  dd = dat_read(getenv('OMINAS_DIR')+'/demo/data/N1456251768_1.IMG', im, label)    ; Cas ISS-NA image</span>
<span class="comments">;  tvim, im, zoom=0.75, /order</span>
<span class="comments">;</span>
<span class="comments">;-</span>
<span class="comments">;-------------------------------------------------------------------------</span>
<span class="comments">;dd = dat_read('data/c1138223.gem', im, label)			; VICAR format file</span>
dd = dat_read(getenv('OMINAS_DIR')+'/demo/data/N1456251768_1.IMG', im, label)		<span class="comments">; Cas ISS-NA image</span>

tvim, im, zoom=0.75, /order

<span class="comments">;-------------------------------------------------------------------------</span>
<span class="comments">;+</span>
<span class="comments">; Filling the descriptors</span>
<span class="comments">; =======================</span>
<span class="comments">;</span>
<span class="comments">; This section fills the camera descriptor (cd), the planet descriptor</span>
<span class="comments">; (pd) and the ring descriptor (rd) for use by the software.</span>
<span class="comments">;  </span>
<span class="comments">; In this example, if the Voyager image is chosen, the default translators</span>
<span class="comments">; are skipped to use a SEDR update from a VICAR program called NAV instead</span>
<span class="comments">; of using the normal SEDR the regular translator would return.</span>
<span class="comments">;</span>
<span class="comments">; If the Cassini image is chosen, this option will be ignored.</span>
<span class="comments">; </span>
<span class="comments">; Code::</span>
<span class="comments">;</span>
<span class="comments">;  ; Voyager descriptor-generating code</span>
<span class="comments">;  ;cd = pg_get_cameras(dd, 'sedr_source=NAV')</span>
<span class="comments">;  ;pd = pg_get_planets(dd, od=cd, 'sedr_source=NAV')</span>
<span class="comments">;  ;rd = pg_get_rings(dd, pd=pd, od=cd, 'sedr_source=NAV')</span>
<span class="comments">;  ; Cassini descriptor-generating code</span>
<span class="comments">;  cd = pg_get_cameras(dd)</span>
<span class="comments">;  pd = pg_get_planets(dd, od=cd)</span>
<span class="comments">;  rd = pg_get_rings(dd, pd=pd, od=cd)</span>
<span class="comments">;-</span>
<span class="comments">;-------------------------------------------------------------------------</span>
<span class="comments">; Voyager descriptor-generating code</span>
<span class="comments">;cd = pg_get_cameras(dd, 'sedr_source=NAV')</span>
<span class="comments">;pd = pg_get_planets(dd, od=cd, 'sedr_source=NAV')</span>
<span class="comments">;rd = pg_get_rings(dd, pd=pd, od=cd, 'sedr_source=NAV')</span>
<span class="comments">; Cassini descriptor-generating code</span>
cd = pg_get_cameras(dd)
pd = pg_get_planets(dd, od=cd)
rd = pg_get_rings(dd, pd=pd, od=cd)

<span class="comments">;-------------------------------------------------------------------------</span>
<span class="comments">;+</span>
<span class="comments">; Filling the generic descriptor</span>
<span class="comments">; ==============================</span>
<span class="comments">;</span>
<span class="comments">; This line fills a "generic" descriptor, which is a standard IDL struct.</span>
<span class="comments">; Generic descriptors are a convenient notation for several descriptors to</span>
<span class="comments">; be grouped into a structure that can be passed to functions in one piece.</span>
<span class="comments">;</span>
<span class="comments">; The components of the generic descriptor are::</span>
<span class="comments">;</span>
<span class="comments">;  cd - camera descriptor part</span>
<span class="comments">;  gbx - globe descriptor part</span>
<span class="comments">;  dkx - disk descriptor part</span>
<span class="comments">; </span>
<span class="comments">; Code::</span>
<span class="comments">;</span>
<span class="comments">;  gd = {cd:cd, gbx:pd, dkx:rd}</span>
<span class="comments">;-</span>
<span class="comments">;-------------------------------------------------------------------------</span>
gd = {cd:cd, gbx:pd, dkx:rd}

<span class="comments">;-------------------------------------------------------------------------</span>
<span class="comments">;+</span>
<span class="comments">; Filling the star descriptor</span>
<span class="comments">; ===========================</span>
<span class="comments">;</span>
<span class="comments">; This line fills a star descriptor by reading the star catalog using</span>
<span class="comments">; `pg_get_stars`. `pg_get_stars` calls back-end functions to read the</span>
<span class="comments">; translator table. Therefore, for a specific instrument (for instance,</span>
<span class="comments">; both ISS-NA and ISS-WA), the star catalog should be specified. The</span>
<span class="comments">; translators.tab for this demo (in data/translators.tab) should contain</span>
<span class="comments">; a line with the star catalog to be used::</span>
<span class="comments">;</span>
<span class="comments">;   -   strcat_tycho2_input     -       /j2000    # or /b1950 if desired</span>
<span class="comments">;</span>
<span class="comments">; This line specifies that the tycho2 catalog should be used, and all</span>
<span class="comments">; coordinates should be for the j2000 epoch. Likewise, such a line should</span>
<span class="comments">; be included in the translator for any mission to be processed. </span>
<span class="comments">; </span>
<span class="comments">; NOTES:</span>
<span class="comments">;  If the keyword 'tr_override' is specified, only the specified </span>
<span class="comments">;  translator is called instead of whatever star catalog</span>
<span class="comments">;  translators are listed in the translators table.</span>
<span class="comments">;</span>
<span class="comments">;  The translator keyword 'faint' selects only stars with magnitudes</span>
<span class="comments">;  brighter than 14.  The keyword, 'bright' may be used place an upper</span>
<span class="comments">;  bound on the brightness.</span>
<span class="comments">;</span>
<span class="comments">;  /no_sort suppresses the default behavior of returning only</span>
<span class="comments">;  the first object found with any given name.  That operation can be</span>
<span class="comments">;  very time consuming when a large number of objects are returned</span>
<span class="comments">;  by the translators.  In the first case, we have specified that only one</span>
<span class="comments">;  translator will be called, and we know that it will not return </span>
<span class="comments">;  duplicate objects.</span>
<span class="comments">;</span>
<span class="comments">; Code::</span>
<span class="comments">;</span>
<span class="comments">;  ;sd = pg_get_stars(dd, od=cd, /no_sort, tr_ov='strcat_gsc2_input', 'faint=8')</span>
<span class="comments">;  sd = pg_get_stars(dd, od=cd, 'faint=14')</span>
<span class="comments">;-</span>
<span class="comments">;-------------------------------------------------------------------------</span>
<span class="comments">;sd = pg_get_stars(dd, od=cd, /no_sort, tr_ov='strcat_gsc2_input', 'faint=8')</span>
sd = pg_get_stars(dd, od=cd, 'faint=14')

<span class="comments">;-------------------------------------------------------------------------</span>
<span class="comments">;+</span>
<span class="comments">; Calculating the star centers</span>
<span class="comments">; ============================</span>
<span class="comments">;</span>
<span class="comments">; The star centers are calculated using `pg_center`. bx is an output</span>
<span class="comments">; keyword which contains the body descriptor, in this case it is an</span>
<span class="comments">; array of star descriptors. Each star descriptor describes the</span>
<span class="comments">; data for one star. </span>
<span class="comments">;</span>
<span class="comments">; `pg_hide` is called to remove (/rm) any star points covered by the </span>
<span class="comments">; planet (/globe). Although there is no planet in the Cassini image,</span>
<span class="comments">; this technique should be used to hide star points in general, were</span>
<span class="comments">; there to be a `limb_ptd`.</span>
<span class="comments">; </span>
<span class="comments">; Determining the plot characteristics</span>
<span class="comments">; ====================================</span>
<span class="comments">;</span>
<span class="comments">; The star elements are chosen to be red, with a symbol type of * </span>
<span class="comments">; (code 2), a font size of 2, and labels corresponding to the name of</span>
<span class="comments">; each star. Stars can have either catalog names or common names.</span>
<span class="comments">;</span>
<span class="comments">; Code::</span>
<span class="comments">;</span>
<span class="comments">;  star_ptd=pg_center(bx=sd, gd=gd) & pg_hide, star_ptd, gd=gd, bx=pd, /rm</span>
<span class="comments">;  n_stars=n_elements(sd)</span>
<span class="comments">;  color = ctred()</span>
<span class="comments">;  psym = 6</span>
<span class="comments">;  csizes = 2</span>
<span class="comments">;  plabels = cor_name(sd)</span>
<span class="comments">;-</span>
<span class="comments">;-------------------------------------------------------------------------</span>
star_ptd=pg_center(bx=sd, gd=gd) & pg_hide, star_ptd, gd=gd, bx=pd, /rm
n_stars=n_elements(sd)

color = ctred()
psym = 6
csizes = 2
plabels = cor_name(sd)

<span class="comments">;-------------------------------------------------------------------------</span>
<span class="comments">;+</span>
<span class="comments">; Drawing the star centers</span>
<span class="comments">; ========================</span>
<span class="comments">;</span>
<span class="comments">; This section draws the stars in the star_ptd with the colors, plot </span>
<span class="comments">; symbols, font size, and labels defined earlier.</span>
<span class="comments">; </span>
<span class="comments">; In this particular example, the planet does not appear in the image.</span>
<span class="comments">;</span>
<span class="comments">; Code::</span>
<span class="comments">; </span>
<span class="comments">;  pg_draw, star_ptd, color=color, psym=psym, plabel=plabels, csi=csizes</span>
<span class="comments">;-</span>
<span class="comments">;-------------------------------------------------------------------------</span>
pg_draw, star_ptd, color=color, psym=psym, plabel=plabels, csi=csizes
stop, '=== Auto-test complete.  Use multi-window cut & paste to continue.'





<span class="comments">;-------------------------------------------------------------------------</span>
<span class="comments">;+</span>
<span class="comments">; Drawing the stellar spectral types</span>
<span class="comments">; ==================================</span>
<span class="comments">;</span>
<span class="comments">; This pasteable section uses the stellar library function str_sp to return</span>
<span class="comments">; spectral types of the stars and uses them instead of the star names. If</span>
<span class="comments">; the spectral type is not available for the catalog, then no information</span>
<span class="comments">; will be plotted in the labels.</span>
<span class="comments">;</span>
<span class="comments">; Code::</span>
<span class="comments">;</span>
<span class="comments">;  tvim, im</span>
<span class="comments">;  spt=str_sp(sd)</span>
<span class="comments">;  psyms_str=make_array(n_stars,val=6)</span>
<span class="comments">;  pg_draw, star_ptd, color=color, psym=psym, plabel=spt, csi=csizes</span>
<span class="comments">;-</span>
<span class="comments">;-------------------------------------------------------------------------</span>
tvim, im
spt=str_sp(sd)
psyms_str=make_array(n_stars,val=6)
pg_draw, star_ptd, color=color, psym=psym, plabel=spt, csi=csizes

<span class="comments">;-------------------------------------------------------------------------</span>
<span class="comments">;+</span>
<span class="comments">; Drawing stellar magnitudes</span>
<span class="comments">; ==========================</span>
<span class="comments">;</span>
<span class="comments">; This pasteable section uses the stellar library function str_get_mag to get</span>
<span class="comments">; visual magnitudes of the stars and uses them instead of the star names.</span>
<span class="comments">;</span>
<span class="comments">; Code::</span>
<span class="comments">;</span>
<span class="comments">;  tvim, im</span>
<span class="comments">;  sm = str_get_mag(sd)</span>
<span class="comments">;  smag = string(sm, format='(f4.1)')</span>
<span class="comments">;  psyms_str=make_array(n_stars,val=6)</span>
<span class="comments">;  pg_draw, star_ptd, color=color, psym=psym, plabel=smag, csi=csizes</span>
<span class="comments">;-</span>
<span class="comments">;-------------------------------------------------------------------------</span>
tvim, im
sm = str_get_mag(sd)
smag = string(sm, format='(f4.1)')
psyms_str=make_array(n_stars,val=6)
pg_draw, star_ptd, color=color, psym=psym, plabel=smag, csi=csizes

<span class="comments">;-------------------------------------------------------------------------</span>
<span class="comments">;+</span>
<span class="comments">; Manually repointing the geometry</span>
<span class="comments">; ================================</span>
<span class="comments">;</span>
<span class="comments">; This pasteable section first clears the screen of the plotted points</span>
<span class="comments">; by redisplaying the image with `tvim`.  It then calls `pg_drag` to allow</span>
<span class="comments">; the user to use the cursor to drag the pointing, and with it the stars.</span>
<span class="comments">; To move the pointing with `pg_drag`, use the left mouse button and</span>
<span class="comments">; translate the pointing in x,y.  Use the middle mouse button to rotate</span>
<span class="comments">; the pointing about an axis (in this case, the axis of rotation is set</span>
<span class="comments">; as the optic axis of the image (star_ptd) which is defined using the</span>
<span class="comments">; routine `pnt_create_descrptors` with the points being the camera optic</span>
<span class="comments">; axis as returned by the camera library routine cam_oaxis.  When the</span>
<span class="comments">; desired pointing is set, the right mouse button accepts it.  pg_drag</span>
<span class="comments">; returns the delta x,y amount dragged (dxy) as well as the rotation</span>
<span class="comments">; angle (dtheta).  `pg_repoint` uses the dxy and dtheta to update the</span>
<span class="comments">; camera descriptor (cd, passed by gd).  The limb, ring and star points</span>
<span class="comments">; are then recalculated, the image redisplayed to clear the objects drawn,</span>
<span class="comments">; and then `pg_draw` is called to replot.</span>
<span class="comments">;</span>
<span class="comments">; Code::</span>
<span class="comments">;</span>
<span class="comments">;  optic_ptd = pnt_create_descriptors(points=cam_oaxis(cd))</span>
<span class="comments">;  tvim, im</span>
<span class="comments">;  dxy = pg_drag(star_ptd, dtheta=dtheta, axis=optic_ptd, symbol=6)  ; square</span>
<span class="comments">;  pg_repoint, dxy, dtheta, axis=optic_ptd, gd=gd</span>
<span class="comments">;  star_ptd=pg_center(bx=sd, gd=gd) & pg_hide, star_ptd, gd=gd, bx=pd, /rm</span>
<span class="comments">;  tvim, im</span>
<span class="comments">;  pg_draw, star_ptd, color=color, psym=psym, plabel=plabels</span>
<span class="comments">;-</span>
<span class="comments">;-------------------------------------------------------------------------</span>
optic_ptd = pnt_create_descriptors(points=cam_oaxis(cd))
tvim, im
dxy = pg_drag(star_ptd, dtheta=dtheta, axis=optic_ptd, symbol=6)  <span class="comments">; square</span>
pg_repoint, dxy, dtheta, axis=optic_ptd, gd=gd

star_ptd=pg_center(bx=sd, gd=gd) & pg_hide, star_ptd, gd=gd, bx=pd, /rm

tvim, im
pg_draw, star_ptd, color=color, psym=psym, plabel=plabels

<span class="comments">;-------------------------------------------------------------------------</span>
<span class="comments">;+</span>
<span class="comments">; Scanning to find the stars and using it to calculate the pointing</span>
<span class="comments">; =================================================================</span>
<span class="comments">;</span>
<span class="comments">; This section calls `pg_ptscan` to scan the image around the predicted</span>
<span class="comments">; star positions (within width of 40 pixels) and find the pixels with </span>
<span class="comments">; the highest correlation with a given edge model (example uses the</span>
<span class="comments">; default gaussian) for each star.  These points are then plotted.</span>
<span class="comments">;</span>
<span class="comments">; Code::</span>
<span class="comments">;</span>
<span class="comments">;  ptscan_ptd = pg_ptscan(dd, star_ptd, edge=30, width=40)</span>
<span class="comments">;  pg_draw, ptscan_ptd, psym=1, col=ctyellow() </span>
<span class="comments">;-</span>
<span class="comments">;-------------------------------------------------------------------------</span>
ptscan_ptd = pg_ptscan(dd, star_ptd, edge=30, width=40)
pg_draw, ptscan_ptd, psym=1, col=ctyellow()

<span class="comments">;-------------------------------------------------------------------------</span>
<span class="comments">;+</span>
<span class="comments">; Thresholding using correlation coefficient</span>
<span class="comments">; ==========================================</span>
<span class="comments">;</span>
<span class="comments">; This section (optional) calls `pg_threshold` to remove points with lower</span>
<span class="comments">; correlation coefficients.  This example only keeps stars with a </span>
<span class="comments">; correlation coefficient above 0.6.  Notice that each object can have</span>
<span class="comments">; its own min and max value.</span>
<span class="comments">;</span>
<span class="comments">; Code::</span>
<span class="comments">;</span>
<span class="comments">;  pg_threshold, ptscan_ptd, min=make_array(n_stars,val=0.6), $</span>
<span class="comments">;                            max=make_array(n_stars,val=1.0)</span>
<span class="comments">;  tvim, im</span>
<span class="comments">;  pg_draw, object_ptd, colors=colors, psyms=psyms, psizes=psizes, plabel=plabels</span>
<span class="comments">;  pg_draw, ptscan_ptd, psym=1, col=ctyellow()</span>
<span class="comments">;-</span>
<span class="comments">;-------------------------------------------------------------------------</span>
pg_threshold, ptscan_ptd, min=make_array(n_stars,val=0.6), $
                         max=make_array(n_stars,val=1.0)

tvim, im
pg_draw, object_ptd, colors=colors, psyms=psyms, psizes=psizes, plabel=plabels
pg_draw, ptscan_ptd, psym=1, col=ctyellow()

<span class="comments">;-------------------------------------------------------------------------</span>
<span class="comments">;+</span>
<span class="comments">; Removing regions of bad points</span>
<span class="comments">; ==============================</span>
<span class="comments">;</span>
<span class="comments">; This section (optional) calls `pg_select` to remove points within a</span>
<span class="comments">; polygonal region as defined by the cursor.  Click the left mouse</span>
<span class="comments">; button to mark a point and move the mouse to the next point and</span>
<span class="comments">; click.  Use the middle mouse button to erase a point and the right</span>
<span class="comments">; mouse button to end the region.  `pg_trim` removes the points in the</span>
<span class="comments">; just defined region.  The scan points are then replotted.</span>
<span class="comments">; Repeat these statements for each region a user wants to remove.</span>
<span class="comments">;</span>
<span class="comments">; Code::</span>
<span class="comments">;</span>
<span class="comments">;  region=pg_select(dd)</span>
<span class="comments">;  pg_trim, dd, ptscan_ptd, region</span>
<span class="comments">;  tvim, im</span>
<span class="comments">;  pg_draw, object_ptd, colors=colors, psyms=psyms, psizes=psizes, plabel=plabels</span>
<span class="comments">;  pg_draw, ptscan_ptd, psym=1, col=ctyellow()</span>
<span class="comments">;-</span>
<span class="comments">;-------------------------------------------------------------------------</span>
region=pg_select(dd)
pg_trim, dd, ptscan_ptd, region

tvim, im
pg_draw, object_ptd, colors=colors, psyms=psyms, psizes=psizes, plabel=plabels
pg_draw, ptscan_ptd, psym=1, col=ctyellow()

<span class="comments">;-------------------------------------------------------------------------</span>
<span class="comments">;+</span>
<span class="comments">; Fitting the pointing to the found stars</span>
<span class="comments">; =======================================</span>
<span class="comments">;</span>
<span class="comments">; This section calls `pg_ptscan_coeff` to determine the linear </span>
<span class="comments">; least-squares coefficients for a fit to the image coordinate translation</span>
<span class="comments">; and rotation which matches the computed positions to the scanned</span>
<span class="comments">; positions. It then calls `pg_fit` to do the fit with the calculated</span>
<span class="comments">; coefficients to calculate the correction in translation (dxy) and</span>
<span class="comments">; rotation (dtheta).  It calls `pg_ptchisq` to get the chi square of the</span>
<span class="comments">; fit.  It then calls `pg_repoint` to update the pointing.  Recalculates</span>
<span class="comments">; the limb, rings and stars and replots.</span>
<span class="comments">;</span>
<span class="comments">; Code::</span>
<span class="comments">;</span>
<span class="comments">;  optic_ptd = pnt_create_descriptors(points=cam_oaxis(cd))</span>
<span class="comments">;  ptscan_cf = pg_ptscan_coeff(ptscan_ptd, axis=optic_ptd)</span>
<span class="comments">;  dxy = pg_fit([ptscan_cf], dtheta=dtheta)</span>
<span class="comments">;  chisq = pg_chisq(dxy, dtheta, ptscan_ptd, axis=optic_ptd[0])</span>
<span class="comments">;  covar = pg_covariance([ptscan_cf])</span>
<span class="comments">;  print, dxy, dtheta*180./!pi, chisq, covar</span>
<span class="comments">;  pg_repoint, dxy, dtheta, axis=optic_ptd, gd=gd</span>
<span class="comments">;  star_ptd = pg_center(bx=sd, gd=gd) & pg_hide, star_ptd, gd=gd, bx=pd, /rm</span>
<span class="comments">;  tvim, im</span>
<span class="comments">;  pg_draw, star_ptd, color=color, psym=psym, plabel=plabels</span>
<span class="comments">;-</span>
<span class="comments">;-------------------------------------------------------------------------</span>
optic_ptd = pnt_create_descriptors(points=cam_oaxis(cd))
ptscan_cf = pg_ptscan_coeff(ptscan_ptd, axis=optic_ptd)
dxy = pg_fit([ptscan_cf], dtheta=dtheta)
chisq = pg_chisq(dxy, dtheta, ptscan_ptd, axis=optic_ptd[0])
covar = pg_covariance([ptscan_cf])
print, dxy, dtheta*180./!pi, chisq, covar
pg_repoint, dxy, dtheta, axis=optic_ptd, gd=gd

star_ptd = pg_center(bx=sd, gd=gd) & pg_hide, star_ptd, gd=gd, bx=pd, /rm

tvim, im
pg_draw, star_ptd, color=color, psym=psym, plabel=plabels



<span class="comments">;-------------------------------------------------------------------------</span>
<span class="comments">;+</span>
<span class="comments">; Output the new state</span>
<span class="comments">; ====================</span>
<span class="comments">;</span>
<span class="comments">; This section (optional) shows how you can save your output: any changes</span>
<span class="comments">; to the image data into a new file and the new pointing into a detached</span>
<span class="comments">; header.</span>
<span class="comments">;</span>
<span class="comments">; Code::</span>
<span class="comments">;</span>
<span class="comments">;  pg_put_cameras, dd, gd=gd</span>
<span class="comments">;  dat_write, getenv('OMINAS_DIR')+'/demo/data/c1138223_nv.gem', dd</span>
<span class="comments">;  </span>
<span class="comments">;-</span>
<span class="comments">;-------------------------------------------------------------------------</span>
pg_put_cameras, dd, gd=gd
<span class="comments">;dat_write, getenv('OMINAS_DIR')+'/demo/data/c1138223_nv.gem', dd</span>
end
</code>
    </div>
  </body>
</html>