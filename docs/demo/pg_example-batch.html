<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.6.1 on Wed Aug 29 11:21:16 2018 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>pg_example-batch.pro (OMINAS Documentation)</title>

    

    <script type="text/javascript" src="idldoc-resources/js/jquery.js"></script>
    <script type="text/javascript" src="idldoc-resources/js/copybutton.js"></script>

    
    <style type="text/css" media="all">
            /* setup page */
      body { font-family: Helvetica, sans-serif; font-size: 12pt; margin: 0; padding: 0; }
      div.content { padding: 1em; }
      p { line-height: 1.4; }
      td p { padding-bottom: 0.5em; }
      img { border: 0; }
      
      /* link styles */
      a { text-decoration: none; }
      a:link, a:visited { color: #0000FF; }
      a:hover, a:focus { background: yellow; border-bottom: 1emx dotted #303099; }
      
      /* dir-overview styles */
      dt.filename { margin-top: 0.5em; }
      dl.file_listing { margin-left: 1em; }
      
      /* titles */
      h1, h2, h3, h4 { font-weight:normal; color: #871E31; margin-top: 1.5em; }
      h4 { margin-bottom: 0.25em; }
      .center { margin-left: auto; margin-right: auto; }
      .small { font-family: Verdana, Helvetica, sans-serif; font-size: 90%; }
      .smaller { font-family: Verdana, Helvetica, sans-serif; font-size: 80%; }
      .smallest { font-family: Verdana, Helvetica, sans-serif; font-size: 70%; }
      h1.basename { margin-top: 0; margin-bottom: 0; }
      h1.basename span.file-attributes { font-size: 70%; margin-left: 3em; color: #384806; }
      h2.directory { font-size: 90%; margin-bottom: 0; }
      h2.routine-name { margin-top: 0; margin-bottom: 0; }
      p.categories { color: #384806; margin-top: 0; }
      span.file_attribute { float: right; color: #384806; margin: 0 0 1em 3em; }
      div#file_comments { margin-top: 1em; }
      
      div.routine-details { border: 1px dotted #C0C0C0; margin-top: 1em; padding: 1em; }
      span.routine-attributes { font-size: 70%; margin-left: 3em; color: #384806; }
      div.details dt { color: #871E31; margin-left: 2em; }
      div.details dt span { color: #384806; margin-left: 2em; }
      div.details dd { margin: 0.5em 2em 1em 4em; }
      a.top {
        font-family: Verdana, Helvetica, sans-serif;
        font-size: 8pt;
        font-weight: bold;
        color: #5070ff;
        text-transform: uppercase;
        float: right;
        margin-left: 1em;
      }
      
      /* comments */
      .pre { white-space: pre; }
      
      /* code styles */
      code { font-family: Monaco, "Courier New", Courier, monospace; font-size: 95%; }
      code.listing { white-space: pre; display: block; margin: 0.75em 0 0.75em 0; padding: 0 3em 0 1em; line-height: 1.4em; }
      code.source { white-space: pre; display: block; }
      code.source span.comments { color: #408080; }
      .syntax { margin-top: 1em; margin-left: 1.5em; text-indent: -1.5em; }
      .var { font-style: italic; }
      .argument { } /* white-space: nowrap; does not work in Safari (and sometimes not even in Firefox) */
      
      dl.routine-summary dt { margin-bottom: 0.25em; }
      dl.routine-summary dd { margin-bottom: 0.5em; margin-left: 2em; }
      
      ul.inherited-method-summary { padding-left: 0em; margin-left: 0em; }
      
      /* general styles */
      ul li { list-style-type: none; }
      table { empty-cells: show; }
      thead { color: #871E31; }
      dd { margin-bottom: 0.35em; }
      input, textarea { background: #F3F6ED; border: #E1D6C6 1px solid; padding: 2px 1em 2px 0.5em; }
      input.text { background: #FFFFC0; }
      
      div.note { margin: 1em 2em 1em 2em; background: #EFEFEF; border: 1px #A0A0A0 dotted; padding: 0 1em 0 1em; }
      p.indent { margin-left: 2em; }
      
      /* An attribute table is a vertical list of name-value pairs. */
      table.box {
        background: #EFEFEF;
        border: 1px #A0A0A0 dotted;
        padding-top: 0.75em;
        padding-bottom: 0.75em;
      }
      table.attribute { padding-left: 0.75em; padding-right: 0.75em; }
      table td { vertical-align: top; }
      table.attribute p { margin: 0; }
      table td.name { font-style: normal; padding-right: 1.5em; }
      ul.fieldslist { padding-top: 0; color: #909090; }
      ul.fieldslist li { margin-bottom: 0.25em; }
      span.fieldname { color: #000000; }
      
      dl.attribute dt { color: #990000; }
      
      /* header/navbar styles */
      div.header { padding: 2em 2em 0 2em; background: #9E9D7B; border-bottom: 2px #262626 solid; }
      div.header h1 { color: white; margin:0; font-weight: normal; }
      div.header h2 { color: white; margin-top: 0; margin-bottom: 1em; font-weight: normal; font-style: italic; font-size: 100%; }
      table.navbar { background: #CCC097; margin: 0; padding: 0; border-bottom: 1px #262626 dotted; width: 100%; }
      table.navbar td { padding: 4px 0.5em 3px 0.5em; white-space: nowrap; vertical-align: top; }
      table.navbar td.flexible { width: 100%; text-align: right; padding-right: 1em; white-space: nowrap; }
      table.navbar td.selected { background: #262626; }
      table.navbar td.selected, table.navbar td.selected a { color: white; }
      table.navbar a:hover, table.navbar a:focus { background: inherit; border-bottom: 1px solid #303099; }
      p.localnavbar { text-align: right; margin: 0.2em 1em 0.2em 0.2em; padding: 0; }
      
      /* CSS graphics styles */
      div.box {
        margin-left: 0.25em;
        display: inline-block;
        width: 0.9em;
        height: 0.9em;
        vertical-align: -1px;
      }
      .red { background-color: #A00; }
      .orange { background-color: #F40; }
      .green { background-color: #480; }
      
      /* index styles */
      span.index_type { margin-left: 1em; }
      dl.index_listing dd { margin-bottom: 0.5em; margin-left: 2em; }
      dl.index_listing dd p { margin-top: 0.2em; margin-bottom: 0em; }
      
      /* search styles */
      fieldset { border: #ddd 1px solid; padding: 1em; margin-top: 3em; }
      legend { color: #871E31; font-size: 120%; }
      label { white-space: nowrap; }
      p.description { margin: 2em 2em 1em 2em; }
      form table td.name { vertical-align: middle; }
      
      /* footer styles */
      div.footer { padding: 0.5em 1em 0.5em 1em; background: #EFEFEF; border-top: 1px #A0A0A0 dotted; }
      div.footer table { width: 100%; }
      div.footer td.right { text-align: right; }

    </style>
    <style type="text/css" media="print">
            p.localnavbar { display: none; }
      
      div.header { background: white; }
      div.header h1 { color: black; }
      div.header h2 { color: black; }

    </style>
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="pg_example-batch.pro (OMINAS Documentation)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">


    <div class="content">
      
      <h1 class="basename">pg_example-batch.pro<span class="file-attributes"></span></h1>
      

      <span class="file_attribute small">batch file</span>
      
      
      <br/>

      
      <div id="file_comments">
        <div class="small "><p>                              PG EXAMPLE
</p>

<p>  Created by Joe Spitale
  Edited by Mark Moretto for manual
</p>

<p>   This example demonstrates various capabilities of the PG programming
   interface, OMINAS' command-line API.
</p>

<p>   This example file can be executed from the shell prompt in the ominas/demo
   directory using:
<div><div><code class="listing"><code class="source"> ominas pg_example-batch</code>

<code class="source">or from within an OMINAS IDL session using:</code>
</code></div></div><div><div><code class="listing"><code class="source">@pg_example-batch</code>
</code></div></div>    After the example stops, later code samples in this file may be executed by
    pasting them onto the IDL command line.
</p>

<p> READ AND DISPLAY IMAGE
</p>

<p> <img src="graphics/jupiter_load.jpeg"/>
</p>

<p>   Use DAT_READ to read the image and then display the image using TVIM.
   With DAT_READ, it is not necessary to specify the file format.  DAT_READ
   uses your file type detectors to determine the format, and gets the
   appropriate reader from your I/O table.  DAT_READ returns a data
   descriptor (dd), which contains all of the data associated with the file.
   For convenience, it also returns the data array (im) and header (label)
   in its second and third arguments.
</p>

<p>   TVIM is called to display the image (im) in a new window with the y
   coordinate as top-down:
<div><div><code class="listing"><code class="source"> dd = dat_read('./demo/data/N1350122987_2.IMG', im, label)</code>
<code class="source"> tvim, im, zoom=0.75, /order, /new</code>
</code></div></div></p>

<p> OBTAIN GEOMETRY
</p>

<p>   This section obtains the geometric information describing the scene.
   Note that there is no reference to the source of the this information.
   That is handled by the translator system, which is controlled by
   a series of translators tables telling OMINAS which translators to use
   for a given instrument.  The translators tables are parsed by DAT_READ,
   which stores the list of translators in the data descriptor.
</p>

<p>   If you are using the default demo configuration, then the geometry
   data are obtained via the NAIF/SPICE translator package and the detached
   header package.  The NAIF/SPICE translators use database files
   provided by NAIF or by individual projects.  The detached header
   translators read and write geometry descriptors in a text-based file
   that resides in the same directory as the data file and has the
   extension '.dh'.  Because the detached header translator dh_std_input
   appears before the Cassini Spice input translator in the default
   translators table, the descriptors are taken from the detached header
   if it exists, and if the relevant descriptors are present.  Otherwise,
   they are obtained from the SPICE kernels:
<div><div><code class="listing"><code class="source"> cd = pg_get_cameras(dd)                        ; CAMERA descriptor</code>
<code class="source"> pd = pg_get_planets(dd, od=cd, count=npd)      ; PLANET descriptor(s)</code>
<code class="source"> rd = pg_get_rings(dd, pd=pd, od=cd, count=nrd) ; RING descriptor(s)</code>
<code class="source"> ltd = pg_get_stars(dd, od=cd, name='SUN')     ; STAR descriptor for Sun</code>
</code></div></div>   The calls to PG_GET_PLANETS, PG_GET_RINGS, and PG_GET_STARS include
   an observer descriptor, od.  Without this, it would not be possible
   to perform aberration corrections on the returned objects.  In that
   case, the returned descriptors would represent the real states of the
   bodies at the time of observation at their respective positions rather
   than from the point of view of the observer:
<div><div><code class="listing"></code></div></div>   Note the 'name' keyword in the call to PG_GET_STARS. This is a CORE
   attribute, so it may be applied to any body.  For example, if you are
   only interested in Jupiter and the Galilean satellites, you could
   write:
<div><div><code class="listing"><code class="source"> pd = pg_get_planets(dd, od=cd, $</code>
<code class="source">          name=['JUPITER', 'IO', 'EUROPA', 'GANYMEDE', 'CALLISTO'])</code>
</code></div></div>   Instead, we just search the returned descriptors for the on named
   'JUPITER':
<div><div><code class="listing"><code class="source"> ii = where(cor_name(pd) EQ 'JUPITER')</code>
</code></div></div></p>

<p> INSTRUMENT-SPECIFIC USAGE
</p>

<p>   It is possible to communicate directly with the translators from the
   PG API via the use of translator keywords.  Translator keywords are
   keyword=value strings that are passed directly to the translator system
   with no interpretation by OMINAS.  They may be permanently coded in
   the translators table to be passed to a specific translator, or
   transient inputs may be provided to the PG_GET_* programs as a string
   argument.  In the latter case, they are accessible to all translators
   pertaining to that PG_GET_* program and they precede translator keywords
   from the translators table.
</p>

<p>   Here are some examples of controlling the NAIF/SPICE interface in a
   call to PG_GET_CAMERAS:
<div><div><code class="listing"><code class="source"> cd = pg_get_cameras(dd, 'klist=my_klist.txt')     ; Use personal kernel</code>
<code class="source">                                                   ; list file.</code>

<code class="source"> cd = pg_get_cameras(dd, 'ck_in=./test.bc')        ; Use a specified C kernel.</code>

<code class="source"> cd = pg_get_cameras(dd, 'ck_in=./auto')           ; Use the C-kernel auto-</code>
<code class="source">                                                   ; detect function.</code>

<code class="source"> cd = pg_get_cameras(dd, 'klist=my_klist.txt, $    ; Multiple arguments</code>
<code class="source">                          ck_in=test.bc;test1.bc') ; separated by commas;</code>
<code class="source">                                                   ; multiple elements</code>
<code class="source">                                                   ; separated by semicolons.</code>
</code></div></div></p>

<p> MAKE A GENERIC DESCRIPTOR
</p>

<p>   Here we go with the generic descriptors again.  The story with these
   things is that long ago before GRIM was summoned from the lowest levels
   of heck, OMINAS (or MINAS, or NV) was purely command-based.  That's
   what you want because you can always build a GUI on top of it, but
   it doesn't really work to start with a graphical tool and try to
   build a command-based system out of that.  Therefore, I decided to have
   mercy on the poor jerks (mostly me up to now) who had to type (really
   paste) all of this nonsense in.  The generic descriptor was therefore
   spawned as a way to cut down on all the cd=this, pd=that, bx=whatever
   that tends to go on.  So we just shove it all into one structure and
   all of the PG programs know to look in there if one is given.  Any
   explicit descriptor arguments take precedence, though.  So if these
   things make you happy, then you're welcome.  I rarely use them in this
   way.  They live on because it turns out they have amazing utility in
   other ways.  So anyway, it's like this:
<div><div><code class="listing"><code class="source"> gd = {cd:cd, gbx:pd, dkx:rd, ltd:ltd}</code>
</code></div></div></p>

<p> COMPUTE OVERLAY ARRAYS
</p>

<p>   These commands compute the center, limb, and terminator of each planet,
   as well as the edges of the rings.  Note that the terminator is computed
   using PG_LIMB with the Sun as the observer:
<div><div><code class="listing"><code class="source"> limb_ptd = pg_limb(gd=gd) & pg_hide, limb_ptd, gd=gd, bx=rd, /rm</code>
<code class="source">           pg_hide, limb_ptd, /assoc, gd=gd, bx=pd, od=ltd</code>
<code class="source"> ring_ptd = pg_disk(gd=gd) & pg_hide, ring_ptd, gd=gd, bx=pd</code>
<code class="source"> term_ptd = pg_limb(gd=gd, od=gd.ltd) & pg_hide, term_ptd, gd=gd, bx=pd, /assoc</code>
<code class="source"> center_ptd = pg_center(gd=gd, bx=pd)</code>
</code></div></div></p>

<p> SET UP FOR PLOTTING
</p>

<p>  This just makes the calls to PG_DRAW a little easier, since they will
  need to be repeated every time we change things and recompute.  We put
  all of the POINT descriptors in one array and then make corresponding
  arrays for the plot parameters:
<div><div><code class="listing"><code class="source"> object_ptd = [center_ptd,limb_ptd,ring_ptd,term_ptd]</code>
<code class="source"> colors=[make_array(npd,value=!p.color), $</code>
<code class="source">         make_array(npd,value=ctyellow()), $</code>
<code class="source">         make_array(2*nrd,value=ctred()), $</code>
<code class="source">         make_array(npd,value=ctgreen())]</code>
<code class="source"> psyms=[make_array(npd,value=1), $</code>
<code class="source">        make_array(npd,value=3), $</code>
<code class="source">        make_array(2*nrd,value=3), $</code>
<code class="source">        make_array(npd,value=3)]</code>
<code class="source"> psizes=1.0</code>
<code class="source"> csizes=0.75</code>
<code class="source"> plabels=[cor_name(pd), $</code>
<code class="source">         make_array(npd,value=''), $</code>
<code class="source">         make_array(2*nrd,value=''), $</code>
<code class="source">         make_array(npd,value='')]</code>
</code></div></div></p>

<p> DRAW EVERYTHING
</p>

<p> <img src="graphics/jupiter_limb_initial.jpeg"/>
</p>

<p> Now we can do a nice simple call to PG_DRAW to draw everything:
<div><div><code class="listing"><code class="source">   pg_draw, object_ptd, $</code>
<code class="source">             col=colors, psy=psyms, psi=psizes, csi=csizes, pl=plabels</code>
</code></div></div></p>

<p> FIRST-CUT AUTOMATIC REPOINTING
</p>

<p>   Refine the pointing of the spacecraft by using PG_FARFIT, which searches
   the image for a pattern matching the edges calculated using the
   geometry descriptors.  First scan the images for edges, ignoring the
   a 10-pixel zone at the edge of the image:
<div><div><code class="listing"><code class="source"> edge_ptd = pg_edges(dd, edge=10)</code>
<code class="source"> pg_draw, edge_ptd</code>

</code></div></div>   <img src="graphics/jupiter_ex_edge.jpeg"/>
</p>

<p>   Next, use PG_FARFIT to find the x/y offset that best matches the limb of
   Jupiter (planet index ii):
<div><div><code class="listing"><code class="source"> dxy = pg_farfit(dd, edge_ptd, [limb_ptd[ii]])</code>
</code></div></div>   BTW, you have been duped.  PG_FARFIT fails a lot because the search
   is pretty sparse.  I cherry-picked an image that usually works pretty
   well.  The sparse search makes PG_FARFIT pretty fast, though.  Ok,
   now repoint using the farfit solution:
<div><div><code class="listing"><code class="source"> pg_repoint, dxy, gd=gd</code>
</code></div></div>   Now that the camera pointing has changed, everything has to be recomputed,
   just like before:
<div><div><code class="listing">
<code class="source">limb_ptd = pg_limb(gd=gd) & pg_hide, limb_ptd, gd=gd, bx=rd, /rm</code>
<code class="source">       pg_hide, limb_ptd, /assoc, gd=gd, bx=pd, od=ltd</code>
<code class="source">ring_ptd = pg_disk(gd=gd) & pg_hide, ring_ptd, gd=gd, bx=pd</code>
<code class="source">center_ptd = pg_center(gd=gd, bx=pd)</code>
<code class="source">term_ptd = pg_limb(gd=gd, od=gd.ltd) & pg_hide, term_ptd, gd=gd, bx=pd, /assoc</code>
<code class="source">object_ptd = [center_ptd,limb_ptd,ring_ptd,term_ptd]</code>
</code></div></div>   And now we can see the result:
</p>

<p>    tvim, im
    pg_draw, object_ptd, $
                colors=colors, psyms=psyms, psizes=psizes, plabel=plabels
</p>

<p>   <img src="graphics/jupiter_ex_farfit.jpeg"/>
</p>

<p></p>

<p> MANUALLY REPOINT THE GEOMETRY
</p>

<p>   If you have a little time, you can just drag the pointing around
   by hand.  We just need to get it close enough to really nail down in
   the next section.  There's a good chance PG_FARFIT really dropped
   the ball on the last step anyway.  Just paste this in and follow
   the directions:
<div><div><code class="listing"><code class="source">tvim, im</code>
<code class="source">dxy = pg_drag(object_ptd, dtheta=dtheta, axis=center_ptd[ii])</code>
</code></div></div>   Like PG_FARFIT, PG_DRAG returns an x/y offset that can be input to
   PG_REPOINT, but it also returns a twist offset, so we need to input
   that and an axis to PG_REPOINT:
<div><div><code class="listing"><code class="source">pg_repoint, dxy, dtheta, axis=center_ptd[ii], gd=gd</code>
</code></div></div>   And now you have to recompute and redraw again.  It's the same as
   above.  Please don't make me write it out.
</p>

<p> PRECISE EDGE SCAN
</p>

<p>   Not satisfied with PG_FARFIT?  I wouldn't be, it's just not a sub-pixel
   kind of thing.  Sometimes its results can be very super-pixel.  However,
   once we get within a few tens of pixels of the correct pointing, we can
   use PG_CVSCAN to pick up the edges with a more rigorous algorithm.
   PG_CVSCAN scans around a predicted edge (in this case Jupiter's limb)
   comparing the brightness profile with a model profile.  In this case,
   we use the limb edge model developed by Gary Yagi and used in the old
   VICAR NAV program (Ugh, remember VICAR?  That's kind of the whole reason
   we're doing any of this).  Indeed this whole CVSCAN business is the same
   exact algorithm that Andy Ingersoll scribbled down on a piece of paper
   sometime in the 1980s, just gussied up and vectorized with a bunch of
   pg_this and gd_that and all manner of other whatnot.
</p>

<p>   Anyway, here we are staying 30 pixels from the image edge, and scanning
   with a width of 80 pixels.  lzero and mzero are coordinating the
   zero pointing of the model:
<div><div><code class="listing"><code class="source">cvscan_ptd=pg_cvscan(dd, gd=gd, limb_ptd[ii], edge=30, width=80, $</code>
<code class="source">   model=[make_array(npd,val=ptr_new(edge_model_nav_limb(zero=lzero)))], $</code>
<code class="source">   mzero=[make_array(npd,val=lzero)] )</code>
</code></div></div>   And then we draw the points:
<div><div><code class="listing"><code class="source">tvim, im</code>
<code class="source">pg_draw, cvscan_ptd</code>

</code></div></div>   <img src="graphics/jupiter_ex_cvscan.jpeg"/>
</p>

<p></p>

<p> THRESHOLD ON CORRELATION COEFFICIENT
</p>

<p>   This section calls pg_threshold to remove points with unacceptable
   correlation coefficients.  The /relative flag means that the minimum
   and maximum thresholds are taken as a fraction of the maximum
   correlation coefficient for each set of points. In this case we use
   a minimum correlation coefficient of 0.81 and a maximum of 1.0:
<div><div><code class="listing"><code class="source"> pg_threshold, cvscan_ptd, min=0.81, max=1.0, /rel</code>
<code class="source"> tvim, im</code>
<code class="source"> pg_draw, cvscan_ptd</code>
</code></div></div></p>

<p> MANUALLY EDIT THE SCANNED POINTS
</p>

<p>   PG_SELECT is used to manually remove points within a polygonal region
   defined by the cursor.  PG_TRIM removes the points in the defined
   region:
<div><div><code class="listing"><code class="source"> region = pg_select(dd)</code>
<code class="source"> pg_trim, dd, cvscan_ptd, region</code>
<code class="source"> tvim, im</code>
<code class="source"> pg_draw, cvscan_ptd</code>
</code></div></div></p>

<p> SUB-PIXEL POINTING CORRECTION
</p>

<p>   PG_CVSCAN_COEFF determines the linear least-squares coefficients for a
   fit to the image coordinate translation and rotation that matches the
   computed curve to the scanned curve.  PG_FIT uses the resulting
   coefficients to calculate the corrections.  In this case, we fix
   the rotation offset (fix=2) because the limb gives little leverage on
   that parameter:
<div><div><code class="listing"><code class="source">cvscan_cf = pg_cvscan_coeff(cvscan_ptd, fix=2)</code>
<code class="source">dxy = pg_fit(cvscan_cf)</code>
</code></div></div>   The reason that these two programs are separate is that a simultaneous
   fit can be performed by simply adding all of the linear coefficients.
   If PG_FIT is given an array of coefficient structures, it will add them
   before performing the fit, so, for example, you could compute coefficients
   to fit stars in the image (using PG_PTSCAN), and include them in the
   call to PG_FIT to get a simultaneous fit to the stars and the limb.
</p>

<p>   Once again, you need to recompute and redraw to see the new pointing:
<div><div><code class="listing"></code></div></div>   <img src="graphics/jupiter_ex_cvscan_repoint.jpeg"/>
</p>

<p></p>

<p> FIT STATISTICS
</p>

<p>   You can get the statistics using PG_CHISQ and PG_COVARIANCE:
<div><div><code class="listing"><code class="source">chisq = pg_chisq(dxy, 0, cvscan_ptd, fix=2)</code>
<code class="source">covar = pg_covariance(cvscan_cf)</code>
<code class="source">print, dxy, dtheta*180./!pi, chisq, covar</code>
</code></div></div></p>

<p> PLANET AND RING LATITUDE/LONGITUDE GRID
</p>

<p> <img src="graphics/jupiter_lat_lon.jpeg"/>
</p>

<p>   This section calculates a latitude/longitude grid for each planet and a
   radius/longitude grid for the rings.  By default it draws 12 latitude
   and 12 longitude grid lines.  The longitude grid lines circle the body
   and so on a map they will appear as 24 grid lines.  The ring radius grid
   uses four grid lines by default between the inner and outer ring radius.
   It uses PG_HIDE to set as not visible the points on the grid behind the
   planet and ring for both objects.  It then uses PG_DRAW to draw the
   grid points in blue (ctblue):
<div><div><code class="listing"><code class="source"> grid_ptd = pg_grid(gd=gd, lat=lat, lon=lon)</code>
<code class="source"> pg_hide, grid_ptd, cd=cd, bx=pd, /assoc</code>
<code class="source"> pg_hide, grid_ptd, cd=cd, bx=pd, od=ltd, /assoc</code>
<code class="source"> pg_hide, grid_ptd, gd=gd, bx=rd</code>
<code class="source"> pg_draw, grid_ptd, color=ctblue()</code>

<code class="source"> plat_ptd = pg_grid(gd=gd, slon=!dpi/2d, lat=lat, nlon=0)</code>
<code class="source"> pg_hide, plat_ptd[ii], cd=cd, bx=pd[ii], /, bx=pd</code>
<code class="source"> pg_draw, plat_ptd[ii], psym=3, plabel=strtrim(round(lat*180d/!dpi),2), /label_p</code>

<code class="source"> plon_ptd = pg_grid(gd=gd, slat=0d, lon=lon, nlat=0)</code>
<code class="source"> pg_hide, plon_ptd[ii], cd=cd, bx=pd[ii], /assoc</code>
<code class="source"> pg_draw, plon_ptd[ii], psym=3, plabel=strtrim(round(lon*180d/!dpi),2), /label_p</code>

<code class="source"> dgrid_ptd=pg_grid(gd=gd, bx=rd) & pg_hide, dgrid_ptd, gd=gd, bx=pd</code>
<code class="source"> pg_draw, dgrid_ptd, color=ctpurple()</code>
</code></div></div></p>

<p> MAP DESCRIPTORS
</p>

<p>   PG_GET_MAPS is used to define map descriptors for various projections.
   Paste the one you want:
<div><div><code class="listing">
<code class="source">Rectangular:</code>
</code></div></div><div><div><code class="listing"><code class="source"> md = pg_get_maps(/over, bx=pd[ii], $</code>
<code class="source">        projection='RECTANGULAR', $</code>
<code class="source">        /map_graphic,</code>
<code class="source">        size=[400,200])</code>

</code></div></div>    <img src="graphics/jupiter_rectangular.jpeg"/>
</p>

<p>    Orthographic:
<div><div><code class="listing"><code class="source">  md = pg_get_maps(/over, bx=pd[ii], $</code>
<code class="source">        projection='ORTHOGRAPHIC', $</code>
<code class="source">        size=[400,400], $</code>
<code class="source">        center=[!dpi/6d,!dpi])</code>

</code></div></div>    <img src="graphics/jupiter_orthographic.jpeg"/>
</p>

<p>    Stereographic:
<div><div><code class="listing"><code class="source">  md = pg_get_maps(/over, bx=pd[ii], $</code>
<code class="source">         projection='STEREOGRAPHIC', $</code>
<code class="source">         scale=0.5, $</code>
<code class="source">         size=[400,400], center=[!dpi/2d,0d])</code>

</code></div></div>    <img src="graphics/jupiter_stereographic.jpeg"/>
</p>

<p>    Mercator:
<div><div><code class="listing"><code class="source">  md = pg_get_maps(/over, bx=pd[ii], $</code>
<code class="source">        projection='MERCATOR', $</code>
<code class="source">         size=[400,200])</code>

</code></div></div>    <img src="graphics/jupiter_mercator.jpeg"/>
</p>

<p></p>

<p> MAP PROJECTIONS
</p>

<p>   PG_MAP creates a map projection and returns it in a data descriptor.
   The map is also returned a a keyword for convenience:
<div><div><code class="listing"><code class="source"> dd_map = pg_map(dd, md=md, gd=gd, bx=pd[ii], map=map)</code>
<code class="source"> tvim, /new, map</code>


</code></div></div>   You could bound the map like this:
<div><div><code class="listing"><code class="source"> dd_map = pg_map(dd, md=md, gd=gd, bx=pd[ii], map=map, $</code>
<code class="source">                  bounds=bounds = [-30,30,-180,180]*!dpi/180d)</code>

</code></div></div>   Or exclude the areas covered by the rings:
<div><div><code class="listing"><code class="source"> dd_map = pg_map(dd, md=md, gd=gd, bx=pd[ii], gbx=pd[ii], $</code>
<code class="source">                    hide_fn='pm_hide_ring', hide_bx=rd, map=map)</code>
</code></div></div></p>

<p> PUT A GRID ON IT
</p>

<p>   PG_GRID computes a latitude/longitude grid.  This is the same program
   used in other examples to draw grids on other things; here we're
   using a map descriptor instead of a camera descriptor.
</p>

<p>   First, define a new generic descriptor.  :
<div><div><code class="listing"><code class="source"> gdm={cd:md, od:cd, gbx:pd[ii], dkx:rd}</code>

<code class="source"> map_grid_ptd = pg_grid(gd=gdm, lat=lat, lon=lon)</code>
<code class="source"> plat_ptd = pg_grid(gd=gdm, slon=!dpi/2d, lat=lat, nlon=0)</code>
<code class="source"> plon_ptd = pg_grid(gd=gdm, slat=0d, lon=lon, nlat=0)</code>

<code class="source"> pg_draw, map_grid_ptd, col=ctgreen()</code>
<code class="source"> pg_draw, plat_ptd, psym=7, plabel=strmid(strtrim(lat*180d/!dpi,2),0,3), /label_p</code>
<code class="source"> pg_draw, plon_ptd, psym=7, plabel=strmid(strtrim(lon*180d/!dpi,2),0,3), /label_p</code>
</code></div></div></p>

<p> OBSERVATION-SPECIFIC OVERLAYS
</p>

<p>   Use PG_LIMB to compute a limb and a terminator by specifying an
   observer descriptor:
<div><div><code class="listing"><code class="source">map_limb_ptd = pg_limb(gd=gdm, od=cd)</code>
<code class="source">map_term_ptd = pg_limb(gd=gdm, od=ltd)</code>

<code class="source">pg_draw, map_limb_ptd, col=ctred()</code>
<code class="source">pg_draw, map_term_ptd, col=ctyellow()</code>
</code></div></div></p>

<p> MAP-TO-MAP PROJECTION
</p>

<p>   A map can be reprojected using a second map descriptor with the
   original map descriptor in place of the camera descriptor:
<div><div><code class="listing"><code class="source"> md1 = pg_get_maps(/over, bx=pd[ii], $</code>
<code class="source">    projection='ORTHOGRAPHIC', $</code>
<code class="source">    size=[400,400], $</code>
<code class="source">    center=[!dpi/6d,!dpi])</code>

<code class="source"> dd_map1 = pg_map(dd_map, md=md1, cd=md, map=map1)</code>
<code class="source"> tvim, /new, map1</code>

</code></div></div> <img src="graphics/jupiter_rectangular_to_ortho.jpeg"/>
</p>

<p></p>

<p> OUTPUT DESCRIPTORS
</p>

<p>   These commands write the descriptor information out through the
   translators.  The exact behavior is translator-dependent.  In the default
   configuration, the detached header translator modifies the detached header
   stored in the data descriptor.  It is not written until DAT_WRITE is called:
<div><div><code class="listing"><code class="source"> pg_put_rings, dd, od=cd, rd=rd</code>
<code class="source"> pg_put_planets, dd, od=cd, pd=pd[0]</code>
<code class="source"> pg_put_cameras, dd, cd=cd</code>
<code class="source"> pg_put_stars, dd, sd=ltd, od=cd</code>

</code></div></div>   The detached head may be viewed using:
<div><div><code class="listing"><code class="source"> print, transpose(dat_dh(dd))</code>
</code></div></div>   If using the NAIF/SPICE translator, a C kernel may be written by
   specifying a file name using the ck_out translator keyword.  A comment
   can be included in the output kernel by making a user data value
   named "CK_COMMENT":
<div><div><code class="listing"><code class="source"> cor_set_udata, cd, 'CK_COMMENT', 'This is a comment.'</code>
<code class="source"> pg_put_cameras, dd, cd=cd, 'ck_out=./outputs/test.bc'</code>
</code></div></div></p>

<p> WRITE DATA FILE
</p>

<p>   DAT_WRITE writes the data array in the data descriptor using whatever
   output function was given in the I/O table.  The detached header is
   is also written into a file with the same name as the image file except
   with the extension '.dh'.  If this file does not already exist, it is
   created:
<div><div><code class="listing"><code class="source"> dat_write, './outputs/' + cor_name(dd), dd</code>
</code></div></div></p>

<p> WRITE MAP FILE
</p>

<p>   PG_PUT_MAPS causes the detached header translator to generate a new
   detached header and write the map descriptor into it.
</p>

<p>   As above, DAT_WRITE writes the map image file and the detached header.
   Notice that the file type is given explicitly because the data descriptor
   was not created by DAT_READ, which would have detected the file type:
<div><div><code class="listing"><code class="source"> pg_put_maps, dd_map, md=md</code>
<code class="source"> dat_write, './outputs/' + cor_name(dd) + '.map', dd_map, filetype = 'VICAR'</code>
</code></div></div>   To read the new map file, use DAT_READ just as the image file was read at
   the beginning of this example script.  To read the map descriptor from the
   detached header, use PG_GET_MAPS:
<div><div><code class="listing"><code class="source"> dd_map = dat_read(./outputs/&lt;nme&gt;.map', map)</code>
<code class="source"> md = pg_get_maps(dd_map)</code>
<code class="source"> tvim, /new, map</code>
</code></div></div></p>

</div>
      </div>
      

      

      

      

      

      

      

      

      

      

      <div id="attributes">
        <h2>File attributes</h2>

        <table class="attribute small" summary="File attributes">
          <tr>
            <td class="name">Modification date:</td>
            <td>Wed Aug 29 11:18:55 2018</td>
          </tr>

          <tr>
            <td class="name">Lines:</td>
            <td>135</td>
          </tr>

          
          <tr>
            <td class="name">Docformat:</td>
            <td>rst rst</td>
          </tr>
          
        </table>
      </div>

      
    </div>

    <div class="footer">
    
      <table class="smaller" summary="footer">
        <tr>
          <td class="left">Produced by IDLdoc 3.6.1 on Wed Aug 29 11:21:16 2018</td>
          <td class="right"><a target="_top" href="http://github.com/mgalloy/idldoc">IDLdoc project information</a></td>
        </tr>
      </table>
    
    </div>
  </body>
</html>