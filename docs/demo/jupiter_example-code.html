<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- Generated by IDLdoc 3.6.1 on Fri Jun 23 14:05:46 2017 -->

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>jupiter_example.pro (OMINAS API Documentation)</title>

    
    <style type="text/css" media="all">
            /* setup page */
      body { font-family: Helvetica, sans-serif; font-size: 12pt; margin: 0; padding: 0; }
      div.content { padding: 1em; }
      p { line-height: 1.4; }
      td p { padding-bottom: 0.5em; }
      img { border: 0; }
      
      /* link styles */
      a { text-decoration: none; }
      a:link, a:visited { color: #0000FF; }
      a:hover, a:focus { background: yellow; border-bottom: 1emx dotted #303099; }
      
      /* dir-overview styles */
      dt.filename { margin-top: 0.5em; }
      dl.file_listing { margin-left: 1em; }
      
      /* titles */
      h1, h2, h3, h4 { font-weight:normal; color: #871E31; margin-top: 1.5em; }
      h4 { margin-bottom: 0.25em; }
      .center { margin-left: auto; margin-right: auto; }
      .small { font-family: Verdana, Helvetica, sans-serif; font-size: 90%; }
      .smaller { font-family: Verdana, Helvetica, sans-serif; font-size: 80%; }
      .smallest { font-family: Verdana, Helvetica, sans-serif; font-size: 70%; }
      h1.basename { margin-top: 0; margin-bottom: 0; }
      h1.basename span.file-attributes { font-size: 70%; margin-left: 3em; color: #384806; }
      h2.directory { font-size: 90%; margin-bottom: 0; }
      h2.routine-name { margin-top: 0; margin-bottom: 0; }
      p.categories { color: #384806; margin-top: 0; }
      span.file_attribute { float: right; color: #384806; margin: 0 0 1em 3em; }
      div#file_comments { margin-top: 1em; }
      
      div.routine-details { border: 1px dotted #C0C0C0; margin-top: 1em; padding: 1em; }
      span.routine-attributes { font-size: 70%; margin-left: 3em; color: #384806; }
      div.details dt { color: #871E31; margin-left: 2em; }
      div.details dt span { color: #384806; margin-left: 2em; }
      div.details dd { margin: 0.5em 2em 1em 4em; }
      a.top {
        font-family: Verdana, Helvetica, sans-serif;
        font-size: 8pt;
        font-weight: bold;
        color: #5070ff;
        text-transform: uppercase;
        float: right;
        margin-left: 1em;
      }
      
      /* comments */
      .pre { white-space: pre; }
      
      /* code styles */
      code { font-family: Monaco, "Courier New", Courier, monospace; font-size: 95%; }
      code.listing { white-space: pre; display: block; margin: 0.75em 0 0.75em 0; padding: 0 3em 0 1em; line-height: 1.4em; }
      code.source { white-space: pre; display: block; }
      code.source span.comments { color: #408080; }
      .syntax { margin-top: 1em; margin-left: 1.5em; text-indent: -1.5em; }
      .var { font-style: italic; }
      .argument { } /* white-space: nowrap; does not work in Safari (and sometimes not even in Firefox) */
      
      dl.routine-summary dt { margin-bottom: 0.25em; }
      dl.routine-summary dd { margin-bottom: 0.5em; margin-left: 2em; }
      
      ul.inherited-method-summary { padding-left: 0em; margin-left: 0em; }
      
      /* general styles */
      ul li { list-style-type: none; }
      table { empty-cells: show; }
      thead { color: #871E31; }
      dd { margin-bottom: 0.35em; }
      input, textarea { background: #F3F6ED; border: #E1D6C6 1px solid; padding: 2px 1em 2px 0.5em; }
      input.text { background: #FFFFC0; }
      
      div.note { margin: 1em 2em 1em 2em; background: #EFEFEF; border: 1px #A0A0A0 dotted; padding: 0 1em 0 1em; }
      p.indent { margin-left: 2em; }
      
      /* An attribute table is a vertical list of name-value pairs. */
      table.box {
        background: #EFEFEF;
        border: 1px #A0A0A0 dotted;
        padding-top: 0.75em;
        padding-bottom: 0.75em;
      }
      table.attribute { padding-left: 0.75em; padding-right: 0.75em; }
      table td { vertical-align: top; }
      table.attribute p { margin: 0; }
      table td.name { font-style: normal; padding-right: 1.5em; }
      ul.fieldslist { padding-top: 0; color: #909090; }
      ul.fieldslist li { margin-bottom: 0.25em; }
      span.fieldname { color: #000000; }
      
      dl.attribute dt { color: #990000; }
      
      /* header/navbar styles */
      div.header { padding: 2em 2em 0 2em; background: #9E9D7B; border-bottom: 2px #262626 solid; }
      div.header h1 { color: white; margin:0; font-weight: normal; }
      div.header h2 { color: white; margin-top: 0; margin-bottom: 1em; font-weight: normal; font-style: italic; font-size: 100%; }
      table.navbar { background: #CCC097; margin: 0; padding: 0; border-bottom: 1px #262626 dotted; width: 100%; }
      table.navbar td { padding: 4px 0.5em 3px 0.5em; white-space: nowrap; vertical-align: top; }
      table.navbar td.flexible { width: 100%; text-align: right; padding-right: 1em; white-space: nowrap; }
      table.navbar td.selected { background: #262626; }
      table.navbar td.selected, table.navbar td.selected a { color: white; }
      table.navbar a:hover, table.navbar a:focus { background: inherit; border-bottom: 1px solid #303099; }
      p.localnavbar { text-align: right; margin: 0.2em 1em 0.2em 0.2em; padding: 0; }
      
      /* CSS graphics styles */
      div.box {
        margin-left: 0.25em;
        display: inline-block;
        width: 0.9em;
        height: 0.9em;
        vertical-align: -1px;
      }
      .red { background-color: #A00; }
      .orange { background-color: #F40; }
      .green { background-color: #480; }
      
      /* index styles */
      span.index_type { margin-left: 1em; }
      dl.index_listing dd { margin-bottom: 0.5em; margin-left: 2em; }
      dl.index_listing dd p { margin-top: 0.2em; margin-bottom: 0em; }
      
      /* search styles */
      fieldset { border: #ddd 1px solid; padding: 1em; margin-top: 3em; }
      legend { color: #871E31; font-size: 120%; }
      label { white-space: nowrap; }
      p.description { margin: 2em 2em 1em 2em; }
      form table td.name { vertical-align: middle; }
      
      /* footer styles */
      div.footer { padding: 0.5em 1em 0.5em 1em; background: #EFEFEF; border-top: 1px #A0A0A0 dotted; }
      div.footer table { width: 100%; }
      div.footer td.right { text-align: right; }

    </style>
    <style type="text/css" media="print">
            p.localnavbar { display: none; }
      
      div.header { background: white; }
      div.header h1 { color: black; }
      div.header h2 { color: black; }

    </style>
    

    <script type="text/javascript">
      function setTitle() {
        parent.document.title="jupiter_example.pro (OMINAS API Documentation)";
      }
    </script>
  </head>

  <body onload="setTitle();" id="root">
    <div class="content">
      <code class="source"><span class="comments">; docformat = 'rst'</span>
<span class="comments">;=======================================================================</span>
<span class="comments">;+</span>
<span class="comments">; JUPITER EXAMPLE</span>
<span class="comments">; ---------------</span>
<span class="comments">;</span>
<span class="comments">;   Edited by Mark Moretto</span>
<span class="comments">;   </span>
<span class="comments">;   June 2016</span>
<span class="comments">;</span>
<span class="comments">;    This example file uses an image of Jupiter, its rings, and satellites to</span>
<span class="comments">;    demonstrate various capabilities of the OMINAS software.  This includes</span>
<span class="comments">;    fitting the limb and rings simultaneously, hiding the limb and/or rings wrt</span>
<span class="comments">;    other objects in the field of view, plotting radial and longitudinal</span>
<span class="comments">;    sectors on the ring and generating map projections.</span>
<span class="comments">;</span>
<span class="comments">;    This example file can be executed from the UNIX command line using::</span>
<span class="comments">;</span>
<span class="comments">;     ominas jupiter_example.pro</span>
<span class="comments">;</span>
<span class="comments">;    or from within an OMINAS IDL session using::</span>
<span class="comments">;</span>
<span class="comments">;     @jupiter_example.pro</span>
<span class="comments">;</span>
<span class="comments">;    After the example stops, later code samples in this file may be executed by</span>
<span class="comments">;    pasting them onto the IDL command line.</span>
<span class="comments">;</span>
<span class="comments">;-</span>
<span class="comments">;=======================================================================</span>
!quiet = 1
<span class="comments">;-------------------------------------------------------------------------</span>
<span class="comments">;+</span>
<span class="comments">; Read and display image</span>
<span class="comments">; ----------------------</span>
<span class="comments">;</span>
<span class="comments">; .. image:: jupiter_load.jpeg</span>
<span class="comments">;</span>
<span class="comments">;   This first section uses dat_read to read in the image and then displays </span>
<span class="comments">;   the image using tvim.  </span>
<span class="comments">;</span>
<span class="comments">;   dat_read reads the image portion (im) and the label (label) and returns a </span>
<span class="comments">;   data descriptor (dd) containing the image and label and information obtained</span>
<span class="comments">;   through OMINAS' configuration tables.  If a file exists in the same directory</span>
<span class="comments">;   and with the same name as the image, except with the extension ".dh",</span>
<span class="comments">;   then it is assumed to be a detached header and it is read as well. </span>
<span class="comments">;</span>
<span class="comments">;   The files w1352097259.1 and n1352037683.2 are Cassini wide- and narrow-</span>
<span class="comments">;   angle frames of Jupiter.  2000r.img and 2100r.img are Galileo SSI</span>
<span class="comments">;   images of Ganymede.</span>
<span class="comments">;</span>
<span class="comments">;   tvim is called to display the image (im) in a new window with the y</span>
<span class="comments">;   coordinate as top-down::</span>
<span class="comments">;</span>
<span class="comments">;     file = getenv('OMINAS_DIR')+'/demo/data/N1350122987_2.IMG'     ; Cassini Image</span>
<span class="comments">;     dd = dat_read(file, im, label)</span>
<span class="comments">;     </span>
<span class="comments">;     tvim, im, zoom=0.75, /order, /new</span>
<span class="comments">;</span>
<span class="comments">;-</span>
<span class="comments">;-------------------------------------------------------------------------</span>

 file = getenv('OMINAS_DIR')+'/demo/data/N1350122987_2.IMG'			<span class="comments">; Cassini Image</span>

 dd = dat_read(file, im, label)

 tvim, im, zoom=0.75, /order, /new

<span class="comments">;-------------------------------------------------------------------------</span>
<span class="comments">;+</span>
<span class="comments">; Obtain descriptors</span>
<span class="comments">; ------------------</span>
<span class="comments">;</span>
<span class="comments">;   This section obtains the camera descriptor (cd), planet descriptors</span>
<span class="comments">;   (pd), ring descriptors (rd), and the sun descriptor (sund) for</span>
<span class="comments">;   use with subsequent commands::</span>
<span class="comments">;</span>
<span class="comments">;     cd = pg_get_cameras(dd)</span>
<span class="comments">;     pd = pg_get_planets(dd, od=cd)</span>
<span class="comments">;     rd = pg_get_rings(dd, pd=pd, od=cd)</span>
<span class="comments">;     sund = pg_get_stars(dd, od=cd, name='SUN')</span>
<span class="comments">;</span>
<span class="comments">; NOTES</span>
<span class="comments">; ~~~~~</span>
<span class="comments">;</span>
<span class="comments">;   Because the detached header translator dh_std_input appears before</span>
<span class="comments">;   the Cassini Spice input translator in the default translators table, the</span>
<span class="comments">;   descriptors are taken from the detached header if it exists.  If it doesn't</span>
<span class="comments">;   exist, then they are obtained through the SPICE kernels.</span>
<span class="comments">;</span>
<span class="comments">;   The commented lines show how translator keywords can be passed to </span>
<span class="comments">;   override the keywords given in the translators table.</span>
<span class="comments">;</span>
<span class="comments">;-------------------------------------------------------------------------</span>
<span class="comments">;+</span>

<span class="comments">;   The keyword 'name' could be used in pg_get_planets to select only Jupiter</span>
<span class="comments">;   and the Galilean satellites.  By default, every body that's relevant to</span>
<span class="comments">;   the mission and can be found in the kernel list is returned.  Also, the </span>
<span class="comments">;   SPICE translator organizes the pd array such that pd[0] gives the </span>
<span class="comments">;   primary target of the observation, if one exists. </span>
<span class="comments">;</span>
<span class="comments">;   The keyword 'name' is used in pg_get_stars to select only the Sun.</span>
<span class="comments">;   Otherwise, star catalog stars would also be returned.  Note, however, </span>
<span class="comments">;   that the star catalog is still searched because it does appear in the </span>
<span class="comments">;   translators table.</span>
<span class="comments">;-</span>
<span class="comments">;-------------------------------------------------------------------------</span>
<span class="comments">;cd = pg_get_cameras(dd, 'klist=my_klist.txt')		; Use personal kernel</span>
							                                    <span class="comments">; list file.</span>
<span class="comments">;;;cd = pg_get_cameras(dd, 'ck_in=./test.bc')		; Load the additional</span>
							                                  <span class="comments">; C-kernel test.bc.</span>
<span class="comments">;cd = pg_get_cameras(dd, 'klist=my_klist.txt, $		      ; Use personal kernel</span>
<span class="comments">;                              ck_in=test.bc;test1.bc')	; list file and load two</span>
							                                          <span class="comments">; additional C-kernels.</span>
<span class="comments">;cd = pg_get_cameras(dd, 'ck_in=auto')			; Try to auto-detect</span>
							                              <span class="comments">; appropriate C-kernels.</span>
cd = pg_get_cameras(dd)					<span class="comments">; Use any defaults in </span>
							                  <span class="comments">; translators.tab</span>

<span class="comments">;pd = pg_get_planets(dd, od=cd, $</span>
<span class="comments">;       name=['JUPITER', 'IO', 'EUROPA', 'GANYMEDE', 'CALLISTO'])</span>
<span class="comments">;       name=['SATURN', 'TITAN'])</span>
<span class="comments">; pd = pg_get_planets(dd, od=cd, name=['JUPITER'])</span>

<span class="comments">;pd = pg_get_planets(dd)			; No observer descriptor,</span>
						                  <span class="comments">;  so no aberration corrections</span>
<span class="comments">;;ltcorr, cd, pd, c=pgc_const('c')		; Light-time correction</span>
<span class="comments">;;stellab, cd, pd, c=pgc_const('c')		; Stellar aberration correction</span>
<span class="comments">;abcorr, cd, pd, c=pgc_const('c')		; Light-time and stellar ab.</span>
						<span class="comments">;  corections</span>

pd = pg_get_planets(dd, od=cd)

rd = pg_get_rings(dd, pd=pd, od=cd)
<span class="comments">;rd = pg_get_rings(dd, pd=pd, od=cd, $</span>
<span class="comments">;          name=['MAIN_RING_SYSTEM', 'A_RING', 'B_RING', 'C_RING'])</span>

sund = pg_get_stars(dd, od=cd, name='SUN')


<span class="comments">;-------------------------------------------------------------------------</span>
<span class="comments">;+</span>
<span class="comments">; Create a generic descriptor</span>
<span class="comments">; ---------------------------</span>
<span class="comments">;</span>
<span class="comments">;   This line creates a "generic" descriptor.  This is a convenience</span>
<span class="comments">;   feature wherein several descriptors are grouped into a structure that</span>
<span class="comments">;   can be passed to functions in one piece.  The field names of a generic</span>
<span class="comments">;   descriptor must follow the convention described in pg_description.txt::</span>
<span class="comments">;</span>
<span class="comments">;     gd = {cd:cd, gbx:pd, dkx:rd, sund:sund}</span>
<span class="comments">;</span>
<span class="comments">;   cd - camera descriptor part</span>
<span class="comments">;</span>
<span class="comments">;   gbx - globe descriptor part</span>
<span class="comments">;</span>
<span class="comments">;   dkx - disk descriptor part</span>
<span class="comments">;</span>
<span class="comments">;   sund - sun descriptor part</span>
<span class="comments">;-</span>
<span class="comments">;-------------------------------------------------------------------------</span>
gd = {cd:cd, gbx:pd, dkx:rd, sund:sund}


<span class="comments">;-------------------------------------------------------------------------</span>
<span class="comments">;+</span>
<span class="comments">; Compute geometric features</span>
<span class="comments">; --------------------------</span>
<span class="comments">;</span>
<span class="comments">;   These commands compute the limb of each planet, the edges of the Jovian ring</span>
<span class="comments">;   system, and terminators on each planet::</span>
<span class="comments">;</span>
<span class="comments">;     limb_ptd = pg_limb(gd=gd) & pg_hide, limb_ptd, gd=gd, bx=rd, /rm</span>
<span class="comments">;               pg_hide, limb_ptd, /assoc, gd=gd, bx=pd, od=sund</span>
<span class="comments">;     ring_ptd = pg_disk(gd=gd) & pg_hide, ring_ptd, gd=gd, bx=pd</span>
<span class="comments">;     term_ptd = pg_limb(gd=gd, od=gd.sund) & pg_hide, term_ptd, gd=gd, bx=pd, /assoc</span>
<span class="comments">;</span>
<span class="comments">;     center_ptd = pg_center(gd=gd, bx=pd)</span>
<span class="comments">;     center_o=pnt_points(center_ptd[0])    ;get the center of Jupiter from the points object</span>
<span class="comments">;     print, center_o                       ;display the center of Jupiter</span>
<span class="comments">;     object_ptd = [center_ptd,limb_ptd,ring_ptd,term_ptd]</span>
<span class="comments">;</span>
<span class="comments">;   Note that terminators are computed</span>
<span class="comments">;   using pg_limb by specifying the sun as the observer instead of the camera.</span>
<span class="comments">;-</span>
<span class="comments">;-------------------------------------------------------------------------</span>
limb_ptd = pg_limb(gd=gd) & pg_hide, limb_ptd, gd=gd, bx=rd, /rm
          pg_hide, limb_ptd, /assoc, gd=gd, bx=pd, od=sund
ring_ptd = pg_disk(gd=gd) & pg_hide, ring_ptd, gd=gd, bx=pd
term_ptd = pg_limb(gd=gd, od=gd.sund) & pg_hide, term_ptd, gd=gd, bx=pd, /assoc

center_ptd = pg_center(gd=gd, bx=pd)
center_o=pnt_points(center_ptd[0])
print, center_o
object_ptd = [center_ptd,limb_ptd,ring_ptd,term_ptd]

<span class="comments">;-------------------------------------------------------------------------</span>
<span class="comments">;+</span>
<span class="comments">; Set plot parameters</span>
<span class="comments">; -------------------</span>
<span class="comments">;</span>
<span class="comments">;   The colors, psyms, psizes and plables variables</span>
<span class="comments">;   are defined for the plot.  The center is drawn in the default color</span>
<span class="comments">;   (!p.color), the limb is in yellow (ctyellow) and the inner and outer ring</span>
<span class="comments">;   are in red (ctred).  Here you can see that each ring is treated as two</span>
<span class="comments">;   objects (inner and outer) when defining plot characteristics.  With an</span>
<span class="comments">;   8-bit display, these color routines return the values that were previously</span>
<span class="comments">;   reserved in the color table with ctmod; with a 24-bit display, these</span>
<span class="comments">;   routines return the true color values for these colors.  nlimb stores the</span>
<span class="comments">;   number of points in the limb_ptd structure, nring, the number of points in</span>
<span class="comments">;   the ring point structure.  In plabels, the limb and ring's name is not</span>
<span class="comments">;   plotted since it would be plotted at the center of the object::</span>
<span class="comments">;</span>
<span class="comments">;     ncent=n_elements(center_ptd)</span>
<span class="comments">;     nlimb=n_elements(limb_ptd)</span>
<span class="comments">;     nring=n_elements(ring_ptd)</span>
<span class="comments">;     nterm=n_elements(term_ptd)</span>
<span class="comments">;     colors=[make_array(n_elements(pd),value=!p.color), $</span>
<span class="comments">;             make_array(n_elements(pd),value=ctyellow()), $</span>
<span class="comments">;             make_array(2*n_elements(rd),value=ctred()), $</span>
<span class="comments">;             make_array(nterm,value=ctgreen())]</span>
<span class="comments">;     psyms=[make_array(n_elements(pd),value=1), $</span>
<span class="comments">;             make_array(n_elements(pd),value=3), $</span>
<span class="comments">;             make_array(2*n_elements(rd),value=3), $</span>
<span class="comments">;             make_array(nterm,value=3)]</span>
<span class="comments">;     psizes=1.0</span>
<span class="comments">;     csizes=0.75</span>
<span class="comments">;     plabels=[cor_name(pd), $</span>
<span class="comments">;             make_array(n_elements(pd),value=''), $</span>
<span class="comments">;             make_array(2*n_elements(rd),value=''), $</span>
<span class="comments">;             make_array(nterm,value='')]</span>
<span class="comments">;</span>
<span class="comments">;-</span>
<span class="comments">;-------------------------------------------------------------------------</span>
ncent=n_elements(center_ptd)
nlimb=n_elements(limb_ptd)
nring=n_elements(ring_ptd)
nterm=n_elements(term_ptd)
colors=[make_array(n_elements(pd),value=!p.color), $
        make_array(n_elements(pd),value=ctyellow()), $
        make_array(2*n_elements(rd),value=ctred()), $
        make_array(nterm,value=ctgreen())]
psyms=[make_array(n_elements(pd),value=1), $
       make_array(n_elements(pd),value=3), $
       make_array(2*n_elements(rd),value=3), $
       make_array(nterm,value=3)]
psizes=1.0
csizes=0.75
plabels=[cor_name(pd), $
        make_array(n_elements(pd),value=''), $
        make_array(2*n_elements(rd),value=''), $
        make_array(nterm,value='')]

<span class="comments">;-------------------------------------------------------------------------</span>
<span class="comments">;+</span>
<span class="comments">; Draw the limb, ring and planet center</span>
<span class="comments">; -------------------------------------</span>
<span class="comments">;</span>
<span class="comments">; .. image:: jupiter_limb_initial.jpeg</span>
<span class="comments">;</span>
<span class="comments">; This section draws the objects in the object array (center, limb, ring,</span>
<span class="comments">; and terminator) with the colors and plot symbols and labels defined earlier::</span>
<span class="comments">;</span>
<span class="comments">;     pg_draw, object_ptd, col=colors, psy=psyms, psi=psizes, csi=csizes, pl=plabels</span>
<span class="comments">;</span>
<span class="comments">;-</span>
<span class="comments">;-------------------------------------------------------------------------</span>
pg_draw, object_ptd, col=colors, psy=psyms, psi=psizes, csi=csizes, pl=plabels
stop





<span class="comments">;-------------------------------------------------------------------------</span>
<span class="comments">;+</span>
<span class="comments">; First-cut Automatic repointing</span>
<span class="comments">; ------------------------------</span>
<span class="comments">;</span>
<span class="comments">;   Refine the pointing of the spacecraft by using pg_farfit, which searches</span>
<span class="comments">;   the whole image for a pattern matching the edges calculated using the </span>
<span class="comments">;   descriptors::</span>
<span class="comments">;</span>
<span class="comments">;     edge_ptd = pg_edges(dd, edge=10)                ; Scan image for edges.</span>
<span class="comments">;     pg_draw, edge_ptd</span>
<span class="comments">;     </span>
<span class="comments">;   .. image:: jupiter_ex_edge.jpeg</span>
<span class="comments">;   </span>
<span class="comments">;     dxy = pg_farfit(dd, edge_ptd, [limb_ptd[0]])    ; Try to correlate scanned edges with the computed limb.</span>
<span class="comments">;     pg_repoint, dxy, 0d, axis=center_ptd[0], gd=gd  ; Change the pointing.</span>
<span class="comments">;     tvim, im</span>
<span class="comments">;     pg_draw, object_ptd, colors=colors, psyms=psyms, psizes=psizes, plabel=plabels</span>
<span class="comments">;     </span>
<span class="comments">;   .. image:: jupiter_ex_farfit.jpeg</span>
<span class="comments">;</span>
<span class="comments">;     center_ptd = pg_center(gd=gd, bx=pd)</span>
<span class="comments">;     print, 'after automatic repointing, the center was shifted by:', pnt_points(center_ptd[0])-center_o, 'pixels' </span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">;-</span>
<span class="comments">;-------------------------------------------------------------------------</span>
edge_ptd = pg_edges(dd, edge=10)			<span class="comments">; Scan image for edges.</span>
pg_draw, edge_ptd
dxy = pg_farfit(dd, edge_ptd, [limb_ptd[0]])	<span class="comments">; Try to correlate scanned</span>
					 	<span class="comments">; edges with the computed limb.</span>
pg_repoint, dxy, 0d, axis=center_ptd[0], gd=gd	<span class="comments">; Change the pointing.</span>

limb_ptd = pg_limb(gd=gd) & pg_hide, limb_ptd, gd=gd,bx=rd, /rm
       pg_hide, limb_ptd, /assoc, gd=gd, bx=pd, od=sund
ring_ptd = pg_disk(gd=gd) & pg_hide, ring_ptd, gd=gd, bx=pd
center_ptd = pg_center(gd=gd, bx=pd)
term_ptd = pg_limb(gd=gd, od=gd.sund) & pg_hide, term_ptd, gd=gd, bx=pd, /assoc
object_ptd = [center_ptd,limb_ptd,ring_ptd,term_ptd]

tvim, im
pg_draw, object_ptd, colors=colors, psyms=psyms, psizes=psizes, plabel=plabels

<span class="comments">;added by me</span>
center_ptd = pg_center(gd=gd, bx=pd)
print, 'after automatic repointing, the center was shifted by:', pnt_points(center_ptd[0])-center_o, 'pixels' 
print, dxy



<span class="comments">;-------------------------------------------------------------------------</span>
<span class="comments">;+</span>
<span class="comments">; Manually repoint the geometry</span>
<span class="comments">; -----------------------------</span>
<span class="comments">;</span>
<span class="comments">;   This pasteable section first clears the screen of the plotted points</span>
<span class="comments">;   by redisplaying the image with tvim.  It then calls pg_drag to allow</span>
<span class="comments">;   the user to use the cursor to drag the pointing, and with it the limb,</span>
<span class="comments">;   ring and planet center.  To move the pointing with pg_drag, use the left</span>
<span class="comments">;   mouse button and translate the pointing in x,y.  Use the middle mouse</span>
<span class="comments">;   button to rotate the pointing about an axis (in this case, the axis of</span>
<span class="comments">;   rotation is set as the planet center (center_ptd[0]).  When the</span>
<span class="comments">;   desired pointing is set, the right mouse button accepts it.  pg_drag</span>
<span class="comments">;   returns the delta x,y amount dragged (dxy) as well as the rotation</span>
<span class="comments">;   angle (dtheta).  pg_repoint uses the dxy and dtheta to update the</span>
<span class="comments">;   camera descriptor (cd, passed by gd).  The limb and center is then</span>
<span class="comments">;   recalculated, the image redisplayed to clear the objects drawn, and</span>
<span class="comments">;   then pg_draw is called to replot::</span>
<span class="comments">;</span>
<span class="comments">;     tvim, im</span>
<span class="comments">;     dxy = pg_drag(object_ptd, dtheta=dtheta, axis=center_ptd[0])    ;Do the reponting </span>
<span class="comments">;     pg_repoint, dxy, dtheta, axis=center_ptd[0], gd=gd              ;Modify the general descriptor</span>
<span class="comments">;</span>
<span class="comments">;     ;Recalculate the geometry and redisplay the image with the new overlays</span>
<span class="comments">;</span>
<span class="comments">;     limb_ptd = pg_limb(gd=gd) & pg_hide, limb_ptd, gd=gd, bx=rd, /rm</span>
<span class="comments">;            pg_hide, limb_ptd, /assoc, gd=gd, bx=pd, od=sund</span>
<span class="comments">;     ring_ptd = pg_disk(gd=gd) & pg_hide, ring_ptd, gd=gd, bx=pd</span>
<span class="comments">;     center_ptd = pg_center(gd=gd, bx=pd)</span>
<span class="comments">;     term_ptd = pg_limb(gd=gd, od=gd.sund) & pg_hide, term_ptd, gd=gd, bx=pd, /assoc</span>
<span class="comments">;     object_ptd = [center_ptd,limb_ptd,ring_ptd,term_ptd]</span>
<span class="comments">;</span>
<span class="comments">;     tvim, im</span>
<span class="comments">;     pg_draw, object_ptd, colors=colors, psyms=psyms, psizes=psizes, plabel=plabels</span>
<span class="comments">;</span>
<span class="comments">;-</span>
<span class="comments">;-------------------------------------------------------------------------</span>
tvim, im
dxy = pg_drag(object_ptd, dtheta=dtheta, axis=center_ptd[0])
pg_repoint, dxy, dtheta, axis=center_ptd[0], gd=gd

limb_ptd = pg_limb(gd=gd) & pg_hide, limb_ptd, gd=gd, bx=rd, /rm
       pg_hide, limb_ptd, /assoc, gd=gd, bx=pd, od=sund
ring_ptd = pg_disk(gd=gd) & pg_hide, ring_ptd, gd=gd, bx=pd
center_ptd = pg_center(gd=gd, bx=pd)
term_ptd = pg_limb(gd=gd, od=gd.sund) & pg_hide, term_ptd, gd=gd, bx=pd, /assoc
object_ptd = [center_ptd,limb_ptd,ring_ptd,term_ptd]

tvim, im
pg_draw, object_ptd, colors=colors, psyms=psyms, psizes=psizes, plabel=plabels



<span class="comments">;-------------------------------------------------------------------------</span>
<span class="comments">;+</span>
<span class="comments">; Scan the edge to find the limb and use it to correct the pointing using least-squares.</span>
<span class="comments">; --------------------------------------------------------------------------------------</span>
<span class="comments">;</span>
<span class="comments">;   This section calls pg_cvscan to scan the image around the predicted</span>
<span class="comments">;   limb position and the ring edge position (within width of 80 pixels) and</span>
<span class="comments">;   find the points of highest correlation with a given edge model for each</span>
<span class="comments">;   object (edge_model_nav_limb = limb model used in the VICAR program NAV</span>
<span class="comments">;   and edge_model_nav_ring = ring model from NAV) and zeropoint offset in</span>
<span class="comments">;   the given model (lzero).  These points are then plotted::</span>
<span class="comments">;</span>
<span class="comments">;     cvscan_ptd=pg_cvscan(dd, gd=gd, [limb_ptd[0]], edge=30, width=80, $</span>
<span class="comments">;         model=[make_array(nlimb,val=ptr_new(edge_model_nav_limb(zero=lzero)))], $</span>
<span class="comments">;         mzero=[make_array(nlimb,val=lzero)] )</span>
<span class="comments">;     </span>
<span class="comments">;     tvim, im</span>
<span class="comments">;     pg_draw, cvscan_ptd</span>
<span class="comments">;     </span>
<span class="comments">;   .. image:: jupiter_ex_cvscan.jpeg</span>
<span class="comments">;</span>
<span class="comments">;   The commented command might be more appropriate for images in which</span>
<span class="comments">;   the planet disk is quite small.  In that case, we use a different edge</span>
<span class="comments">;   model (because the nav model cannot be scaled) and we scan a much</span>
<span class="comments">;   narrower region.</span>
<span class="comments">;-</span>
<span class="comments">;-------------------------------------------------------------------------</span>
cvscan_ptd=pg_cvscan(dd, gd=gd, [limb_ptd[0]], edge=30, width=80, $
   model=[make_array(nlimb,val=ptr_new(edge_model_nav_limb(zero=lzero)))], $
   mzero=[make_array(nlimb,val=lzero)] )
<span class="comments">; cvscan_ptd=pg_cvscan(dd, [limb_ptd], edge=30, width=20, $</span>
<span class="comments">;    model=[make_array(nlimb,val=ptr_new(edge_model_atan(10,5, zero=lzero)))], $</span>
<span class="comments">;    mzero=[make_array(nlimb,val=lzero)] )</span>

tvim, im
pg_draw, cvscan_ptd


<span class="comments">;-------------------------------------------------------------------------</span>
<span class="comments">;+</span>
<span class="comments">; Threshold on correlation coefficient</span>
<span class="comments">; ------------------------------------</span>
<span class="comments">;</span>
<span class="comments">;   This section calls pg_threshold to remove points with </span>
<span class="comments">;   unacceptable correlation coefficients.  The /relative flag means that </span>
<span class="comments">;   the minimum and maximum thresholds are taken as a fraction of the maximum</span>
<span class="comments">;   correlation coefficient for each set of points. In this case we use a minimun </span>
<span class="comments">;   correlation coefficent of 0.81 and a maximum of 1.0::</span>
<span class="comments">;</span>
<span class="comments">;     pg_threshold, cvscan_ptd, min=0.81, max=1.0, /rel</span>
<span class="comments">;     tvim, im</span>
<span class="comments">;     pg_draw, cvscan_ptd</span>
<span class="comments">;  </span>
<span class="comments">;-</span>
<span class="comments">;-------------------------------------------------------------------------</span>
pg_threshold, cvscan_ptd, min=0.81, max=1.0, /rel
tvim, im
pg_draw, cvscan_ptd

<span class="comments">;-------------------------------------------------------------------------</span>
<span class="comments">;+</span>
<span class="comments">; Removing regions of bad scan points</span>
<span class="comments">; -----------------------------------</span>
<span class="comments">;</span>
<span class="comments">;   This pasteable section calls pg_select to remove points within a</span>
<span class="comments">;   polygonal region as defined by the cursor.  Click the left mouse</span>
<span class="comments">;   button to mark a point and move the mouse to the next point and</span>
<span class="comments">;   click.  Use the middle mouse button to erase a point and the right</span>
<span class="comments">;   mouse button to end the region.  pg_trim removes the points in the</span>
<span class="comments">;   just defined region.  The scan points are then replotted.</span>
<span class="comments">;   Repeat these statements for each region a user wants to remove::</span>
<span class="comments">;</span>
<span class="comments">;     region = pg_select(dd)</span>
<span class="comments">;     pg_trim, dd, cvscan_ptd, region</span>
<span class="comments">;     tvim, im</span>
<span class="comments">;     pg_draw, cvscan_ptd</span>
<span class="comments">;</span>
<span class="comments">;-</span>
<span class="comments">;-------------------------------------------------------------------------</span>
region = pg_select(dd)
pg_trim, dd, cvscan_ptd, region
tvim, im
pg_draw, cvscan_ptd

<span class="comments">;-------------------------------------------------------------------------</span>
<span class="comments">;+</span>
<span class="comments">; Fit the pointing to the scanned points using least squares</span>
<span class="comments">; ----------------------------------------------------------</span>
<span class="comments">;</span>
<span class="comments">;   This section calls pg_cvscan_coeff to determine the linear least-squares</span>
<span class="comments">;   coefficients for a fit to the image coordinate translation and rotation</span>
<span class="comments">;   that matches the computed curve to the scanned curve. It then calls</span>
<span class="comments">;   pg_fit to do the fit with the calculated coefficients to calculate the</span>
<span class="comments">;   correction in translation (dxy) and rotation (dtheta).  It calls</span>
<span class="comments">;   pg_cvchisq to get the chi square of the fit.  Then calls pg_repoint to</span>
<span class="comments">;   update the pointing. Recalculates the limb and center and replots.</span>
<span class="comments">;   The determination of the curves and their subsequent fit can be </span>
<span class="comments">;   iterated on.  </span>
<span class="comments">;</span>
<span class="comments">;   Note that, as shown, dx, dy, and dtheta are fit.  To fix any of these </span>
<span class="comments">;   parameters use the 'fix' keyword to pg_cvscan_coeff.  For example</span>
<span class="comments">;   with 'fix=2', dtheta will be zero::</span>
<span class="comments">;</span>
<span class="comments">;     fix = [2]</span>
<span class="comments">;     cvscan_cf = pg_cvscan_coeff(cvscan_ptd, axis=center_ptd[0], fix=fix)</span>
<span class="comments">;     dxy = pg_fit([cvscan_cf], dtheta=dtheta)</span>
<span class="comments">;     chisq = pg_chisq(dxy, dtheta, cvscan_ptd, axis=center_ptd[0], fix=fix)</span>
<span class="comments">;     covar = pg_covariance([cvscan_cf])</span>
<span class="comments">;     print, dxy, dtheta*180./!pi, chisq, covar</span>
<span class="comments">;     pg_repoint, dxy, dtheta, axis=center_ptd[0], gd=gd</span>
<span class="comments">;</span>
<span class="comments">;     limb_ptd = pg_limb(gd=gd) & pg_hide, limb_ptd, gd=gd, bx=rd, /rm</span>
<span class="comments">;             pg_hide, limb_ptd, bx=pd, /assoc, gd=gd, od=sund</span>
<span class="comments">;     ring_ptd = pg_disk(gd=gd) & pg_hide, ring_ptd, gd=gd, bx=pd</span>
<span class="comments">;     center_ptd = pg_center(gd=gd, bx=pd)</span>
<span class="comments">;     term_ptd = pg_limb(gd=gd, od=gd.sund) & pg_hide, term_ptd, gd=gd, bx=pd, /assoc</span>
<span class="comments">;     object_ptd = [center_ptd,limb_ptd,ring_ptd,term_ptd]</span>
<span class="comments">;</span>
<span class="comments">;     tvim, im</span>
<span class="comments">;     pg_draw, object_ptd, colors=colors, psyms=psyms, psizes=psizes, plabel=plabels</span>
<span class="comments">;     </span>
<span class="comments">;   .. image:: jupiter_ex_cvscan_repoint.jpeg</span>
<span class="comments">;</span>
<span class="comments">;-</span>
<span class="comments">;-------------------------------------------------------------------------</span>
fix = [2]
cvscan_cf = pg_cvscan_coeff(cvscan_ptd, axis=center_ptd[0], fix=fix)
dxy = pg_fit([cvscan_cf], dtheta=dtheta)
chisq = pg_chisq(dxy, dtheta, cvscan_ptd, axis=center_ptd[0], fix=fix)
covar = pg_covariance([cvscan_cf])
print, dxy, dtheta*180./!pi, chisq, covar
pg_repoint, dxy, dtheta, axis=center_ptd[0], gd=gd

limb_ptd = pg_limb(gd=gd) & pg_hide, limb_ptd, gd=gd, bx=rd, /rm
        pg_hide, limb_ptd, /assoc, gd=gd, bx=pd, od=sund
ring_ptd = pg_disk(gd=gd) & pg_hide, ring_ptd, gd=gd, bx=pd
center_ptd = pg_center(gd=gd, bx=pd)
term_ptd = pg_limb(gd=gd, od=gd.sund) & pg_hide, term_ptd, gd=gd, bx=pd, /assoc
object_ptd = [center_ptd,limb_ptd,ring_ptd,term_ptd]

tvim, im
pg_draw, object_ptd, colors=colors, psyms=psyms, psizes=psizes, plabel=plabels


<span class="comments">;-------------------------------------------------------------------------</span>
<span class="comments">;+</span>
<span class="comments">; Draw planet and ring latitude/longitude grid</span>
<span class="comments">; --------------------------------------------</span>
<span class="comments">;</span>
<span class="comments">; .. image:: jupiter_lat_lon.jpeg</span>
<span class="comments">;</span>
<span class="comments">;   This section calculates a latitude/longitude grid for each planet and a</span>
<span class="comments">;   radius/longitude grid for the rings.  By default it draws 12 latitude</span>
<span class="comments">;   and 12 longitude grid lines.  The longitude grid lines circle the body</span>
<span class="comments">;   and so on a map they will appear as 24 grid lines.  The ring radius grid</span>
<span class="comments">;   uses four grid lines by default between the inner and outer ring radius.</span>
<span class="comments">;   It uses pg_hide to set as not visible the points on the grid behind the</span>
<span class="comments">;   planet and ring for both objects.  It then uses pg_draw to draw the </span>
<span class="comments">;   grid points in blue (ctblue)::</span>
<span class="comments">;</span>
<span class="comments">;     grid_ptd = pg_grid(gd=gd, lat=lat, lon=lon) </span>
<span class="comments">;     pg_hide, grid_ptd, cd=cd, bx=pd, /assoc</span>
<span class="comments">;     pg_hide, grid_ptd, cd=cd, bx=pd, od=sund, /assoc</span>
<span class="comments">;     pg_hide, grid_ptd, gd=gd, bx=rd</span>
<span class="comments">;     pg_draw, grid_ptd, color=ctblue()</span>
<span class="comments">;</span>
<span class="comments">;     plat_ptd = pg_grid(gd=gd, slon=!dpi/2d, lat=lat, nlon=0) </span>
<span class="comments">;     pg_hide, plat_ptd[0], cd=cd, bx=pd[0], /, bx=pd</span>
<span class="comments">;     pg_draw, plat_ptd[0], psym=3, plabel=strtrim(round(lat*180d/!dpi),2), /label_p</span>
<span class="comments">;</span>
<span class="comments">;     plon_ptd = pg_grid(gd=gd, slat=0d, lon=lon, nlat=0) </span>
<span class="comments">;     pg_hide, plon_ptd[0], cd=cd, bx=pd[0], /assoc</span>
<span class="comments">;     pg_draw, plon_ptd[0], psym=3, plabel=strtrim(round(lon*180d/!dpi),2), /label_p</span>
<span class="comments">;</span>
<span class="comments">;     dgrid_ptd=pg_grid(gd=gd, bx=rd) & pg_hide, dgrid_ptd, gd=gd, bx=pd</span>
<span class="comments">;     pg_draw, dgrid_ptd, color=ctpurple()</span>
<span class="comments">;</span>
<span class="comments">;-</span>
<span class="comments">;-------------------------------------------------------------------------</span>
grid_ptd = pg_grid(gd=gd, lat=lat, lon=lon) 
pg_hide, grid_ptd, cd=cd, bx=pd, /assoc
pg_hide, grid_ptd, cd=cd, bx=pd, od=sund, /assoc
pg_hide, grid_ptd, gd=gd, bx=rd
pg_draw, grid_ptd, color=ctblue()

plat_ptd = pg_grid(gd=gd, slon=!dpi/2d, lat=lat, nlon=0) 
pg_hide, plat_ptd[0], cd=cd, bx=pd[0], /assoc
pg_draw, plat_ptd[0], psym=3, plabel=strtrim(round(lat*180d/!dpi),2), /label_p

plon_ptd = pg_grid(gd=gd, slat=0d, lon=lon, nlat=0) 
pg_hide, plon_ptd[0], cd=cd, bx=pd[0], /assoc
pg_draw, plon_ptd[0], psym=3, plabel=strtrim(round(lon*180d/!dpi),2), /label_p


dgrid_ptd=pg_grid(gd=gd, bx=rd) & pg_hide, dgrid_ptd, gd=gd, bx=pd
pg_draw, dgrid_ptd, color=ctpurple()

<span class="comments">;=========================================================================</span>
<span class="comments">;+</span>
<span class="comments">; Generate map projections</span>
<span class="comments">; ------------------------</span>
<span class="comments">;</span>
<span class="comments">;   This section defines a map descriptor for a simple cylindrical projection</span>
<span class="comments">;   using pg_get_maps.  It then calls pg_map to create a map projection and </span>
<span class="comments">;   uses tvim to display it in a new window.  Four different map descriptors </span>
<span class="comments">;   are demonstrated.</span>
<span class="comments">;</span>
<span class="comments">;   We also call pg_grid to calculate a latitude/longitude grid on the map and</span>
<span class="comments">;   then pg_draw to draw the grid in green. For convenience, define a new generic descriptor.  </span>
<span class="comments">;   Note that the map descriptor is used for the cd field. Call pg_limb to calculate the limb </span>
<span class="comments">;   on the map and then pg_draw to draw the grid in purple.</span>
<span class="comments">;</span>
<span class="comments">; Mercator</span>
<span class="comments">; ~~~~~~~~</span>
<span class="comments">;</span>
<span class="comments">;   Map descriptor::</span>
<span class="comments">;</span>
<span class="comments">;     md = pg_get_maps(/over, bx=pd[0], $</span>
<span class="comments">;       type='MERCATOR', $ </span>
<span class="comments">;       fn_data=ptr_new(),size=[400,200])</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; .. image:: jupiter_mercator.jpeg</span>
<span class="comments">;</span>
<span class="comments">; Stereographic</span>
<span class="comments">; ~~~~~~~~~~~~~</span>
<span class="comments">;</span>
<span class="comments">;   Map descriptor::</span>
<span class="comments">;</span>
<span class="comments">;     md = pg_get_maps(/over, bx=pd[0], $</span>
<span class="comments">;       type='STEREOGRAPHIC', $</span>
<span class="comments">;       fn_data=ptr_new(),scale=0.5, $</span>
<span class="comments">;       size=[400,400], center=[!dpi/2d,0d])</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; .. image:: jupiter_stereographic.jpeg</span>
<span class="comments">;</span>
<span class="comments">; Orthographic</span>
<span class="comments">; ~~~~~~~~~~~~</span>
<span class="comments">;</span>
<span class="comments">;   Map descriptor::</span>
<span class="comments">;</span>
<span class="comments">;     md = pg_get_maps(/over, bx=pd[0], $</span>
<span class="comments">;       type='ORTHOGRAPHIC', $</span>
<span class="comments">;       fn_data=ptr_new(), $</span>
<span class="comments">;       size=[400,400], $</span>
<span class="comments">;       center=[!dpi/6d,!dpi])</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; .. image:: jupiter_orthographic.jpeg</span>
<span class="comments">;</span>
<span class="comments">; Rectangular</span>
<span class="comments">; ~~~~~~~~~~~</span>
<span class="comments">;</span>
<span class="comments">;   Map descriptor::</span>
<span class="comments">;</span>
<span class="comments">;     md = pg_get_maps(/over, bx=pd[0], $</span>
<span class="comments">;       type='RECTANGULAR', $</span>
<span class="comments">;       /map_graphic,fn_data=ptr_new(),scale=1.0, $</span>
<span class="comments">;       size=[400,200])</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">; .. image:: jupiter_rectangular.jpeg</span>
<span class="comments">;</span>
<span class="comments">;-</span>
<span class="comments">;-------------------------------------------------------------------------</span>

md = pg_get_maps(/over, bx=pd[0], $
	type='RECTANGULAR', $
	/map_graphic,fn_data=ptr_new(),scale=1.0, $
<span class="comments">;	center=[0d,!dpi],$</span>
<span class="comments">;	size=[800,400] $</span>
	size=[400,200])

md = pg_get_maps(/over, bx=pd[0], $
	type='ORTHOGRAPHIC', $
	fn_data=ptr_new(), $
	size=[400,400], $
	center=[!dpi/6d,!dpi])
<span class="comments">;	center=[!dpi/2d,0] $	; north polar</span>
<span class="comments">;	center=[-!dpi/2d,0] $	; south polar</span>
	

md = pg_get_maps(/over, bx=pd[0], $
	type='STEREOGRAPHIC', $
	fn_data=ptr_new(),scale=0.5, $
	size=[400,400], center=[!dpi/2d,0d])

md = pg_get_maps(/over, bx=pd[0], $
	type='MERCATOR', $	
<span class="comments">;	type='MOLLWEIDE', $	</span>
	fn_data=ptr_new(),size=[400,200])


<span class="comments">;-------------------------------------------------------------------------</span>
<span class="comments">;+</span>
<span class="comments">; Projecting the maps</span>
<span class="comments">; ~~~~~~~~~~~~~~~~~~~</span>
<span class="comments">;</span>
<span class="comments">;   Use the pg_map and the map descriptor to project the image onto a map.</span>
<span class="comments">;   Certain regions, such as rings, could be excluded from the projection</span>
<span class="comments">;   and bounds on the map can be set, if desired::</span>
<span class="comments">;</span>
<span class="comments">;     ;to set projection bounds...</span>
<span class="comments">;     ;bounds = [-30,30,-180,180]*!dpi/180d</span>
<span class="comments">;</span>
<span class="comments">;     mmap = 0</span>
<span class="comments">;     dd_map = pg_map(dd, md=md, gd=gd, bx=pd[0], map=mmap, bounds=bounds)</span>
<span class="comments">;</span>
<span class="comments">;     ; to exclude areas covered by rings...</span>
<span class="comments">;     ;dd_map = pg_map(dd, md=md, gd=gd, bx=pd[0], gbx=pd[0], $</span>
<span class="comments">;     ;          hide_fn='pm_hide_ring', hide_data_p=ptr_new(rd), map=map, bounds=bounds)</span>
<span class="comments">;</span>
<span class="comments">;     tvim, /new, mmap</span>
<span class="comments">;</span>
<span class="comments">;   Call pg_grid to calculate a latitude/longitude grid on the map and</span>
<span class="comments">;   then pg_draw to draw the grid in green.</span>
<span class="comments">;</span>
<span class="comments">;   For convenience, define a new generic descriptor.  Note that the map</span>
<span class="comments">;   descriptor is used for the cd field::</span>
<span class="comments">;</span>
<span class="comments">;     gdm={cd:md, od:cd, gbx:cor_select(pd,'JUPITER'), dkx:rd}</span>
<span class="comments">;</span>
<span class="comments">;     map_grid_ptd = pg_grid(gd=gdm, lat=lat, lon=lon)</span>
<span class="comments">;     plat_ptd = pg_grid(gd=gdm, slon=!dpi/2d, lat=lat, nlon=0)</span>
<span class="comments">;     plon_ptd = pg_grid(gd=gdm, slat=0d, lon=lon, nlat=0)</span>
<span class="comments">;</span>
<span class="comments">;     pg_draw, map_grid_ptd, col=ctgreen()</span>
<span class="comments">;     pg_draw, plat_ptd, psym=7, plabel=strmid(strtrim(lat*180d/!dpi,2),0,3), /label_p</span>
<span class="comments">;     pg_draw, plon_ptd, psym=7, plabel=strmid(strtrim(lon*180d/!dpi,2),0,3), /label_p</span>
<span class="comments">;</span>
<span class="comments">;   Call pg_limb to calculate the limb on the map and then pg_draw to</span>
<span class="comments">;   draw the grid in purple::</span>
<span class="comments">;</span>
<span class="comments">;     map_limb_ptd = pg_limb(gd=gdm)</span>
<span class="comments">;     pg_draw, map_limb_ptd, col=ctred()</span>
<span class="comments">;</span>
<span class="comments">;     map_term_ptd = pg_limb(gd=gdm, od=sund)</span>
<span class="comments">;     pg_draw, map_term_ptd, col=ctyellow()</span>
<span class="comments">;</span>
<span class="comments">;-</span>
<span class="comments">;-------------------------------------------------------------------------</span>

<span class="comments">;to set projection bounds...</span>
<span class="comments">; bounds = [-30,30,-180,180]*!dpi/180d</span>

mmap = 0
dd_map = pg_map(dd, md=md, gd=gd, bx=pd[0], map=mmap, bounds=bounds)

<span class="comments">; to exclude areas covered by rings...</span>
<span class="comments">;dd_map = pg_map(dd, md=md, gd=gd, bx=pd[0], gbx=pd[0], $</span>
<span class="comments">;          hide_fn='pm_hide_ring', hide_data_p=ptr_new(rd), map=map, bounds=bounds)</span>

tvim, /new, mmap



<span class="comments">;-------------------------------------------------------------------------</span>
<span class="comments">; Call pg_grid to calculate a latitude/longitude grid on the map and</span>
<span class="comments">; then pg_draw to draw the grid in green.</span>
<span class="comments">;-------------------------------------------------------------------------</span>

<span class="comments">;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span>
<span class="comments">; For convenience, define a new generic descriptor.  Note that the map</span>
<span class="comments">; descriptor is used for the cd field.</span>
<span class="comments">;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span>

gdm={cd:md, od:cd, gbx:cor_select(pd,'JUPITER'), dkx:rd}

map_grid_ptd = pg_grid(gd=gdm, lat=lat, lon=lon)
plat_ptd = pg_grid(gd=gdm, slon=!dpi/2d, lat=lat, nlon=0)
plon_ptd = pg_grid(gd=gdm, slat=0d, lon=lon, nlat=0)

pg_draw, map_grid_ptd, col=ctgreen()
pg_draw, plat_ptd, psym=7, plabel=strmid(strtrim(lat*180d/!dpi,2),0,3), /label_p
pg_draw, plon_ptd, psym=7, plabel=strmid(strtrim(lon*180d/!dpi,2),0,3), /label_p



<span class="comments">;-------------------------------------------------------------------------</span>
<span class="comments">; Call pg_limb to calculate the limb on the map and then pg_draw to</span>
<span class="comments">; draw the grid in purple.</span>
<span class="comments">;-------------------------------------------------------------------------</span>

map_limb_ptd = pg_limb(gd=gdm)
pg_draw, map_limb_ptd, col=ctred()

map_term_ptd = pg_limb(gd=gdm, od=sund)
pg_draw, map_term_ptd, col=ctyellow()



<span class="comments">;------------------------------------------------</span>
<span class="comments">;+</span>
<span class="comments">; Reproject the previous map</span>
<span class="comments">; --------------------------</span>
<span class="comments">;</span>
<span class="comments">;   A map can be reprojected using a second map descriptor</span>
<span class="comments">;   and the original map descriptor as the camera descriptor::</span>
<span class="comments">;</span>
<span class="comments">;     md1 = pg_get_maps(/over, bx=pd[0], $</span>
<span class="comments">;       type='ORTHOGRAPHIC', $</span>
<span class="comments">;       fn_data=ptr_new(), $</span>
<span class="comments">;       size=[400,400], $</span>
<span class="comments">;       center=[!dpi/6d,!dpi])</span>
<span class="comments">;</span>
<span class="comments">;     map=0</span>
<span class="comments">;     dd_map1 = pg_map(dd_map, md=md1, cd=md, map=map1, bounds=bounds)</span>
<span class="comments">;     tvim, /new, map1</span>
<span class="comments">;</span>
<span class="comments">; .. image:: jupiter_rectangular_to_ortho.jpeg</span>
<span class="comments">;</span>
<span class="comments">;-</span>
<span class="comments">;------------------------------------------------</span>
md1 = pg_get_maps(/over, bx=pd[0], $
	type='ORTHOGRAPHIC', $
<span class="comments">;	type='STEREOGRAPHIC', $</span>
	fn_data=ptr_new(), $
	size=[400,400], $
	center=[!dpi/6d,!dpi])

map=0
dd_map1 = pg_map(dd_map, md=md1, cd=md, map=map1, bounds=bounds)
tvim, /new, map1


stop, '=== Auto-example complete.  Use cut & paste to continue.'

<span class="comments">;=========================================================================</span>
<span class="comments">;+</span>
<span class="comments">; Output the new state</span>
<span class="comments">; --------------------</span>
<span class="comments">;</span>
<span class="comments">;   This section shows how you can save your output.</span>
<span class="comments">;-</span>
<span class="comments">;=========================================================================</span>

<span class="comments">;---------------------------------------------------------------------------</span>
<span class="comments">;+</span>
<span class="comments">; Output descriptors</span>
<span class="comments">; ~~~~~~~~~~~~~~~~~~</span>
<span class="comments">;</span>
<span class="comments">;   These commands write the descriptor information out through the </span>
<span class="comments">;   translators.  The exact behavior is translator-dependent.  The detached </span>
<span class="comments">;   header translator just modifies the detached header (stored in the data</span>
<span class="comments">;   descriptor).  The SPICE output translator writes a C-kernel if a file </span>
<span class="comments">;   name is specified using the ck_out translator keyword (as in the commented</span>
<span class="comments">;   line)::</span>
<span class="comments">;</span>
<span class="comments">;     pg_put_rings, dd, od=gd.cd, rd=rd</span>
<span class="comments">;     pg_put_planets, dd, od=gd.cd, pd=pd</span>
<span class="comments">;     pg_put_cameras, dd, cd=cd</span>
<span class="comments">;     ; cor_set_udata, cd, 'CK_COMMENT', 'This is a comment.'</span>
<span class="comments">;     ; pg_put_cameras, dd, gd=gd, 'ck_out=./test.bc'</span>
<span class="comments">;     ; print, spice_daf_comment('./test.bc')</span>
<span class="comments">;     pg_put_stars, dd, sd=sund, od=gd.cd</span>
<span class="comments">;</span>
<span class="comments">;</span>
<span class="comments">;-</span>
<span class="comments">;---------------------------------------------------------------------------</span>
pg_put_rings, dd, od=gd.cd, rd=rd
pg_put_planets, dd, od=gd.cd, pd=pd
pg_put_cameras, dd, cd=cd
<span class="comments">; cor_set_udata, cd, 'CK_COMMENT', 'This is a comment.'</span>
<span class="comments">; pg_put_cameras, dd, gd=gd, 'ck_out=./test.bc'</span>
<span class="comments">; print, spice_daf_comment('./test.bc')</span>
pg_put_stars, dd, sd=sund, od=gd.cd

<span class="comments">;---------------------------------------------------------------------------</span>
<span class="comments">;+</span>
<span class="comments">; Write image file and header</span>
<span class="comments">; ~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
<span class="comments">;</span>
<span class="comments">;   dat_write writes the image file from the data descriptor.  The detached header</span>
<span class="comments">;   is also written into a file with the same name as the image file except with</span>
<span class="comments">;   the extension '.dh'.  If this file does not already exist, it is created::</span>
<span class="comments">;</span>
<span class="comments">;     split_filename, file, dir, name</span>
<span class="comments">;     dat_write, getenv('OMINAS_DATA')+'/' + name, dd</span>
<span class="comments">;</span>
<span class="comments">;-</span>
<span class="comments">;---------------------------------------------------------------------------</span>
split_filename, file, dir, name
dat_write, getenv('OMINAS_DATA')+'/' + name, dd


<span class="comments">;---------------------------------------------------------------------------</span>
<span class="comments">;+</span>
<span class="comments">; Write map file and header</span>
<span class="comments">; ~~~~~~~~~~~~~~~~~~~~~~~~~</span>
<span class="comments">;</span>
<span class="comments">;   pg_put_maps causes the detached header translator to generate a new detached </span>
<span class="comments">;   header and write the map descriptor into it.</span>
<span class="comments">;</span>
<span class="comments">;   As above, dat_write writes the map image file and the detached header. Notice</span>
<span class="comments">;   that the filetype is given explicitly because the data descriptor was not</span>
<span class="comments">;   created by dat_read, which would have detected the filetype::</span>
<span class="comments">;</span>
<span class="comments">;     pg_put_maps, dd_map, md=md</span>
<span class="comments">;</span>
<span class="comments">;     split_filename, file, dir, name</span>
<span class="comments">;     dat_write, getenv('OMINAS_DATA')+'/' + name + '.map', dd_map, filetype = 'VICAR'</span>
<span class="comments">;</span>
<span class="comments">;   To read the new map file, use dat_read just as the image file was read at the</span>
<span class="comments">;   beginning of this example script.  To read the map descriptor from the</span>
<span class="comments">;   detached header, use::</span>
<span class="comments">;</span>
<span class="comments">;     md = pg_get_maps(dd_map)</span>
<span class="comments">;</span>
<span class="comments">;-</span>
<span class="comments">;---------------------------------------------------------------------------</span>
pg_put_maps, dd_map, md=md

split_filename, file, dir, name
dat_write, getenv('OMINAS_DATA')+'/' + name + '.map', dd_map, filetype = 'VICAR'
<span class="comments">;end</span>
</code>
    </div>
  </body>
</html>