;=============================================================================
; grim_get_n_colors
;
;=============================================================================
function grim_get_n_colors, grim_data, plane=plane, type=type

 if(NOT keyword_set(grim_data)) then grim_data = grim_get_data(plane=plane)
 if(NOT keyword_set(plane)) then plane = grim_get_plane(grim_data)
 type = dat_type(plane.dd)

 return, grim_n_colors(type)
end
;=============================================================================



;=============================================================================
; grim_visible_planes
;
;=============================================================================
function grim_visible_planes, grim_data, plane=plane, current=current
 
 if(NOT keyword_set(plane)) then plane = grim_get_plane(grim_data)

 if(keyword_set(current)) then return, plane
 planes = grim_get_plane(grim_data, /all)

 vis = planes.visibility
 vis[plane.pn] = 1
 w = where(vis EQ 1)


 return, planes[w]
end
;=============================================================================



;=============================================================================
; grim_get_plane_by_xy
;
;=============================================================================
function grim_get_plane_by_xy, grim_data, xy

 planes = grim_visible_planes(grim_data)
 nplanes = n_elements(planes)

 for i=0, nplanes-1 do $
  begin
   im = dat_data(planes[i].dd)		; shouldn't do this
   w = where(im NE 0)
   ww = xy_to_w(im, round(xy))

   www = where(w EQ ww[0])

   if(www[0] NE -1) then return, planes[i]
  end

 return, planes[grim_data.pn]
end
;=============================================================================



;=============================================================================
; grim_test_single_channel
;
;=============================================================================
function grim_test_single_channel, grim_data
 if(NOT keyword_set(grim_data)) then grim_data = grim_get_data(/primary)

 planes = grim_visible_planes(grim_data)
 rgb = planes.rgb

 return, total(rgb) EQ n_elements(planes)*3
end
;=============================================================================



;=============================================================================
; grim_toggle_image
;
;=============================================================================
pro grim_toggle_image, grim_data, plane, no_refresh=no_refresh, bm=bm

 if(NOT plane.image_visible) then $
  begin
   plane.image_visible = 1
   bm = grim_hide_image_bitmap()
  end $
 else $
  begin
   plane.image_visible = 0
   bm = grim_unhide_image_bitmap()
  end

 widget_control, grim_data.toggle_image_button, set_value=bm

 grim_set_plane, grim_data, plane, pn=plane.pn
 grim_set_data, grim_data, grim_data.base
 if(NOT keyword_set(no_refresh)) then grim_refresh, grim_data, /use_pixmap

end
;=============================================================================



;=============================================================================
; grim_toggle_image_overlays
;
;=============================================================================
pro grim_toggle_image_overlays, grim_data, plane, no_refresh=no_refresh

 grim_toggle_image, grim_data, plane, /no_refresh, bm=bmi
 grim_hide_overlays, grim_data, /no_refresh, bm=bmo

; widget_control, grim_data.toggle_image_overlays_button, set_value=bmi AND bmo


 if(NOT keyword_set(no_refresh)) then grim_refresh, grim_data, /use_pixmap
end
;=============================================================================



;=============================================================================
; grim_render_image
;
;=============================================================================
pro grim_render_image, grim_data, plane=plane, image_pts=image_pts

 ;-----------------------------------------
 ; load relevant descriptors
 ;-----------------------------------------
 grim_suspend_events
 cd = grim_get_cameras(grim_data, plane=plane)
 pd = grim_get_planets(grim_data, plane=plane)
 rd = grim_get_rings(grim_data, plane=plane)
 sund = grim_get_sun(grim_data, plane=plane)
 grim_resume_events


 ;-----------------------------------------
 ; load maps
 ;-----------------------------------------
 if(NOT keyword_set(*grim_data.dd_map_p)) then dd_map = pg_load_maps(md=md)
 if(keyword_set(dd_map)) then $
  begin
   *grim_data.dd_map_p = dd_map
   *grim_data.md_map_p = md
  end


 ;-----------------------------------------
 ; render
 ;-----------------------------------------
 bx = append_array(pd, rd)
 dd_map = *grim_data.dd_map_p
 md = *grim_data.md_map_p

 stat = pg_render(/psf, /nodd, show=plane.render_show, $
                    cd=cd, bx=bx, sund=sund, md=md, ddmap=dd_map, map=map, $
                    pht=plane.render_pht_min, $
                    sample=plane.render_sample, $
                    image_ptd=image_pts)

 
 image_pts = reform(image_pts, 2, n_elements(map), /over)
 dat_set_data, plane.dd, map
end
;=============================================================================



;=============================================================================
; grim_image
;
;=============================================================================
function grim_image, grim_data, _data, plane=plane, pn=pn, colormap=colormap, $
                     channel=channel, current=current, xrange=xrange, yrange=yrange

 if(NOT keyword_set(plane)) then plane = grim_get_plane(grim_data)
 ctmod, top=top
 dim = dat_dim(plane.dd)

 ;---------------------------------------
 ; get all visible planes
 ;---------------------------------------
 planes = grim_visible_planes(grim_data, current=current, plane=plane)
 rgb = planes.rgb


 ;---------------------------------------
 ; get appropriate channel if specified
 ;---------------------------------------
 if(defined(channel)) then $
  begin
   w = where(rgb[channel,*] EQ 1)
   if(w[0] EQ -1) then return, 0
   planes = planes[w]
  end
 nplanes = n_elements(planes)


 ;----------------------------------------------------------------------
 ; get output image grid
 ;----------------------------------------------------------------------
 vp = get_viewport_indices(dim, xrange=xrange, yrange=yrange, $
              device_indices=vpi, device_size=device_size, p=data_xy, $
                                                      noclip=plane.rendering)
 if(n_elements(vp) EQ 1) then return, 0



 ;----------------------------------------------------------------------
 ; construct output image by considering only unique data coords and
 ; averaging all visible planes
 ;----------------------------------------------------------------------
 for i=0, nplanes-1 do $
  begin
   ; - - - - - - - - - - - - - - -
   ; get sub image
   ; - - - - - - - - - - - - - - -
   _im = dat_data(planes[i].dd, sample=data_xy)
   max = dat_max(plane.dd)


   ; - - - - - - - - - - - - - - -
   ; apply color map
   ; - - - - - - - - - - - - - - -
   colormap = compute_colormap(planes[i].cmd)
   if(NOT grim_test_single_channel(grim_data)) then $
                 if(keyword_set(channel)) then _channel=channel

   _im = apply_colormap(_im, colormap, channel=_channel, max=max, min=0)

   ; - - - - - - - - - - - - - - -
   ; add current image
   ; - - - - - - - - - - - - - - -
   if(i EQ 0) then $
    begin
     im = _im
     weight = fix(_im<1)
    end $
   else $
    begin
     im = im + _im
     weight = weight + fix(_im<1)
    end

   grim_set_plane, grim_data, plane
  end


 ;----------------------------------------------------------------------
 ; weight average
 ;----------------------------------------------------------------------
 w = where(weight EQ 0)
 if(w[0] NE -1) then weight[w] = 1

 im = im / weight


 ;----------------------------------------------------------------------
 ; create final device image
 ;----------------------------------------------------------------------
 image = make_array(type=size(im, /type), dim=device_size)
 image[vpi] = im


 image = bytscl(image, max=plane.cmd.n_colors)

 return, image
end
;=============================================================================



;=============================================================================
; grim_scale_image
;
;=============================================================================
function grim_scale_image, grim_data, data, r, g, b, current=current, $
     plane=plane, no_scale=no_scale, top=top, xrange=xrange, yrange=yrange

 ;------------------------------------------------------
 ; test for single-channel
 ;------------------------------------------------------
 if(grim_test_single_channel(grim_data)) then $
   image = grim_image(grim_data, data, plane=plane, current=current, xrange=xrange, yrange=yrange) $

 ;------------------------------------------------------------------
 ; otherwise display according to current channel settings 
 ;------------------------------------------------------------------
 else $
  begin
   ctmod, visual=visual

   red = grim_image(grim_data, data, channel=0, current=current, xrange=xrange, yrange=yrange)
   grn = grim_image(grim_data, data, channel=1, current=current, xrange=xrange, yrange=yrange)
   blu = grim_image(grim_data, data, channel=2, current=current, xrange=xrange, yrange=yrange)     

   ;---------------------------------------
   ; pseudo-color (8-bit) display
   ;---------------------------------------
   if(visual EQ 8) then $
    begin
     image = color_quan(red, grn, blu, r, g, b)
     tvlct, r, g, b
     no_scale = 1
    end $
   ;---------------------------------------
   ; otherwise assume decomposed colors
   ;---------------------------------------
   else $
    begin
     sr = size(red, /dim)
     if(NOT keyword_set(red)) then sr = [0l,0l]
     sg = size(grn, /dim)
     if(NOT keyword_set(grn)) then sg = [0l,0l]
     sb = size(blu, /dim)
     if(NOT keyword_set(blu)) then sb = [0l,0l]
     
     xs = max([sr[0], sg[0], sb[0]])
     ys = max([sr[1], sg[1], sb[1]])

     if(xs EQ 0) then return, 0

     image = dblarr(xs, ys, 3)
     if(keyword_set(red)) then image[0:sr[0]-1,0:sr[1]-1,0] = red
     if(keyword_set(grn)) then image[0:sg[0]-1,0:sg[1]-1,1] = grn
     if(keyword_set(blu)) then image[0:sb[0]-1,0:sb[1]-1,2] = blu
    end

  end


 ctmod, top=top
 tvlct, r, g, b, /get

 return, image
end
;=============================================================================



;=============================================================================
; grim_display_image
;
;=============================================================================
pro grim_display_image, grim_data, data, plane=plane, $
       entire=entire, wnum=wnum, doffset=doffset, zoom=zoom, rotate=rotate, order=order, $
       default=default, previous=previous, flip=flip, restore=restore, $
       xsize=xsize, ysize=ysize, offset=offset, top=top, noplot=no_plot, $
       no_scale=no_scale, no_wset=no_wset, no_coord=no_coord, tvimage=tvimage, $
       min=min, max=max, home=home, draw_pixmap=draw_pixmap, current=current, no_copy=no_copy


 dim = dat_dim(plane.dd)

 ;-------------------------------
 ; set tvim coordinate system
 ;-------------------------------
 if(keyword_set(entire)) then $
  begin 
   wset, wnum
   entire_xsize = double(!d.x_size)
   entire_ysize = double(!d.y_size)
   wset, grim_data.wnum

   zoom = min([entire_xsize/dim[0], entire_ysize/dim[1]]) * 0.95

   offset = 0.5 * [dim[0]-entire_xsize/zoom, $
                     dim[1]-entire_ysize/zoom]
  end

 tvim, wnum, /silent, doffset=doffset, zoom=zoom, rotate=rotate, order=order, $
       default=default, previous=previous, flip=flip, restore=restore, $
       xsize=xsize, ysize=ysize, offset=offset, top=top, noplot=no_plot, $
       no_scale=no_scale, no_wset=no_wset, no_coord=no_coord, tvimage=tvimage, $
       min=min, max=max, home=home, draw_pixmap=draw_pixmap, no_copy=no_copy;, erase=erase

 if(NOT plane.image_visible) then return


 ;---------------
 ; scale image
 ;---------------
 tvimage = grim_scale_image(grim_data, data, r, g, b, current=current, $
                                      plane=plane, no_scale=no_scale, top=top)
 if(NOT keyword_set(tvimage)) then $
  begin
   erase
   return
  end

 *grim_data.tv_rp = r
 *grim_data.tv_gp = g
 *grim_data.tv_bp = b
 grim_set_data, grim_data, grim_data.base

 s = size(tvimage)
 image_xsize = s[1]
 image_ysize = s[2]


 if(((where(r-g NE 0))[0] NE -1) OR ((where(g-b NE 0))[0] NE -1)) then $
  begin
   _tvimage = dblarr(image_xsize, image_ysize, 3)
   _tvimage[*,*,0] = apply_colormap(tvimage, r)
   _tvimage[*,*,1] = apply_colormap(tvimage, g)
   _tvimage[*,*,2] = apply_colormap(tvimage, b)
   tvimage = _tvimage
   _tvimage = 0   
  end


 ;---------------------
 ; display image
 ;---------------------
 if(wnum EQ grim_data.wnum) then draw_pixmap = grim_data.redraw_pixmap

;no_scale=0
 tvim, tvimage, /tvimage, /silent, wnum, noplot=no_plot, $
     min=min, max=max, draw_pixmap=draw_pixmap, no_copy=no_copy, $
     no_scale=no_scale

 min = (max = 0)

 if(keyword_set(tvimage)) then $
  begin
   if(NOT defined(min)) then min = min(tvimage)
   if(NOT defined(max)) then max = max(tvimage)
  end

 *grim_data.min_p = min
 *grim_data.max_p = max


end
;=============================================================================



;=============================================================================
; grim_display_plot
;
;=============================================================================
pro grim_display_plot, grim_data, _data, plane=plane, doffset=doffset, $
       wnum=wnum, xrange=xrange, yrange=yrange, no_wset=no_wset, $
       default=default, previous=previous, flip=flip, restore=restore, $
       xsize=xsize, ysize=ysize, position=position, dx=dx, dy=dy, $
       entire=entire, erase=erase, no_coord=no_coord, $
       color=color, nodraw=nodraw, current=current

;print, plane.xrange, plane.yrange

 planes = grim_visible_planes(grim_data, current=current, plane=plane)
 nplanes = n_elements(planes)


 for i=0, nplanes-1 do $
  begin
   if(NOT keyword_set(_data)) then data = dat_data(planes[i].dd) $
   else data = _data

   ;---------------------------------------
   ; set view unless forced
   ;---------------------------------------
   if((NOT keyword_set(default)) $
       AND (NOT keyword_set(previous)) $
       AND (NOT keyword_set(flip)) $
       AND (NOT keyword_set(restore)) ) then $
    begin
     tvgr, grim_data.wnum, get=tvd

     if(NOT keyword_set(xrange)) then $
       if((plane.xrange[0] NE 0) OR (plane.xrange[1] NE 0)) then xrange = plane.xrange $
     else if((tvd.xrange[0] NE 0) OR (tvd.xrange[1] NE 0)) then xrange = tvd.xrange

     if(NOT keyword_set(yrange)) then $
       if((plane.yrange[0] NE 0) OR (plane.yrange[1] NE 0)) then yrange = plane.yrange $
     else $;if((tvd.yrange[0] NE 0) OR (tvd.yrange[1] NE 0)) then yrange = tvd.yrange
      begin
       yarr = data[1,*]
       yrange = [min(yarr), max(yarr)]
      end

     if(NOT keyword_set(position)) then $
       if((planes[i].position[0] NE 0) OR (planes[i].position[1] NE 0)) then position = planes[i].position $
     else if((tvd.position[0] NE 0) OR (tvd.position[1] NE 0)) then position = tvd.position



;   if(NOT keyword_set(xrange)) then $
;    begin
;     if((plane.yrange[0] NE 0) OR (plane.yrange[1] NE 0)) then $
;      begin
;       xrange = plane.xrange
;       yrange = plane.yrange
;       position = plane.position
;      end $
;     else $
;      begin
;       tvgr, grim_data.wnum, get=tvd
;       if((tvd.xrange[0] NE 0) OR (tvd.xrange[1] NE 0)) then $
;        begin
;         xrange = tvd.xrange
;yarr = data[1,*]
;yrange = [min(yarr), max(yarr)]

;;         yrange = tvd.yrange
;         position = tvd.position
;        end
;      end
;    end
  end


   xarr = data[0,*] & yarr = data[1,*]

   parm = planes[i].parm

   ;-----------------------------------------------------------------------
   ; if /entire, set ranges so that entire image is displayed
   ;-----------------------------------------------------------------------
   if(keyword_set(entire)) then $
    begin 
     xrange = [min(xarr), max(xarr)]
     yrange = [min(yarr), max(yarr)]
    end

   ;---------------------
   ; display plot(s)
   ;---------------------
   if(NOT keyword_set(no_color)) then $
    begin
     color = parm.color
;stop
;     if(keyword_set(plane.override_color) $
;               AND (strupcase(plane.override_color) NE 'NONE')) then $
;                                                   color = plane.override_color

    end

   if(keyword_set(doffset)) then $
    begin
     dx = doffset[0]
     dy = doffset[1]
    end

   if(i GT 0) then erase = 0
 
   tvgr, wnum, xarr, yarr, xrange=xrange, yrange=yrange, no_wset=no_wset, $
       default=default, previous=previous, flip=flip, restore=restore, $
       xsize=xsize, ysize=ysize, position=position, dx=dx, dy=dy, $
       entire=entire, erase=erase, no_coord=no_coord, $
       xtitle=plane.xtitle, ytitle=plane.ytitle, $
       title=plane.title, thick=parm.thick, nsum=parm.nsum, color=color, $
       psym=parm.psym, symsize=parm.symsize;, nodraw=nodraw

  end





 ;----------------------------
 ; save view
 ;----------------------------
 tvgr, grim_data.wnum, get=tvd
 plane.xrange = tvd.xrange
 plane.yrange = tvd.yrange

 ;-----------------------------------
 ; tie xranges of all planes
 ;-----------------------------------
 all_planes = grim_get_plane(grim_data, /all, pn=pn)
 nall = n_elements(all_planes)
 for i=0, nall-1 do if(pn[i] NE plane.pn) then $ 
  begin
   all_planes[i].xrange = plane.xrange
   grim_set_plane, grim_data, all_planes[i], pn=pn[i]
  end



 plane.position = tvd.position
 grim_set_plane, grim_data, plane, pn=plane.pn



end
;=============================================================================



;=============================================================================
; grim_display
;
;=============================================================================
pro grim_display, grim_data, data, plane=plane, wnum=wnum, home=home, $
       no_image=no_image, no_axes=no_axes, doffset=doffset, no_erase=no_erase, $
       zoom=zoom, rotate=rotate, order=order, xsize=xsize, ysize=ysize, offset=offset, $
       default=default, previous=previous, flip=flip, restore=restore,$
       use_pixmap=use_pixmap, pixmap_box_center=pixmap_box_center, no_copy=no_copy, $
       pixmap_box_side=pixmap_box_side, no_back=no_back, entire=entire, $
       no_wset=no_wset, no_coord=no_coord, tvimage=tvimage, no_plot=no_plot, $
       nodraw=nodraw, xrange=xrange, yrange=yrange, dx=dx, dy=dy, current=current, $
       pixmap_to_use=pixmap_to_use

 erase = 1
 if(keyword_set(no_erase)) then erase = 0
 no_scale = 1


 if(NOT keyword_set(pixmap_to_use)) then pixmap_to_use = grim_data.pixmap

 if(NOT keyword_set(plane)) then plane = grim_get_plane(grim_data)
 if(NOT keyword_set(wnum)) then wnum = grim_data.wnum


 ;------------------------------------------------------
 ; if image display is off then just erase
 ;------------------------------------------------------
 if(NOT plane.image_visible) then erase $
 ;------------------------------------------------------------
 ; otherwise if /use_pixmap then just copy from stored image
 ;------------------------------------------------------------
 else if((keyword_set(use_pixmap)) AND (grim_data.pixmap_valid)) then $
  begin
   if(plane.image_visible) then $
    begin
     x0 = 0 & y0 = 0
     xsize = !d.x_size-1 
     ysize = !d.y_size-1

     if(keyword_set(pixmap_box_center)) then $
      begin 
       x0 = (pixmap_box_center[0] - pixmap_box_side/2) > 0
       y0 = (pixmap_box_center[1] - pixmap_box_side/2) > 0
       xsize = pixmap_box_side < $
                        abs(xsize - pixmap_box_center[0] + pixmap_box_side/2)
       ysize = pixmap_box_side < $
                        abs(ysize - pixmap_box_center[1] + pixmap_box_side/2)
      end

     wset, wnum
     if((x0 GE 0) AND (x0 LT !d.x_size) AND $
        (y0 GE 0) AND (y0 LT !d.y_size) AND $
        (xsize GT 0) AND (ysize GT 0)) then $
               device, copy=[x0,y0, xsize,ysize, x0,y0, pixmap_to_use]
   end
  end 
 ;------------------------------------------------------
 ; otherwise generate a new image
 ;------------------------------------------------------
 if(grim_data.type NE 'plot') then $
     grim_display_image, grim_data, data, plane=plane, no_copy=no_copy, $
       entire=entire, wnum=wnum, doffset=doffset, zoom=zoom, rotate=rotate, order=order, $
       default=default, previous=previous, flip=flip, restore=restore, $
       xsize=xsize, ysize=ysize, offset=offset, top=top, noplot=no_plot, $
       no_scale=no_scale, no_wset=no_wset, no_coord=no_coord, tvimage=tvimage, $
       min=min, max=max, home=home, draw_pixmap=draw_pixmap, current=current $

 else grim_display_plot, grim_data, data, plane=plane, doffset=doffset, $
       wnum=wnum, xrange=xrange, yrange=yrange, no_wset=no_wset, $
       default=default, previous=previous, flip=flip, restore=restore, $
       xsize=xsize, ysize=ysize, position=position, dx=dx, dy=dy, current=current, $
       entire=entire, erase=erase, no_coord=no_coord, color=color, nodraw=nodraw


 ;-------------------------------------
 ; copy to backing pixmap
 ;-------------------------------------
 if(NOT keyword_set(no_back)) then $
  begin
   wnum = !d.window
   wset, pixmap_to_use
   device, copy=[0,0, !d.x_size-1,!d.y_size-1, 0,0, wnum]
   wset, wnum
  end


end
;=============================================================================



;=============================================================================
; grim_show_context_image
;
;=============================================================================
pro grim_show_context_image, grim_data

 wset, grim_data.context_wnum
 device, copy=[0,0, !d.x_size-1,!d.y_size-1, 0,0, grim_data.context_pixmap]
 wset, grim_data.wnum

end
;=============================================================================



;=============================================================================
; grim_show_axes
;
;  inertial axes:	blue
;  sun direction:	yellow
;  camera axes:		red
;  dir. to primary:	green
;
;  Axis source is just in front of the camera.
;
;=============================================================================
pro grim_show_axes, grim_data, plane
@grim_constants.common

 if(NOT keyword_set(plane)) then plane = grim_get_plane(grim_data)
 widget_control, grim_data.axes_base, xoff=0, yoff=!d.y_size-AXES_SIZE

 ;---------------------------------
 ; clear axes window
 ;---------------------------------
 wnum = !d.window
 wset, grim_data.axes_wnum
 erase
 wset, wnum

 ;---------------------------------
 ; draw axis vectors
 ;---------------------------------
 if(NOT grim_test_map(grim_data)) then $
  if(grim_data.axes_flag) then $
   if(keyword_set(*plane.cd_p)) then $ 
    begin
     ;- - - - - - - - - - - - - - - - - - - - - - - - - - -
     ; compute source location
     ;- - - - - - - - - - - - - - - - - - - - - - - - - - -
     device_pt = [AXES_SIZE/2, AXES_SIZE/2]
     image_pt = (convert_coord(device_pt[0], device_pt[1], /device, /to_data))[0:1]

     cd = *plane.cd_p
     dir = image_to_inertial(cd, image_pt)
     source = bod_pos(cd) + dir*100000d 

     ;- - - - - - - - - - - - - - - - - - - - - - - - - - -
     ; compute length in data units
     ;- - - - - - - - - - - - - - - - - - - - - - - - - - -
     device_len = AXES_SIZE/3
     device_corners = [tr([0,0]), tr([!d.x_size-1,0])]
     image_corners = (convert_coord(device_corners[0,*], device_corners[1,*], $
                                                    /device, /to_data))[0:1,*]
     len = device_len * p_mag(image_corners[*,0]-image_corners[*,1])/!d.x_size

     ;- - - - - - - - - - - - - - - - - - - - - - - - - - -
     ; draw inertial axes
     ;- - - - - - - - - - - - - - - - - - - - - - - - - - -
     pg_draw_vector, cd=cd, source, (bod_orient(bod_inertial())), $
         plab=['x','y','z'], col='blue', len=len, draw_wnum=grim_data.axes_wnum, $
         label_shade=0.75

     ;- - - - - - - - - - - - - - - - - - - - - - - - - - -
     ; draw camera axes
     ;- - - - - - - - - - - - - - - - - - - - - - - - - - -
     pg_draw_vector, cd=cd, source, (bod_orient(cd)), $
         plab=['cx','cy','cz'], col='red', len=len, draw_wnum=grim_data.axes_wnum, $
         label_shade=0.75

     ;- - - - - - - - - - - - - - - - - - - - - - - - - - -
     ; draw sun vector
     ;- - - - - - - - - - - - - - - - - - - - - - - - - - -
     if(keyword_set(*plane.sund_p)) then $
       pg_draw_vector, cd=cd, source, /noshort, /fix, $
         v_unit(bod_pos(*plane.sund_p) - bod_pos(cd)), $
         plab=['SUN'], col='yellow', len=len, draw_wnum=grim_data.axes_wnum, $
         label_shade=0.75

     ;- - - - - - - - - - - - - - - - - - - - - - - - - - -
     ; draw primary planet vector
     ;- - - - - - - - - - - - - - - - - - - - - - - - - - -
     if(keyword_set(*plane.pd_p)) then $
      begin
       pd = get_primary(cd, *plane.pd_p)
       pg_draw_vector, cd=cd, source, /noshort, /fix, $
         v_unit(bod_pos(pd) - bod_pos(cd)), $
         plab=cor_name(pd), col='green', len=len, draw_wnum=grim_data.axes_wnum, $
         label_shade=0.75
      end
    end

 ;----------------------------
 ; axes window outline
 ;----------------------------
 wset, grim_data.axes_wnum
 plots, /device, col=ctblue(), $
     [0,!d.x_size-1,!d.x_size-1,0,0], [0,0,!d.y_size-1,!d.y_size-1,0], th=4
 grim_wset, grim_data, grim_data.wnum

end
;=============================================================================



;=============================================================================
; grim_add_refresh_callback
;
;=============================================================================
pro grim_add_refresh_callback, callbacks, data_ps, top=top, no_wset=no_wset

 grim_data = grim_get_data(top, no_wset=no_wset)

 rf_callbacks = *grim_data.rf_callbacks_p
 rf_data_ps = *grim_data.rf_callbacks_data_pp

 grim_add_callback, callbacks, data_ps, rf_callbacks, rf_data_ps

 *grim_data.rf_callbacks_p = rf_callbacks
 *grim_data.rf_callbacks_data_pp = rf_data_ps

 grim_set_data, grim_data, grim_data.base
end
;=============================================================================



;=============================================================================
; grim_rm_refresh_callback
;
;=============================================================================
pro grim_rm_refresh_callback, data_ps, top=top

 grim_data = grim_get_data(top)
 if(NOT grim_exists(grim_data)) then return

 rf_callbacks = *grim_data.rf_callbacks_p
 rf_data_ps = *grim_data.rf_callbacks_data_pp

 grim_rm_callback, data_ps, rf_callbacks, rf_data_ps

 *grim_data.rf_callbacks_p = rf_callbacks
 *grim_data.rf_callbacks_data_pp = rf_data_ps

 grim_set_data, grim_data, grim_data.base
end
;=============================================================================



;=============================================================================
; grim_call_refresh_callbacks
;
;=============================================================================
pro grim_call_refresh_callbacks, grim_data

 grim_call_callbacks, *grim_data.rf_callbacks_p, *grim_data.rf_callbacks_data_pp

end
;=============================================================================



;=============================================================================
; grim_title
;
;=============================================================================
function grim_title, plane, primary=primary

 if(NOT keyword_set(plane)) then $
  begin
   grim_data = grim_get_data(primary=primary)
   plane = grim_get_plane(grim_data)
  end

 if(NOT keyword_set(plane.filename)) then name = cor_name(plane.dd) $
 else split_filename, plane.filename, dir, name

 return, name[0]
end
;=============================================================================



;=============================================================================
; grim_refresh
;
;=============================================================================
pro grim_refresh, grim_data, wnum=wnum, plane=plane, $
 no_image=no_image, no_objects=no_objects, no_axes=no_axes, $
 no_title=no_title, home=home, xrange=xrange, yrange=yrange, $
 doffset=doffset, no_erase=no_erase, zoom=zoom, rotate=rotate, order=order, $
 default=default, previous=previous, flip=flip, restore=restore, $
 xsize=xsize, ysize=ysize, offset=offset, use_pixmap=use_pixmap, $
 pixmap_box_center=pixmap_box_center, pixmap_box_side=pixmap_box_side, $
 context=context, entire=entire, noglass=noglass, no_wset=no_wset, $
 no_context=no_context, no_callback=no_callback, no_back=no_back, $
 no_coord=no_coord, tvimage=tvimage, no_plot=no_plot, just_image=just_image, $
 dx=dx, dy=dy, update=update, current=current, no_copy=no_copy, no_main=no_main, $
 no_user=no_user
@grim_block.include


 if(NOT keyword_set(grim_data)) then grim_data = grim_get_data(plane=plane) 
 if(NOT keyword_set(noglass)) then widget_control, grim_data.draw, /hourglass
 if(NOT keyword_set(no_wset)) then grim_wset, grim_data, grim_data.wnum


 grim_data.guideline_save_xy = [-1,-1]

 if(NOT keyword_set(plane)) then $
  begin
   plane = grim_get_plane(grim_data)
   planes = grim_get_visible_planes(grim_data)
  end $
 else planes = plane

 grim_update_shadows, grim_data, plane=plane

 ;-----------------------------------
 ; apply any default activations
 ;-----------------------------------
; grim_default_activations, grim_data, plane=plane


 ;-----------------------------------
 ; redraw main image
 ;-----------------------------------
 if(NOT keyword_set(no_image)) then $
  if(NOT keyword_set(no_main)) then $
   begin
    grim_display, grim_data, data, wnum=wnum, plane=plane, xrange=xrange, yrange=yrange, $
         no_axes=no_axes, doffset=doffset, no_wset=no_wset, no_back=no_back, $
         no_erase=no_erase, zoom=zoom, rotate=rotate, order=order, entire=entire, $
         default=default, previous=previous, flip=flip, restore=restore, $
         xsize=xsize, ysize=ysize, offset=offset, use_pixmap=use_pixmap, $
         pixmap_box_center=pixmap_box_center, pixmap_box_side=pixmap_box_side, $
         no_coord=no_coord, tvimage=tvimage, no_plot=no_plot, home=home, $
         dx=dx, dy=dy, current=current, no_copy=no_copy
   end


 ;-----------------------------------
 ; redraw context image
 ;-----------------------------------
 if(NOT keyword_set(no_context)) then $
  if(NOT keyword_set(no_image)) then $
   if(grim_data.context_mapped) then $
    begin
     tvim, grim_data.wnum, get=tvd, /no_coord

     grim_display, grim_data, data, wnum=grim_data.context_pixmap, plane=plane, $
;           use_pixmap=use_pixmap, pixmap_to_use=grim_data.context_pixmap, $
           /entire, order=tvd.order, nodraw=nodraw, /no_back

     grim_display, grim_data, data, wnum=grim_data.context_wnum, plane=plane, $
           /entire, order=tvd.order, /no_back, /no_image, /no_erase, nodraw=nodraw
     grim_wset, grim_data, grim_data.wnum
    end


 ;------------------------------------
 ; redisplay grids
 ;------------------------------------
 if(NOT keyword_set(no_axes)) then $
           grim_draw_grids, grim_data, plane=plane, no_wset=no_wset


 ;-----------------------------------
 ; redraw overlays
 ;-----------------------------------
 if(NOT keyword_set(no_objects)) then $
          grim_draw, grim_data, plane=planes, /all, update=update, no_user=no_user


 ;------------------------------------
 ; redisplay axes
 ;------------------------------------
 if(NOT keyword_set(no_axes)) then $
           grim_draw_axes, grim_data, data, plane=plane, $
                                   no_context=no_context, no_wset=no_wset


 ;------------------------------------------
 ; copy context image to screen if mapped
 ;------------------------------------------
 if(NOT keyword_set(no_context)) then $
        if(grim_data.context_mapped) then grim_show_context_image, grim_data


 ;-----------------------------------
 ; set base title
 ;-----------------------------------
 if(NOT keyword_set(no_title)) then $
  begin
   beta = ''
   if(grim_data.beta) then beta = '(beta)'
   title = 'grim' + beta + ' ' + strtrim(grim_data.grnum,2) + $
           ';  plane ' + strtrim(grim_data.pn,2) + ' of ' + $
           strtrim(grim_data.n_planes,2) + ';  ' + grim_title(plane)

   widget_control, grim_data.base,  tlb_set_title = title
  end


 ;-----------------------------------
 ; clear out plane text box
 ;-----------------------------------
 widget_control, grim_data.jumpto_text, set_value=''


 ;-----------------------------------
 ; update menu item sensitivity
 ;-----------------------------------
 menu_ids = *grim_data.menu_ids_p
 menu_desc = *grim_data.menu_desc_p
 if(grim_test_map(grim_data, plane=plane)) then $
  begin
   ;- - - - - - - - - - - - - - - - - - - - -
   ; allowed menu items
   ;- - - - - - - - - - - - - - - - - - - - -
   md_items = *grim_data.map_items_p
   if(keyword_set(*plane.od_p)) then $
       md_items = append_array(md_items, *grim_data.od_map_items_p)

   mark = bytarr(n_elements(menu_ids))

   n = n_elements(md_items)
   for i=0, n-1 do $
    begin
     w = where(strpos(menu_desc, md_items[i]) NE -1)
     if(w[0] NE -1) then $
      begin
       widget_control, menu_ids[w[0]], sensitive=1
       mark[w[0]] = 1
      end
    end

   w = where(mark EQ 0)
   if(w[0] NE -1) then for i=0, n_elements(w)-1 do $
               widget_control, menu_ids[w[i]], sensitive=0
  end $
 else $
  begin
   n = n_elements(menu_ids)
   for i=0, n-1 do widget_control, menu_ids[i], sensitive=1
  end


 ;-----------------------------------
 ; update undo/redo sensitivity
 ;-----------------------------------
 nhist = dat_nhist(plane.dd)
 sens = nhist GT 1
 widget_control, grim_data.undo_button, sensitive=sens
 widget_control, grim_data.undo_menu_id, sensitive=sens
 widget_control, grim_data.redo_button, sensitive=sens
 widget_control, grim_data.redo_menu_id, sensitive=sens


 ;-----------------------------------
 ; update render button
 ;-----------------------------------
 if(grim_data.type NE 'plot') then $
  begin
   bm = grim_render_bitmap()
   if(plane.rendering) then bm = grim_unrender_bitmap()
   widget_control, grim_data.render_button, set_value=bm
  end

 ;-----------------------------------
 ; update active and primary arrays
 ;-----------------------------------
 grim_update_activated, grim_data, plane=plane


 ;-----------------------------------
 ; cull descriptors
 ;-----------------------------------
; grim_cull_descriptors, grim_data


 ;-----------------------------------
 ; update header window
 ;-----------------------------------
 if(widget_info(grim_data.header_text, /valid)) then $
  begin
   widget_control, grim_data.header_text, set_value=dat_header(plane.dd)
   widget_control, grim_data.header_base, tlb_set_title=grim_title(plane)
  end


 ;-----------------------------------
 ; update notes window
 ;-----------------------------------
 if(widget_info(grim_data.notes_text, /valid)) then $
  begin
   widget_control, grim_data.notes_text, set_value=*plane.notes_p
   widget_control, grim_data.notes_base, tlb_set_title=grim_title(plane)
  end

 
 ;-----------------------------------
 ; update _all_tops list
 ;-----------------------------------
 w = -1
 if(keyword_set(_all_tops)) then w = where(_all_tops EQ grim_data.base)
 if(w[0] EQ -1) then _all_tops = append_array(_all_tops, grim_data.base)


 ;-----------------------------------
 ; contact refresh callbacks
 ;-----------------------------------
 if(NOT keyword_set(no_callback)) then $
  begin
   grim_call_refresh_callbacks, grim_data
   grim_call_primary_callbacks
  end

 grim_wset, grim_data, grim_data.wnum

; nv_flush
end
;=============================================================================



